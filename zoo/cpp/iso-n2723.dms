translation-unit = declaration-seq? ;
declaration-seq = declaration ;
declaration-seq = declaration-seq declaration ;
declaration = block-declaration ;
declaration = function-definition ;
declaration = template-declaration ;
declaration = explicit-instantiation ;
declaration = explicit-specialization ;
declaration = linkage-specification ;
declaration = namespace-definition ;
block-declaration = simple-declaration ;
block-declaration = asm-definition ;
block-declaration = namespace-alias-definition ;
block-declaration = using-declaration ;
block-declaration = using-directive ;
block-declaration = static_assert-declaration ;
block-declaration = alias-declaration ;
simple-declaration = decl-specifier-seq? init-declarator-list? ';' ;
decl-specifier-seq = decl-specifier-seq? decl-specifier ;
decl-specifier = storage-class-specifier ;
decl-specifier = type-specifier ;
decl-specifier = function-specifier ;
decl-specifier = 'friend' ;
decl-specifier = 'typedef' ;
decl-specifier = 'constexpr' ;
decl-specifier = alignment-specifier ;
storage-class-specifier = 'register' ;
storage-class-specifier = 'static' ;
storage-class-specifier = 'thread_local' ;
storage-class-specifier = 'extern' ;
storage-class-specifier = 'mutable' ;
type-specifier = simple-type-specifier ;
type-specifier = class-specifier ;
type-specifier = enum-specifier ;
type-specifier = elaborated-type-specifier ;
type-specifier = typename-specifier ;
type-specifier = cv-qualifier ;
simple-type-specifier = '::'? nested-name-specifier? type-name ;
simple-type-specifier = '::'? nested-name-specifier 'template' simple-template-id ;
simple-type-specifier = 'char' ;
simple-type-specifier = 'char16_t' ;
simple-type-specifier = 'char32_t' ;
simple-type-specifier = 'wchar_t' ;
simple-type-specifier = 'bool' ;
simple-type-specifier = 'short' ;
simple-type-specifier = 'int' ;
simple-type-specifier = 'long' ;
simple-type-specifier = 'signed' ;
simple-type-specifier = 'unsigned' ;
simple-type-specifier = 'float' ;
simple-type-specifier = 'double' ;
simple-type-specifier = 'void' ;
simple-type-specifier = 'auto' ;
simple-type-specifier = 'decltype' '(' expression ')' ;
nested-name-specifier = type-name '::' ;
nested-name-specifier = namespace-name '::' ;
nested-name-specifier = nested-name-specifier IDENTIFIER '::' ;
nested-name-specifier = nested-name-specifier 'template'? simple-template-id '::' ;
type-name = class-name ;
type-name = enum-name ;
type-name = typedef-name ;
class-name = IDENTIFIER ;
class-name = simple-template-id ;
simple-template-id = template-name '<' template-argument-list? '>' ;
template-name = IDENTIFIER ;
template-argument-list = template-argument '...'? ;
template-argument-list = template-argument-list ',' template-argument '...'? ;
template-argument = constant-expression ;
template-argument = type-id ;
template-argument = id-expression ;
constant-expression = conditional-expression ;
conditional-expression = logical-or-expression ;
conditional-expression = logical-or-expression '?' expression ':' assignment-expression ;
logical-or-expression = logical-and-expression ;
logical-or-expression = logical-or-expression '||' logical-and-expression ;
logical-and-expression = inclusive-or-expression ;
logical-and-expression = logical-and-expression '&&' inclusive-or-expression ;
inclusive-or-expression = exclusive-or-expression ;
inclusive-or-expression = inclusive-or-expression '|' exclusive-or-expression ;
exclusive-or-expression = and-expression ;
exclusive-or-expression = exclusive-or-expression '^' and-expression ;
and-expression = equality-expression ;
and-expression = and-expression '&' equality-expression ;
equality-expression = relational-expression ;
equality-expression = equality-expression '==' relational-expression ;
equality-expression = equality-expression '!=' relational-expression ;
relational-expression = shift-expression ;
relational-expression = relational-expression '<' shift-expression ;
relational-expression = relational-expression '>' shift-expression ;
relational-expression = relational-expression '<=' shift-expression ;
relational-expression = relational-expression '>=' shift-expression ;
shift-expression = additive-expression ;
shift-expression = shift-expression '<<' additive-expression ;
shift-expression = shift-expression '>>' additive-expression ;
additive-expression = multiplicative-expression ;
additive-expression = additive-expression '+' multiplicative-expression ;
additive-expression = additive-expression '-' multiplicative-expression ;
multiplicative-expression = pm-expression ;
multiplicative-expression = multiplicative-expression '*' pm-expression ;
multiplicative-expression = multiplicative-expression '/' pm-expression ;
multiplicative-expression = multiplicative-expression '%' pm-expression ;
pm-expression = cast-expression ;
pm-expression = pm-expression '.*' cast-expression ;
pm-expression = pm-expression '->*' cast-expression ;
cast-expression = unary-expression ;
cast-expression = '(' type-id ')' cast-expression ;
unary-expression = postfix-expression ;
unary-expression = '++' cast-expression ;
unary-expression = '--' cast-expression ;
unary-expression = unary-operator cast-expression ;
unary-expression = 'sizeof' unary-expression ;
unary-expression = 'sizeof' '(' type-id ')' ;
unary-expression = 'sizeof' '...' '(' IDENTIFIER ')' ;
unary-expression = 'alignof' '(' type-id ')' ;
unary-expression = new-expression ;
unary-expression = delete-expression ;
postfix-expression = primary-expression ;
postfix-expression = postfix-expression '[' expression ']' ;
postfix-expression = postfix-expression '[' braced-init-list ']' ;
postfix-expression = postfix-expression '(' expression-list? ')' ;
postfix-expression = simple-type-specifier '(' expression-list? ')' ;
postfix-expression = typename-specifier '(' expression-list? ')' ;
postfix-expression = simple-type-specifier braced-init-list ;
postfix-expression = typename-specifier braced-init-list ;
postfix-expression = postfix-expression '.' 'template'? id-expression ;
postfix-expression = postfix-expression '->' 'template'? id-expression ;
postfix-expression = postfix-expression '.' pseudo-destructor-name ;
postfix-expression = postfix-expression '->' pseudo-destructor-name ;
postfix-expression = postfix-expression '++' ;
postfix-expression = postfix-expression '--' ;
postfix-expression = 'dynamic_cast' '<' type-id '>' '(' expression ')' ;
postfix-expression = 'static_cast' '<' type-id '>' '(' expression ')' ;
postfix-expression = 'reinterpret_cast' '<' type-id '>' '(' expression ')' ;
postfix-expression = 'const_cast' '<' type-id '>' '(' expression ')' ;
postfix-expression = 'typeid' '(' expression ')' ;
postfix-expression = 'typeid' '(' type-id ')' ;
primary-expression = literal ;
primary-expression = 'this' ;
primary-expression = '(' expression ')' ;
primary-expression = id-expression ;
primary-expression = lambda-expression ;
expression = assignment-expression ;
expression = expression ',' assignment-expression ;
assignment-expression = conditional-expression ;
assignment-expression = logical-or-expression assignment-operator initializer-clause ;
assignment-expression = throw-expression ;
assignment-operator = '=' ;
assignment-operator = '*=' ;
assignment-operator = '/=' ;
assignment-operator = '%=' ;
assignment-operator = '+=' ;
assignment-operator = '-=' ;
assignment-operator = '>>=' ;
assignment-operator = '<<=' ;
assignment-operator = '&=' ;
assignment-operator = '^=' ;
assignment-operator = '|=' ;
initializer-clause = assignment-expression ;
initializer-clause = braced-init-list ;
braced-init-list = '{' initializer-list ','? '}' ;
braced-init-list = '{' '}' ;
initializer-list = initializer-clause '...'? ;
initializer-list = initializer-list ',' initializer-clause '...'? ;
throw-expression = 'throw' assignment-expression? ;
id-expression = unqualified-id ;
id-expression = qualified-id ;
unqualified-id = IDENTIFIER ;
unqualified-id = operator-function-id ;
unqualified-id = conversion-function-id ;
unqualified-id = '~' class-name ;
unqualified-id = template-id ;
operator-function-id = 'operator' operator ;
operator = 'new' ;
operator = 'delete' ;
operator = 'new' '[' ']' ;
operator = 'delete' '[' ']' ;
operator = '+' ;
operator = '-' ;
operator = '*' ;
operator = '/' ;
operator = '%' ;
operator = '^' ;
operator = '&' ;
operator = '|' ;
operator = '~' ;
operator = '!' ;
operator = '=' ;
operator = '<' ;
operator = '>' ;
operator = '+=' ;
operator = '-=' ;
operator = '*=' ;
operator = '/=' ;
operator = '%=' ;
operator = '^=' ;
operator = '&=' ;
operator = '|=' ;
operator = '<<' ;
operator = '>>' ;
operator = '>>=' ;
operator = '<<=' ;
operator = '==' ;
operator = '!=' ;
operator = '<=' ;
operator = '>=' ;
operator = '&&' ;
operator = '||' ;
operator = '++' ;
operator = '--' ;
operator = ',' ;
operator = '->*' ;
operator = '->' ;
operator = '(' ;
operator = ')' ;
operator = '[' ;
operator = ']' ;
conversion-function-id = 'operator' conversion-type-id ;
conversion-type-id = type-specifier-seq conversion-declarator? ;
type-specifier-seq = type-specifier type-specifier-seq? ;
conversion-declarator = ptr-operator conversion-declarator? ;
ptr-operator = '*' cv-qualifier-seq? ;
ptr-operator = '&' ;
ptr-operator = '&&' ;
ptr-operator = '::'? nested-name-specifier '*' cv-qualifier-seq? ;
cv-qualifier-seq = cv-qualifier cv-qualifier-seq? ;
cv-qualifier = 'const' ;
cv-qualifier = 'volatile' ;
template-id = simple-template-id ;
template-id = operator-function-id '<' template-argument-list? '>' ;
qualified-id = '::'? nested-name-specifier 'template'? unqualified-id ;
qualified-id = '::' IDENTIFIER ;
qualified-id = '::' operator-function-id ;
qualified-id = '::' template-id ;
lambda-expression = lambda-introducer lambda-parameter-declaration? compound-statement ;
lambda-introducer = '[' lambda-capture? ']' ;
lambda-capture = capture-default ;
lambda-capture = capture-list ;
lambda-capture = capture-default ',' capture-list ;
capture-default = '&' ;
capture-default = '=' ;
capture-list = capture ;
capture-list = capture-list ',' capture ;
capture = IDENTIFIER ;
capture = '&' IDENTIFIER ;
capture = 'this' ;
lambda-parameter-declaration = '(' lambda-parameter-declaration-list? ')' 'mutable'? exception-specification? lambda-return-type-clause? ;
lambda-parameter-declaration-list = lambda-parameter ;
lambda-parameter-declaration-list = lambda-parameter ',' lambda-parameter-declaration-list ;
lambda-parameter = decl-specifier-seq declarator ;
declarator = direct-declarator ;
declarator = ptr-operator declarator ;
direct-declarator = declarator-id ;
direct-declarator = direct-declarator '(' parameter-declaration-clause ')' cv-qualifier-seq? ref-qualifier? exception-specification? ;
direct-declarator = direct-declarator '(' parameter-declaration-clause ')' cv-qualifier-seq? ref-qualifier? exception-specification? '->' type-id ;
direct-declarator = direct-declarator '[' constant-expression? ']' ;
direct-declarator = '(' declarator ')' ;
declarator-id = '...'? id-expression ;
declarator-id = '::'? nested-name-specifier? class-name ;
parameter-declaration-clause = parameter-declaration-list? '...'? ;
parameter-declaration-clause = parameter-declaration-list ',' '...' ;
parameter-declaration-list = parameter-declaration ;
parameter-declaration-list = parameter-declaration-list ',' parameter-declaration ;
parameter-declaration = decl-specifier-seq declarator ;
parameter-declaration = decl-specifier-seq declarator '=' assignment-expression ;
parameter-declaration = decl-specifier-seq abstract-declarator? ;
parameter-declaration = decl-specifier-seq abstract-declarator? '=' assignment-expression ;
abstract-declarator = ptr-operator abstract-declarator? ;
abstract-declarator = direct-abstract-declarator ;
abstract-declarator = '...' ;
direct-abstract-declarator = direct-abstract-declarator? '(' parameter-declaration-clause ')' cv-qualifier-seq? ref-qualifier? exception-specification? ;
direct-abstract-declarator = direct-abstract-declarator? '(' parameter-declaration-clause ')' cv-qualifier-seq? ref-qualifier? exception-specification? '->' type-id ;
direct-abstract-declarator = direct-abstract-declarator? '[' constant-expression? ']' ;
direct-abstract-declarator = '(' abstract-declarator ')' ;
ref-qualifier = '&' ;
ref-qualifier = '&&' ;
exception-specification = 'throw' '(' type-id-list? ')' ;
type-id-list = type-id '...'? ;
type-id-list = type-id-list ',' type-id '...'? ;
type-id = type-specifier-seq abstract-declarator? ;
lambda-return-type-clause = '->' type-id ;
compound-statement = '{' statement-seq? '}' ;
statement-seq = statement ;
statement-seq = statement-seq statement ;
statement = labeled-statement ;
statement = expression-statement ;
statement = compound-statement ;
statement = selection-statement ;
statement = iteration-statement ;
statement = jump-statement ;
statement = declaration-statement ;
statement = try-block ;
labeled-statement = IDENTIFIER ':' statement ;
labeled-statement = 'case' constant-expression ':' statement ;
labeled-statement = 'default' ':' statement ;
expression-statement = expression? ';' ;
selection-statement = 'if' '(' condition ')' statement ;
selection-statement = 'if' '(' condition ')' statement 'else' statement ;
selection-statement = 'switch' '(' condition ')' statement ;
condition = expression ;
condition = type-specifier-seq declarator '=' initializer-clause ;
condition = type-specifier-seq declarator braced-init-list ;
iteration-statement = 'while' '(' condition ')' statement ;
iteration-statement = 'do' statement 'while' '(' expression ')' ';' ;
iteration-statement = 'for' '(' for-init-statement condition? ';' expression? ')' statement ;
for-init-statement = expression-statement ;
for-init-statement = simple-declaration ;
jump-statement = 'break' ';' ;
jump-statement = 'continue' ';' ;
jump-statement = 'return' expression? ';' ;
jump-statement = 'return' braced-init-list ';' ;
jump-statement = 'goto' IDENTIFIER ';' ;
declaration-statement = block-declaration ;
try-block = 'try' compound-statement handler-seq ;
handler-seq = handler handler-seq? ;
handler = 'catch' '(' exception-declaration ')' compound-statement ;
exception-declaration = type-specifier-seq declarator ;
exception-declaration = type-specifier-seq abstract-declarator ;
exception-declaration = type-specifier-seq ;
exception-declaration = '...' ;
expression-list = initializer-list ;
typename-specifier = 'typename' '::'? nested-name-specifier IDENTIFIER ;
typename-specifier = 'typename' '::'? nested-name-specifier 'template'? simple-template-id ;
pseudo-destructor-name = '::'? nested-name-specifier? type-name '::' '~' type-name ;
pseudo-destructor-name = '::'? nested-name-specifier 'template' simple-template-id '::' '~' type-name ;
pseudo-destructor-name = '::'? nested-name-specifier? '~' type-name ;
unary-operator = '*' ;
unary-operator = '&' ;
unary-operator = '+' ;
unary-operator = '-' ;
unary-operator = '!' ;
unary-operator = '~' ;
new-expression = '::'? 'new' new-placement? new-type-id new-initializer? ;
new-expression = '::'? 'new' new-placement? '(' type-id ')' new-initializer? ;
new-placement = '(' expression-list ')' ;
new-type-id = type-specifier-seq new-declarator? ;
new-declarator = ptr-operator new-declarator? ;
new-declarator = direct-new-declarator ;
direct-new-declarator = '[' expression ']' ;
direct-new-declarator = direct-new-declarator '[' constant-expression ']' ;
new-initializer = '(' expression-list? ')' ;
new-initializer = braced-init-list ;
delete-expression = '::'? 'delete' cast-expression ;
delete-expression = '::'? 'delete' '[' ']' cast-expression ;
enum-name = IDENTIFIER ;
typedef-name = IDENTIFIER ;
namespace-name = original-namespace-name ;
namespace-name = namespace-alias ;
original-namespace-name = IDENTIFIER ;
namespace-alias = IDENTIFIER ;
class-specifier = class-head '{' member-specification? '}' ;
class-head = class-key IDENTIFIER? base-clause? ;
class-head = class-key nested-name-specifier IDENTIFIER base-clause? ;
class-head = class-key nested-name-specifier? simple-template-id base-clause? ;
class-key = 'class' ;
class-key = 'struct' ;
class-key = 'union' ;
base-clause = ':' base-specifier-list ;
base-specifier-list = base-specifier '...'? ;
base-specifier-list = base-specifier-list ',' base-specifier '...'? ;
base-specifier = '::'? nested-name-specifier? class-name ;
base-specifier = 'virtual' access-specifier? '::'? nested-name-specifier? class-name ;
base-specifier = access-specifier 'virtual'? '::'? nested-name-specifier? class-name ;
access-specifier = 'private' ;
access-specifier = 'protected' ;
access-specifier = 'public' ;
member-specification = member-declaration member-specification? ;
member-specification = access-specifier ':' member-specification? ;
member-declaration = decl-specifier-seq? member-declarator-list? ';' ;
member-declaration = function-definition ';'? ;
member-declaration = '::'? nested-name-specifier 'template'? unqualified-id ';' ;
member-declaration = using-declaration ;
member-declaration = static_assert-declaration ;
member-declaration = template-declaration ;
member-declarator-list = member-declarator ;
member-declarator-list = member-declarator-list ',' member-declarator ;
member-declarator = declarator pure-specifier? ;
member-declarator = declarator constant-initializer? ;
member-declarator = IDENTIFIER? ':' constant-expression ;
pure-specifier = '=' '0' ;
constant-initializer = '=' constant-expression ;
function-definition = decl-specifier-seq? declarator function-body ;
function-definition = decl-specifier-seq? declarator '=' 'default' ';' ;
function-definition = decl-specifier-seq? declarator '=' 'delete' ';' ;
function-body = ctor-initializer? compound-statement ;
function-body = function-try-block ;
ctor-initializer = ':' mem-initializer-list ;
mem-initializer-list = mem-initializer '...'? ;
mem-initializer-list = mem-initializer ',' mem-initializer-list '...'? ;
mem-initializer = mem-initializer-id '(' expression-list? ')' ;
mem-initializer = mem-initializer-id braced-init-list ;
mem-initializer-id = '::'? nested-name-specifier? class-name ;
mem-initializer-id = IDENTIFIER ;
function-try-block = 'try' ctor-initializer? compound-statement handler-seq ;
using-declaration = 'using' 'typename'? '::'? nested-name-specifier unqualified-id ';' ;
using-declaration = 'using' '::' unqualified-id ';' ;
static_assert-declaration = 'static_assert' '(' constant-expression ',' string-literal ')' ';' ;
template-declaration = 'export'? 'template' '<' template-parameter-list '>' declaration ;
template-parameter-list = template-parameter ;
template-parameter-list = template-parameter-list ',' template-parameter ;
template-parameter = type-parameter ;
template-parameter = parameter-declaration ;
type-parameter = 'class' '...'? IDENTIFIER? ;
type-parameter = 'class' IDENTIFIER? '=' type-id ;
type-parameter = 'typename' '...'? IDENTIFIER? ;
type-parameter = 'typename' IDENTIFIER? '=' type-id ;
type-parameter = 'template' '<' template-parameter-list '>' 'class' '...'? IDENTIFIER? ;
type-parameter = 'template' '<' template-parameter-list '>' 'class' IDENTIFIER? '=' id-expression ;
enum-specifier = enum-key IDENTIFIER? enum-base? '{' enumerator-list? '}' ;
enum-specifier = enum-key IDENTIFIER? enum-base? '{' enumerator-list ',' '}' ;
enum-key = 'enum' ;
enum-key = 'enum' 'class' ;
enum-key = 'enum' 'struct' ;
enum-base = ':' type-specifier-seq ;
enumerator-list = enumerator-definition ;
enumerator-list = enumerator-list ',' enumerator-definition ;
enumerator-definition = enumerator ;
enumerator-definition = enumerator '=' constant-expression ;
enumerator = IDENTIFIER ;
elaborated-type-specifier = class-key '::'? nested-name-specifier? IDENTIFIER ;
elaborated-type-specifier = class-key '::'? nested-name-specifier? 'template'? simple-template-id ;
elaborated-type-specifier = enum-key '::'? nested-name-specifier? IDENTIFIER ;
function-specifier = 'inline' ;
function-specifier = 'virtual' ;
function-specifier = 'explicit' ;
alignment-specifier = 'alignas' '(' constant-expression ')' ;
alignment-specifier = 'alignas' '(' type-id ')' ;
init-declarator-list = init-declarator ;
init-declarator-list = init-declarator-list ',' init-declarator ;
init-declarator = declarator initializer? ;
initializer = '=' initializer-clause ;
initializer = '(' expression-list ')' ;
initializer = braced-init-list ;
asm-definition = 'asm' '(' string-literal ')' ';' ;
namespace-alias-definition = 'namespace' IDENTIFIER '=' qualified-namespace-specifier ';' ;
qualified-namespace-specifier = '::'? nested-name-specifier? namespace-name ;
using-directive = 'using' 'namespace' '::'? nested-name-specifier? namespace-name ';' ;
alias-declaration = 'using' IDENTIFIER '=' type-id ';' ;
explicit-instantiation = 'extern'? 'template' declaration ;
explicit-specialization = 'template' '<' '>' declaration ;
linkage-specification = 'extern' string-literal '{' declaration-seq? '}' ;
linkage-specification = 'extern' string-literal declaration ;
namespace-definition = named-namespace-definition ;
namespace-definition = unnamed-namespace-definition ;
named-namespace-definition = original-namespace-definition ;
named-namespace-definition = extension-namespace-definition ;
original-namespace-definition = 'inline'? 'namespace' IDENTIFIER '{' namespace-body '}' ;
namespace-body = declaration-seq? ;
extension-namespace-definition = 'inline'? 'namespace' original-namespace-name '{' namespace-body '}' ;
unnamed-namespace-definition = 'inline'? 'namespace' '{' namespace-body '}' ;
