module Main

exports
 context-free start-symbols compilationUnit
  sorts
        CompilationUnit PackageDefinition Annotations Annotation AT Identifier IDENT DOT AnnotationInit LPAREN AnnotationMemberInit ASSIGN AnnotationMemberValue ConditionalExpression LogicalOrExpression LogicalAndExpression InclusiveOrExpression ExclusiveOrExpression AndExpression EqualityExpression RelationalExpression ShiftExpression AdditiveExpression MultiplicativeExpression UnaryExpression INC DEC MINUS PLUS UnaryExpressionNotPlusMinus BNOT LNOT BuiltInTypeSpec BuiltInType LBRACK RBRACK RPAREN ClassTypeSpec ClassOrInterfaceType TypeArguments LT TypeArgument QUESTION ReferenceTypeSpec ArrayTypeSpec COMMA TypeArgumentsEnd GT SR BSR PostfixExpression PrimaryExpression IdentPrimary ArgList ExpressionList Expression AssignmentExpression PLUS-ASSIGN MINUS-ASSIGN STAR-ASSIGN DIV-ASSIGN MOD-ASSIGN SR-ASSIGN BSR-ASSIGN SL-ASSIGN BAND-ASSIGN BXOR-ASSIGN BOR-ASSIGN Constant NUM-INT EXPONENT FLOAT-SUFFIX HEX-DIGIT CHAR-LITERAL ESC STRING-LITERAL NUM-FLOAT NUM-LONG NUM-DOUBLE NewExpression Type ClassBlock LCURLY ClassField Modifiers Modifier InnerTypeDef EnumDefinition ENUM ImplementsClause EnumBlock EnumConst EnumConstInit SEMI RCURLY ClassDefinition TypeParameters TypeParameter BAND SuperClassClause InterfaceDefinition InterfaceExtends InterfaceBlock InterfaceField MemberDef TypeSpec ParameterDeclarationList ParameterDeclaration ParameterModifier ELLIPSIS DeclaratorBrackets ThrowsClause CompoundStatement Statement Declaration VariableDefinitions VariableDeclarator VarInitializer Initializer ArrayInitializer COLON ForInit ForCond ForIter CasesGroup ACase CaseSList TryBlock Handler FinallyClause ASSERT AnnotationTypeDefinition AnnotationBlock AnnotationField DefaultValue CtorHead ConstructorBody ExplicitConstructorInvocation NewArrayDeclarator STAR DIV MOD SL LE GE NOT-EQUAL EQUAL BXOR BOR LAND LOR AnnotationMemberArrayInitializer ImportDefinition IdentifierStar TypeDefinition 
  context-free syntax
        (PackageDefinition | ) ImportDefinition* TypeDefinition* -> CompilationUnit

        Annotations p::"package" Identifier SEMI -> PackageDefinition

        Annotation* -> Annotations

        AT Identifier AnnotationInit -> Annotation

        "@" -> AT

        IDENT (DOT IDENT)* -> Identifier

        ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "$") ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "$")* -> IDENT

        "." -> DOT

        lp::LPAREN ((AnnotationMemberInit (COMMA AnnotationMemberInit)*) | AnnotationMemberValue | ) RPAREN
		|  -> AnnotationInit

        "(" -> LPAREN

        IDENT ASSIGN AnnotationMemberValue -> AnnotationMemberInit

        "=" -> ASSIGN

        Annotation
		| ConditionalExpression
		| AnnotationMemberArrayInitializer -> AnnotationMemberValue

        LogicalOrExpression (QUESTION AssignmentExpression COLON ConditionalExpression)? -> ConditionalExpression

        LogicalAndExpression (LOR LogicalAndExpression)* -> LogicalOrExpression

        InclusiveOrExpression (LAND InclusiveOrExpression)* -> LogicalAndExpression

        ExclusiveOrExpression (BOR ExclusiveOrExpression)* -> InclusiveOrExpression

        AndExpression (BXOR AndExpression)* -> ExclusiveOrExpression

        EqualityExpression (BAND EqualityExpression)* -> AndExpression

        RelationalExpression ((NOT-EQUAL | EQUAL) RelationalExpression)* -> EqualityExpression

        ShiftExpression (((LT | GT | LE | GE) ShiftExpression)* | ("instanceof" TypeSpec)) -> RelationalExpression

        AdditiveExpression ((SL | SR | BSR) AdditiveExpression)* -> ShiftExpression

        MultiplicativeExpression ((PLUS | MINUS) MultiplicativeExpression)* -> AdditiveExpression

        UnaryExpression ((STAR | DIV | MOD) UnaryExpression)* -> MultiplicativeExpression

        INC UnaryExpression
		| DEC UnaryExpression
		| MINUS UnaryExpression
		| PLUS UnaryExpression
		| UnaryExpressionNotPlusMinus -> UnaryExpression

        "++" -> INC

        "--" -> DEC

        "-" -> MINUS

        "+" -> PLUS

        BNOT UnaryExpression
		| LNOT UnaryExpression
		| lpb::LPAREN BuiltInTypeSpec RPAREN UnaryExpression
		| lp::LPAREN ClassTypeSpec RPAREN UnaryExpressionNotPlusMinus
		| PostfixExpression -> UnaryExpressionNotPlusMinus

        "~" -> BNOT

        "!" -> LNOT

        BuiltInType (lb::LBRACK RBRACK)* -> BuiltInTypeSpec

        "void"
		| "boolean"
		| "byte"
		| "char"
		| "short"
		| "int"
		| "float"
		| "long"
		| "double" -> BuiltInType

        "[" -> LBRACK

        "]" -> RBRACK

        ")" -> RPAREN

        ClassOrInterfaceType (lb::LBRACK RBRACK)* -> ClassTypeSpec

        IDENT TypeArguments (DOT IDENT TypeArguments)* -> ClassOrInterfaceType

        lt::LT TypeArgument (COMMA TypeArgument)* TypeArgumentsEnd?
		|  -> TypeArguments

        "<" -> LT

        q::QUESTION (("extends" ReferenceTypeSpec) | ("super" ReferenceTypeSpec))?
		| ReferenceTypeSpec -> TypeArgument

        "?" -> QUESTION

        ClassTypeSpec
		| ArrayTypeSpec -> ReferenceTypeSpec

        BuiltInType (lb::LBRACK RBRACK)+ -> ArrayTypeSpec

        "," -> COMMA

        GT
		| SR
		| BSR -> TypeArgumentsEnd

        ">" -> GT

        ">>" -> SR

        ">>>" -> BSR

        PrimaryExpression ((DOT "this") | (DOT ta1::TypeArguments ((IDENT (lp::LPAREN ArgList RPAREN)?) | ("super" ((lp3::LPAREN ArgList RPAREN) | (DOT ta2::TypeArguments IDENT (lps::LPAREN ArgList RPAREN)?))))) | (DOT NewExpression) | (lb::LBRACK Expression RBRACK))* (in::INC | de::DEC)? -> PostfixExpression

        IdentPrimary (DOT "class")?
		| Constant
		| "true"
		| "false"
		| "null"
		| NewExpression
		| "this"
		| "super"
		| LPAREN AssignmentExpression RPAREN
		| BuiltInType (lbt::LBRACK RBRACK)* DOT "class" -> PrimaryExpression

        ta1::TypeArguments IDENT ((DOT ta2::TypeArguments IDENT) | )* ((lp::LPAREN ArgList RPAREN) | (lbc::LBRACK RBRACK)+)? -> IdentPrimary

        ExpressionList
		|  -> ArgList

        Expression (COMMA Expression)* -> ExpressionList

        AssignmentExpression -> Expression

        ConditionalExpression ((ASSIGN | PLUS-ASSIGN | MINUS-ASSIGN | STAR-ASSIGN | DIV-ASSIGN | MOD-ASSIGN | SR-ASSIGN | BSR-ASSIGN | SL-ASSIGN | BAND-ASSIGN | BXOR-ASSIGN | BOR-ASSIGN) AssignmentExpression)? -> AssignmentExpression

        "+=" -> PLUS-ASSIGN

        "-=" -> MINUS-ASSIGN

        "*=" -> STAR-ASSIGN

        "/=" -> DIV-ASSIGN

        "%=" -> MOD-ASSIGN

        ">>=" -> SR-ASSIGN

        ">>>=" -> BSR-ASSIGN

        "<<=" -> SL-ASSIGN

        "&=" -> BAND-ASSIGN

        "^=" -> BXOR-ASSIGN

        "|=" -> BOR-ASSIGN

        NUM-INT
		| CHAR-LITERAL
		| STRING-LITERAL
		| NUM-FLOAT
		| NUM-LONG
		| NUM-DOUBLE -> Constant

        "." (("." ".") | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? f1::FLOAT-SUFFIX?)?)
		| (("0" ((("x" | "X") HEX-DIGIT+) | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+)?) | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? f2::FLOAT-SUFFIX?) | (EXPONENT f3::FLOAT-SUFFIX?) | f4::FLOAT-SUFFIX)? -> NUM-INT

        ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ -> EXPONENT

        "f"
		| "F"
		| "d"
		| "D" -> FLOAT-SUFFIX

        "0"
		| "1"
		| "2"
		| "3"
		| "4"
		| "5"
		| "6"
		| "7"
		| "8"
		| "9"
		| "A"
		| "B"
		| "C"
		| "D"
		| "E"
		| "F"
		| "a"
		| "b"
		| "c"
		| "d"
		| "e"
		| "f" -> HEX-DIGIT

        "\'" (ESC | STR) "\'" -> CHAR-LITERAL

        "\\" ("n" | "r" | "t" | "b" | "f" | """ | "\'" | "\\" | ("u"+ HEX-DIGIT HEX-DIGIT HEX-DIGIT HEX-DIGIT) | (("0" | "1" | "2" | "3") (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)?) | (("4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)) -> ESC

        """ (ESC | STR)* """ -> STRING-LITERAL

        "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("f" | "F")
		| "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "f" | "F")
		| ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("f" | "F")) | EXPONENT) -> NUM-FLOAT

        ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ("l" | "L") -> NUM-LONG

        "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("d" | "D")
		| "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "d" | "D")
		| ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("d" | "D")) | EXPONENT) -> NUM-DOUBLE

        "new" TypeArguments Type ((LPAREN ArgList RPAREN ClassBlock?) | (NewArrayDeclarator ArrayInitializer?)) -> NewExpression

        ClassOrInterfaceType
		| BuiltInType -> Type

        LCURLY (ClassField | SEMI)* RCURLY -> ClassBlock

        "{" -> LCURLY

        mods::Modifiers (it::InnerTypeDef | (tp::TypeParameters ((h::CtorHead s::ConstructorBody) | md::MemberDef)))
		| "static" s3::CompoundStatement
		| s4::CompoundStatement -> ClassField

        (Modifier | Annotation)* -> Modifiers

        "private"
		| "public"
		| "protected"
		| "static"
		| "transient"
		| "final"
		| "abstract"
		| "native"
		| "threadsafe"
		| "synchronized"
		| "volatile"
		| "strictfp" -> Modifier

        ed::EnumDefinition
		| cd::ClassDefinition
		| id::InterfaceDefinition
		| ad::AnnotationTypeDefinition -> InnerTypeDef

        ENUM IDENT ic::ImplementsClause eb::EnumBlock -> EnumDefinition

        "enum" -> ENUM

        (i::"implements" ClassOrInterfaceType (COMMA ClassOrInterfaceType)*)? -> ImplementsClause

        LCURLY (EnumConst (COMMA EnumConst)*)? COMMA? (SEMI (ClassField | SEMI)*)? RCURLY -> EnumBlock

        Annotations IDENT EnumConstInit ClassBlock? -> EnumConst

        lp::LPAREN ArgList RPAREN
		|  -> EnumConstInit

        ";" -> SEMI

        "}" -> RCURLY

        "class" IDENT tp::TypeParameters sc::SuperClassClause ic::ImplementsClause cb::ClassBlock -> ClassDefinition

        lt::LT TypeParameter (COMMA TypeParameter)* TypeArgumentsEnd?
		|  -> TypeParameters

        IDENT ("extends" ClassOrInterfaceType (BAND ClassOrInterfaceType)*)? -> TypeParameter

        "&" -> BAND

        ("extends" ClassOrInterfaceType)? -> SuperClassClause

        "interface" IDENT tp::TypeParameters ie::InterfaceExtends ib::InterfaceBlock -> InterfaceDefinition

        (e::"extends" ClassOrInterfaceType (COMMA ClassOrInterfaceType)*)? -> InterfaceExtends

        LCURLY (InterfaceField | SEMI)* RCURLY -> InterfaceBlock

        mods::Modifiers (it::InnerTypeDef | (tp::TypeParameters md::MemberDef)) -> InterfaceField

        t::TypeSpec ((IDENT LPAREN param::ParameterDeclarationList RPAREN rt::DeclaratorBrackets tc::ThrowsClause? (SEMI | s2::CompoundStatement)) | (v::VariableDefinitions SEMI)) -> MemberDef

        ClassTypeSpec
		| BuiltInTypeSpec -> TypeSpec

        (ParameterDeclaration (COMMA ParameterDeclaration)*)? -> ParameterDeclarationList

        pm::ParameterModifier t::TypeSpec el::ELLIPSIS? id::IDENT pd::DeclaratorBrackets -> ParameterDeclaration

        ("final" | Annotation)* -> ParameterModifier

        "..." -> ELLIPSIS

        (lb::LBRACK RBRACK)* -> DeclaratorBrackets

        "throws" Identifier (COMMA Identifier)* -> ThrowsClause

        lc::LCURLY Statement* RCURLY -> CompoundStatement

        CompoundStatement
		| Declaration SEMI
		| Expression SEMI
		| m::Modifiers (EnumDefinition | ClassDefinition)
		| IDENT c::COLON Statement
		| "if" LPAREN Expression RPAREN Statement ("else" Statement)?
		| "for" LPAREN ((ParameterDeclaration COLON Expression) | (ForInit SEMI ForCond SEMI ForIter)) RPAREN Statement
		| "while" LPAREN Expression RPAREN Statement
		| "do" Statement "while" LPAREN Expression RPAREN SEMI
		| "break" IDENT? SEMI
		| "continue" IDENT? SEMI
		| "return" Expression? SEMI
		| "switch" LPAREN Expression RPAREN LCURLY CasesGroup* RCURLY
		| TryBlock
		| "throw" Expression SEMI
		| "synchronized" LPAREN Expression RPAREN CompoundStatement
		| ASSERT Expression (COLON Expression)? SEMI
		| s::SEMI -> Statement

        m::Modifiers t::TypeSpec v::VariableDefinitions -> Declaration

        VariableDeclarator (COMMA VariableDeclarator)* -> VariableDefinitions

        id::IDENT d::DeclaratorBrackets v::VarInitializer -> VariableDeclarator

        (ASSIGN Initializer)? -> VarInitializer

        Expression
		| ArrayInitializer -> Initializer

        lc::LCURLY (Initializer (COMMA Initializer)*)? COMMA? RCURLY -> ArrayInitializer

        ":" -> COLON

        (Declaration | ExpressionList)? -> ForInit

        Expression? -> ForCond

        ExpressionList? -> ForIter

        ACase+ CaseSList -> CasesGroup

        (("case" Expression) | "default") COLON -> ACase

        Statement* -> CaseSList

        "try" CompoundStatement Handler* FinallyClause? -> TryBlock

        "catch" LPAREN ParameterDeclaration RPAREN CompoundStatement -> Handler

        "finally" CompoundStatement -> FinallyClause

        "assert" -> ASSERT

        AT "interface" IDENT ab::AnnotationBlock -> AnnotationTypeDefinition

        LCURLY (AnnotationField | SEMI)* RCURLY -> AnnotationBlock

        mods::Modifiers (it::InnerTypeDef | (ts::TypeSpec ((i::IDENT LPAREN RPAREN dv::DefaultValue SEMI) | (v::VariableDefinitions SEMI)))) -> AnnotationField

        ("default" AnnotationMemberValue)? -> DefaultValue

        IDENT LPAREN ParameterDeclarationList RPAREN ThrowsClause? -> CtorHead

        lc::LCURLY ExplicitConstructorInvocation? Statement* RCURLY -> ConstructorBody

        TypeArguments (("this" lp1::LPAREN ArgList RPAREN SEMI) | ("super" lp2::LPAREN ArgList RPAREN SEMI)) -> ExplicitConstructorInvocation

        (lb::LBRACK Expression? RBRACK)+ -> NewArrayDeclarator

        "*" -> STAR

        "/" -> DIV

        "%" -> MOD

        "<<" -> SL

        "<=" -> LE

        ">=" -> GE

        "!=" -> NOT-EQUAL

        "==" -> EQUAL

        "^" -> BXOR

        "|" -> BOR

        "&&" -> LAND

        "||" -> LOR

        lc::LCURLY (AnnotationMemberValue (COMMA AnnotationMemberValue)*)? COMMA? RCURLY -> AnnotationMemberArrayInitializer

        i::"import" "static"? IdentifierStar SEMI -> ImportDefinition

        IDENT (DOT IDENT)* (DOT STAR)? -> IdentifierStar

        m::Modifiers (ClassDefinition | EnumDefinition | InterfaceDefinition | AnnotationTypeDefinition)
		| SEMI -> TypeDefinition
