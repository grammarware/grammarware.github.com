javaSource = compilationUnit ;
compilationUnit = annotationList packageDeclaration? importDeclaration* typeDecls* ;
annotationList = annotation* ;
annotation = AT qualifiedIdentifier annotationInit? ;
AT = '@' ;
qualifiedIdentifier = IDENT (DOT ident::IDENT)* ;
IDENT = JAVA_ID_START JAVA_ID_PART* ;
JAVA_ID_START = 'a' ;
JAVA_ID_START = 'b' ;
JAVA_ID_START = 'c' ;
JAVA_ID_START = 'd' ;
JAVA_ID_START = 'e' ;
JAVA_ID_START = 'f' ;
JAVA_ID_START = 'g' ;
JAVA_ID_START = 'h' ;
JAVA_ID_START = 'i' ;
JAVA_ID_START = 'j' ;
JAVA_ID_START = 'k' ;
JAVA_ID_START = 'l' ;
JAVA_ID_START = 'm' ;
JAVA_ID_START = 'n' ;
JAVA_ID_START = 'o' ;
JAVA_ID_START = 'p' ;
JAVA_ID_START = 'q' ;
JAVA_ID_START = 'r' ;
JAVA_ID_START = 's' ;
JAVA_ID_START = 't' ;
JAVA_ID_START = 'u' ;
JAVA_ID_START = 'v' ;
JAVA_ID_START = 'w' ;
JAVA_ID_START = 'x' ;
JAVA_ID_START = 'y' ;
JAVA_ID_START = 'z' ;
JAVA_ID_START = 'A' ;
JAVA_ID_START = 'B' ;
JAVA_ID_START = 'C' ;
JAVA_ID_START = 'D' ;
JAVA_ID_START = 'E' ;
JAVA_ID_START = 'F' ;
JAVA_ID_START = 'G' ;
JAVA_ID_START = 'H' ;
JAVA_ID_START = 'I' ;
JAVA_ID_START = 'J' ;
JAVA_ID_START = 'K' ;
JAVA_ID_START = 'L' ;
JAVA_ID_START = 'M' ;
JAVA_ID_START = 'N' ;
JAVA_ID_START = 'O' ;
JAVA_ID_START = 'P' ;
JAVA_ID_START = 'Q' ;
JAVA_ID_START = 'R' ;
JAVA_ID_START = 'S' ;
JAVA_ID_START = 'T' ;
JAVA_ID_START = 'U' ;
JAVA_ID_START = 'V' ;
JAVA_ID_START = 'W' ;
JAVA_ID_START = 'X' ;
JAVA_ID_START = 'Y' ;
JAVA_ID_START = 'Z' ;
JAVA_ID_PART = JAVA_ID_START ;
JAVA_ID_PART = '0' ;
JAVA_ID_PART = '1' ;
JAVA_ID_PART = '2' ;
JAVA_ID_PART = '3' ;
JAVA_ID_PART = '4' ;
JAVA_ID_PART = '5' ;
JAVA_ID_PART = '6' ;
JAVA_ID_PART = '7' ;
JAVA_ID_PART = '8' ;
JAVA_ID_PART = '9' ;
DOT = '.' ;
annotationInit = LPAREN annotationInitializers RPAREN ;
LPAREN = '(' ;
annotationInitializers = annotationInitializer (COMMA annotationInitializer)* ;
annotationInitializers = annotationElementValue ;
annotationInitializer = IDENT ASSIGN annotationElementValue ;
ASSIGN = '=' ;
annotationElementValue = annotationElementValueExpression ;
annotationElementValue = annotation ;
annotationElementValue = annotationElementValueArrayInitializer ;
annotationElementValueExpression = conditionalExpression ;
conditionalExpression = logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression = logicalAndExpression (LOGICAL_OR logicalAndExpression)* ;
logicalAndExpression = inclusiveOrExpression (LOGICAL_AND inclusiveOrExpression)* ;
inclusiveOrExpression = exclusiveOrExpression (OR exclusiveOrExpression)* ;
exclusiveOrExpression = andExpression (XOR andExpression)* ;
andExpression = equalityExpression (AND equalityExpression)* ;
equalityExpression = instanceOfExpression ((EQUAL | NOT_EQUAL) instanceOfExpression)* ;
instanceOfExpression = relationalExpression (INSTANCEOF type)? ;
relationalExpression = shiftExpression ((LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN) shiftExpression)* ;
shiftExpression = additiveExpression ((BIT_SHIFT_RIGHT | SHIFT_RIGHT | SHIFT_LEFT) additiveExpression)* ;
additiveExpression = multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression = unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression = PLUS unaryExpression ;
unaryExpression = MINUS unaryExpression ;
unaryExpression = INC postfixedExpression ;
unaryExpression = DEC postfixedExpression ;
unaryExpression = unaryExpressionNotPlusMinus ;
PLUS = '+' ;
MINUS = '-' ;
INC = '++' ;
postfixedExpression = primaryExpression ((outerDot::DOT ((genericTypeArgumentListSimplified? IDENT arguments?) | THIS | (Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments?) | innerNewExpression)) | (LBRACK expression RBRACK))* (INC | DEC)? ;
primaryExpression = parenthesizedExpression ;
primaryExpression = literal ;
primaryExpression = newExpression ;
primaryExpression = qualifiedIdentExpression ;
primaryExpression = genericTypeArgumentListSimplified ((SUPER (arguments | (DOT IDENT arguments))) | (IDENT arguments) | (THIS arguments)) ;
primaryExpression = THIS arguments? ;
primaryExpression = SUPER arguments ;
primaryExpression = SUPER DOT IDENT (arguments | ) ;
primaryExpression = primitiveType arrayDeclarator* DOT CLASS ;
primaryExpression = VOID DOT CLASS ;
parenthesizedExpression = LPAREN expression RPAREN ;
expression = assignmentExpression ;
assignmentExpression = conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | BIT_SHIFT_RIGHT_ASSIGN) assignmentExpression)? ;
PLUS_ASSIGN = '+=' ;
MINUS_ASSIGN = '-=' ;
STAR_ASSIGN = '*=' ;
DIV_ASSIGN = '/=' ;
AND_ASSIGN = '&=' ;
OR_ASSIGN = '|=' ;
XOR_ASSIGN = '^=' ;
MOD_ASSIGN = '%=' ;
SHIFT_LEFT_ASSIGN = '<<=' ;
SHIFT_RIGHT_ASSIGN = '>>=' ;
BIT_SHIFT_RIGHT_ASSIGN = '>>>=' ;
RPAREN = ')' ;
literal = HEX_LITERAL ;
literal = OCTAL_LITERAL ;
literal = DECIMAL_LITERAL ;
literal = FLOATING_POINT_LITERAL ;
literal = CHARACTER_LITERAL ;
literal = STRING_LITERAL ;
literal = TRUE ;
literal = FALSE ;
literal = NULL ;
HEX_LITERAL = '0' ('x' | 'X') HEX_DIGIT+ INTEGER_TYPE_SUFFIX? ;
HEX_DIGIT = '0' ;
HEX_DIGIT = '1' ;
HEX_DIGIT = '2' ;
HEX_DIGIT = '3' ;
HEX_DIGIT = '4' ;
HEX_DIGIT = '5' ;
HEX_DIGIT = '6' ;
HEX_DIGIT = '7' ;
HEX_DIGIT = '8' ;
HEX_DIGIT = '9' ;
HEX_DIGIT = 'a' ;
HEX_DIGIT = 'b' ;
HEX_DIGIT = 'c' ;
HEX_DIGIT = 'd' ;
HEX_DIGIT = 'e' ;
HEX_DIGIT = 'f' ;
HEX_DIGIT = 'A' ;
HEX_DIGIT = 'B' ;
HEX_DIGIT = 'C' ;
HEX_DIGIT = 'D' ;
HEX_DIGIT = 'E' ;
HEX_DIGIT = 'F' ;
INTEGER_TYPE_SUFFIX = 'l' ;
INTEGER_TYPE_SUFFIX = 'L' ;
OCTAL_LITERAL = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')+ INTEGER_TYPE_SUFFIX? ;
DECIMAL_LITERAL = ('0' | (('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)) INTEGER_TYPE_SUFFIX? ;
FLOATING_POINT_LITERAL = ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ((DOT ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* EXPONENT? FLOAT_TYPE_SUFFIX?) | (EXPONENT FLOAT_TYPE_SUFFIX?) | FLOAT_TYPE_SUFFIX) ;
FLOATING_POINT_LITERAL = DOT ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? FLOAT_TYPE_SUFFIX? ;
EXPONENT = ('e' | 'E') ('+' | '-')? ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ;
FLOAT_TYPE_SUFFIX = 'f' ;
FLOAT_TYPE_SUFFIX = 'F' ;
FLOAT_TYPE_SUFFIX = 'd' ;
FLOAT_TYPE_SUFFIX = 'D' ;
CHARACTER_LITERAL = '\'' (ESCAPE_SEQUENCE | STR) '\'' ;
ESCAPE_SEQUENCE = '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\') ;
ESCAPE_SEQUENCE = UNICODE_ESCAPE ;
ESCAPE_SEQUENCE = OCTAL_ESCAPE ;
UNICODE_ESCAPE = '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;
OCTAL_ESCAPE = ('0' | '1' | '2' | '3') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
OCTAL_ESCAPE = '\\' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
OCTAL_ESCAPE = '\\' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
STRING_LITERAL = '"' (ESCAPE_SEQUENCE | STR)* '"' ;
TRUE = 'true' ;
FALSE = 'false' ;
NULL = 'null' ;
newExpression = NEW ((primitiveType newArrayConstruction) | (genericTypeArgumentListSimplified? qualifiedTypeIdentSimplified (newArrayConstruction | (arguments classBody?)))) ;
NEW = 'new' ;
primitiveType = BOOLEAN ;
primitiveType = CHAR ;
primitiveType = BYTE ;
primitiveType = SHORT ;
primitiveType = INT ;
primitiveType = LONG ;
primitiveType = FLOAT ;
primitiveType = DOUBLE ;
BOOLEAN = 'boolean' ;
CHAR = 'char' ;
BYTE = 'byte' ;
SHORT = 'short' ;
INT = 'int' ;
LONG = 'long' ;
FLOAT = 'float' ;
DOUBLE = 'double' ;
newArrayConstruction = arrayDeclaratorList arrayInitializer ;
newArrayConstruction = LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList? ;
arrayDeclaratorList = arrayDeclarator+ ;
arrayDeclarator = LBRACK RBRACK ;
LBRACK = '[' ;
RBRACK = ']' ;
arrayInitializer = LCURLY (variableInitializer (COMMA variableInitializer)* COMMA?)? RCURLY ;
LCURLY = '{' ;
variableInitializer = arrayInitializer ;
variableInitializer = expression ;
COMMA = ',' ;
RCURLY = '}' ;
genericTypeArgumentListSimplified = LESS_THAN genericTypeArgumentSimplified (COMMA genericTypeArgumentSimplified)* genericTypeListClosing ;
LESS_THAN = '<' ;
genericTypeArgumentSimplified = type ;
genericTypeArgumentSimplified = QUESTION ;
type = simpleType ;
type = objectType ;
simpleType = primitiveType arrayDeclaratorList? ;
objectType = qualifiedTypeIdent arrayDeclaratorList? ;
qualifiedTypeIdent = typeIdent (DOT typeIdent)* ;
typeIdent = IDENT genericTypeArgumentList? ;
genericTypeArgumentList = LESS_THAN genericTypeArgument (COMMA genericTypeArgument)* genericTypeListClosing ;
genericTypeArgument = type ;
genericTypeArgument = QUESTION genericWildcardBoundType? ;
QUESTION = '?' ;
genericWildcardBoundType = (EXTENDS | SUPER) type ;
EXTENDS = 'extends' ;
SUPER = 'super' ;
genericTypeListClosing = GREATER_THAN ;
genericTypeListClosing = SHIFT_RIGHT ;
genericTypeListClosing = BIT_SHIFT_RIGHT ;
genericTypeListClosing =  ;
GREATER_THAN = '>' ;
SHIFT_RIGHT = '>>' ;
BIT_SHIFT_RIGHT = '>>>' ;
qualifiedTypeIdentSimplified = typeIdentSimplified (DOT typeIdentSimplified)* ;
typeIdentSimplified = IDENT genericTypeArgumentListSimplified? ;
arguments = LPAREN expressionList? RPAREN ;
expressionList = expression (COMMA expression)* ;
classBody = LCURLY classScopeDeclarations* RCURLY ;
classScopeDeclarations = block ;
classScopeDeclarations = STATIC block ;
classScopeDeclarations = modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? (block | SEMI)) | (VOID IDENT formalParameterList throwsClause? (block | SEMI)) | (ident::IDENT formalParameterList throwsClause? block))) | (type classFieldDeclaratorList SEMI)) ;
classScopeDeclarations = typeDeclaration ;
classScopeDeclarations = SEMI ;
block = LCURLY blockStatement* RCURLY ;
blockStatement = localVariableDeclaration SEMI ;
blockStatement = typeDeclaration ;
blockStatement = statement ;
localVariableDeclaration = localModifierList type classFieldDeclaratorList ;
localModifierList = localModifier* ;
localModifier = FINAL ;
localModifier = annotation ;
FINAL = 'final' ;
classFieldDeclaratorList = classFieldDeclarator (COMMA classFieldDeclarator)* ;
classFieldDeclarator = variableDeclaratorId (ASSIGN variableInitializer)? ;
variableDeclaratorId = IDENT arrayDeclaratorList? ;
SEMI = ';' ;
typeDeclaration = modifierList (classTypeDeclaration | interfaceTypeDeclaration | enumTypeDeclaration | annotationTypeDeclaration) ;
modifierList = modifier* ;
modifier = PUBLIC ;
modifier = PROTECTED ;
modifier = PRIVATE ;
modifier = STATIC ;
modifier = ABSTRACT ;
modifier = NATIVE ;
modifier = SYNCHRONIZED ;
modifier = TRANSIENT ;
modifier = VOLATILE ;
modifier = STRICTFP ;
modifier = localModifier ;
PUBLIC = 'public' ;
PROTECTED = 'protected' ;
PRIVATE = 'private' ;
STATIC = 'static' ;
ABSTRACT = 'abstract' ;
NATIVE = 'native' ;
SYNCHRONIZED = 'synchronized' ;
TRANSIENT = 'transient' ;
VOLATILE = 'volatile' ;
STRICTFP = 'strictfp' ;
classTypeDeclaration = CLASS IDENT genericTypeParameterList? classExtendsClause? implementsClause? classBody ;
CLASS = 'class' ;
genericTypeParameterList = LESS_THAN genericTypeParameter (COMMA genericTypeParameter)* genericTypeListClosing ;
genericTypeParameter = IDENT bound? ;
bound = EXTENDS type (AND type)* ;
AND = '&' ;
classExtendsClause = EXTENDS type ;
implementsClause = IMPLEMENTS typeList ;
IMPLEMENTS = 'implements' ;
typeList = type (COMMA type)* ;
interfaceTypeDeclaration = INTERFACE IDENT genericTypeParameterList? interfaceExtendsClause? interfaceBody ;
INTERFACE = 'interface' ;
interfaceExtendsClause = EXTENDS typeList ;
interfaceBody = LCURLY interfaceScopeDeclarations* RCURLY ;
interfaceScopeDeclarations = modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI) | (VOID IDENT formalParameterList throwsClause? SEMI))) | (type interfaceFieldDeclaratorList SEMI)) ;
interfaceScopeDeclarations = typeDeclaration ;
interfaceScopeDeclarations = SEMI ;
formalParameterList = LPAREN ((formalParameterStandardDecl (COMMA formalParameterStandardDecl)* (COMMA formalParameterVarArgDecl)?) | formalParameterVarArgDecl | ) RPAREN ;
formalParameterStandardDecl = localModifierList type variableDeclaratorId ;
formalParameterVarArgDecl = localModifierList type ELLIPSIS variableDeclaratorId ;
ELLIPSIS = '...' ;
throwsClause = THROWS qualifiedIdentList ;
THROWS = 'throws' ;
qualifiedIdentList = qualifiedIdentifier (COMMA qualifiedIdentifier)* ;
VOID = 'void' ;
interfaceFieldDeclaratorList = interfaceFieldDeclarator (COMMA interfaceFieldDeclarator)* ;
interfaceFieldDeclarator = variableDeclaratorId ASSIGN variableInitializer ;
enumTypeDeclaration = ENUM IDENT implementsClause? enumBody ;
ENUM = 'enum' ;
enumBody = LCURLY enumScopeDeclarations RCURLY ;
enumScopeDeclarations = enumConstants COMMA? enumClassScopeDeclarations? ;
enumConstants = enumConstant (COMMA enumConstant)* ;
enumConstant = annotationList IDENT arguments? classBody? ;
enumClassScopeDeclarations = SEMI classScopeDeclarations* ;
annotationTypeDeclaration = AT INTERFACE IDENT annotationBody ;
annotationBody = LCURLY annotationScopeDeclarations* RCURLY ;
annotationScopeDeclarations = modifierList type ((IDENT LPAREN RPAREN annotationDefaultValue? SEMI) | (classFieldDeclaratorList SEMI)) ;
annotationScopeDeclarations = typeDeclaration ;
annotationDefaultValue = DEFAULT annotationElementValue ;
DEFAULT = 'default' ;
statement = block ;
statement = ASSERT expr1::expression ((COLON expr2::expression SEMI) | SEMI) ;
statement = IF parenthesizedExpression ifStat::statement ((ELSE elseStat::statement) | ) ;
statement = FOR LPAREN ((forInit SEMI forCondition SEMI forUpdater RPAREN statement) | (localModifierList type IDENT COLON expression RPAREN statement)) ;
statement = WHILE parenthesizedExpression statement ;
statement = DO statement WHILE parenthesizedExpression SEMI ;
statement = TRY block ((catches finallyClause?) | finallyClause) ;
statement = SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY ;
statement = SYNCHRONIZED parenthesizedExpression block ;
statement = RETURN expression? SEMI ;
statement = THROW expression SEMI ;
statement = BREAK IDENT? SEMI ;
statement = CONTINUE IDENT? SEMI ;
statement = IDENT COLON statement ;
statement = expression SEMI ;
statement = SEMI ;
ASSERT = 'assert' ;
COLON = ':' ;
IF = 'if' ;
ELSE = 'else' ;
FOR = 'for' ;
forInit = localVariableDeclaration ;
forInit = expressionList ;
forInit =  ;
forCondition = expression? ;
forUpdater = expressionList? ;
WHILE = 'while' ;
DO = 'do' ;
TRY = 'try' ;
catches = catchClause+ ;
catchClause = CATCH LPAREN formalParameterStandardDecl RPAREN block ;
CATCH = 'catch' ;
finallyClause = FINALLY block ;
FINALLY = 'finally' ;
SWITCH = 'switch' ;
switchBlockLabels = switchCaseLabels switchDefaultLabel? switchCaseLabels ;
switchCaseLabels = switchCaseLabel* ;
switchCaseLabel = CASE expression COLON blockStatement* ;
CASE = 'case' ;
switchDefaultLabel = DEFAULT COLON blockStatement* ;
RETURN = 'return' ;
THROW = 'throw' ;
BREAK = 'break' ;
CONTINUE = 'continue' ;
qualifiedIdentExpression = qualifiedIdentifier ((arrayDeclarator+ DOT CLASS) | arguments | (outerDot::DOT (CLASS | (genericTypeArgumentListSimplified ((Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments) | (IDENT arguments))) | THIS | (Super::SUPER arguments) | innerNewExpression)))? ;
THIS = 'this' ;
innerNewExpression = NEW genericTypeArgumentListSimplified? IDENT arguments classBody? ;
DEC = '--' ;
unaryExpressionNotPlusMinus = NOT unaryExpression ;
unaryExpressionNotPlusMinus = LOGICAL_NOT unaryExpression ;
unaryExpressionNotPlusMinus = LPAREN type RPAREN unaryExpression ;
unaryExpressionNotPlusMinus = postfixedExpression ;
NOT = '~' ;
LOGICAL_NOT = '!' ;
STAR = '*' ;
DIV = '/' ;
MOD = '%' ;
SHIFT_LEFT = '<<' ;
LESS_OR_EQUAL = '<=' ;
GREATER_OR_EQUAL = '>=' ;
INSTANCEOF = 'instanceof' ;
EQUAL = '==' ;
NOT_EQUAL = '!=' ;
XOR = '^' ;
OR = '|' ;
LOGICAL_AND = '&&' ;
LOGICAL_OR = '||' ;
annotationElementValueArrayInitializer = LCURLY (annotationElementValue (COMMA annotationElementValue)*)? COMMA? RCURLY ;
packageDeclaration = PACKAGE qualifiedIdentifier SEMI ;
PACKAGE = 'package' ;
importDeclaration = IMPORT STATIC? qualifiedIdentifier DOTSTAR? SEMI ;
IMPORT = 'import' ;
DOTSTAR = '.*' ;
typeDecls = typeDeclaration ;
typeDecls = SEMI ;
