compilationUnit = annotations ((packageDeclaration importDeclaration* typeDeclaration*) | (classOrInterfaceDeclaration typeDeclaration*)) ;
compilationUnit = packageDeclaration? importDeclaration* typeDeclaration* ;
annotations = annotation+ ;
annotation = '@' annotationName ('(' (elementValuePairs | elementValue)? ')')? ;
annotationName = Identifier ('.' Identifier)* ;
Identifier = Letter (Letter | JavaIDDigit)* ;
Letter = 'a' ;
Letter = 'b' ;
Letter = 'c' ;
Letter = 'd' ;
Letter = 'e' ;
Letter = 'f' ;
Letter = 'g' ;
Letter = 'h' ;
Letter = 'i' ;
Letter = 'j' ;
Letter = 'k' ;
Letter = 'l' ;
Letter = 'm' ;
Letter = 'n' ;
Letter = 'o' ;
Letter = 'p' ;
Letter = 'q' ;
Letter = 'r' ;
Letter = 's' ;
Letter = 't' ;
Letter = 'u' ;
Letter = 'v' ;
Letter = 'w' ;
Letter = 'x' ;
Letter = 'y' ;
Letter = 'z' ;
Letter = 'A' ;
Letter = 'B' ;
Letter = 'C' ;
Letter = 'D' ;
Letter = 'E' ;
Letter = 'F' ;
Letter = 'G' ;
Letter = 'H' ;
Letter = 'I' ;
Letter = 'J' ;
Letter = 'K' ;
Letter = 'L' ;
Letter = 'M' ;
Letter = 'N' ;
Letter = 'O' ;
Letter = 'P' ;
Letter = 'Q' ;
Letter = 'R' ;
Letter = 'S' ;
Letter = 'T' ;
Letter = 'U' ;
Letter = 'V' ;
Letter = 'W' ;
Letter = 'X' ;
Letter = 'Y' ;
Letter = 'Z' ;
JavaIDDigit = '0' ;
JavaIDDigit = '1' ;
JavaIDDigit = '2' ;
JavaIDDigit = '3' ;
JavaIDDigit = '4' ;
JavaIDDigit = '5' ;
JavaIDDigit = '6' ;
JavaIDDigit = '7' ;
JavaIDDigit = '8' ;
JavaIDDigit = '9' ;
JavaIDDigit = 'a' ;
JavaIDDigit = 'b' ;
JavaIDDigit = 'c' ;
JavaIDDigit = 'd' ;
JavaIDDigit = 'e' ;
JavaIDDigit = 'f' ;
JavaIDDigit = 'g' ;
JavaIDDigit = 'h' ;
JavaIDDigit = 'i' ;
JavaIDDigit = 'j' ;
JavaIDDigit = 'k' ;
JavaIDDigit = 'l' ;
JavaIDDigit = 'm' ;
JavaIDDigit = 'n' ;
JavaIDDigit = 'o' ;
JavaIDDigit = 'p' ;
JavaIDDigit = 'q' ;
JavaIDDigit = 'r' ;
JavaIDDigit = 's' ;
JavaIDDigit = 't' ;
JavaIDDigit = 'u' ;
JavaIDDigit = 'v' ;
JavaIDDigit = 'w' ;
JavaIDDigit = 'x' ;
JavaIDDigit = 'y' ;
JavaIDDigit = 'z' ;
JavaIDDigit = 'A' ;
JavaIDDigit = 'B' ;
JavaIDDigit = 'C' ;
JavaIDDigit = 'D' ;
JavaIDDigit = 'E' ;
JavaIDDigit = 'F' ;
JavaIDDigit = 'G' ;
JavaIDDigit = 'H' ;
JavaIDDigit = 'I' ;
JavaIDDigit = 'J' ;
JavaIDDigit = 'K' ;
JavaIDDigit = 'L' ;
JavaIDDigit = 'M' ;
JavaIDDigit = 'N' ;
JavaIDDigit = 'O' ;
JavaIDDigit = 'P' ;
JavaIDDigit = 'Q' ;
JavaIDDigit = 'R' ;
JavaIDDigit = 'S' ;
JavaIDDigit = 'T' ;
JavaIDDigit = 'U' ;
JavaIDDigit = 'V' ;
JavaIDDigit = 'W' ;
JavaIDDigit = 'X' ;
JavaIDDigit = 'Y' ;
JavaIDDigit = 'Z' ;
elementValuePairs = elementValuePair (',' elementValuePair)* ;
elementValuePair = Identifier '=' elementValue ;
elementValue = conditionalExpression ;
elementValue = annotation ;
elementValue = elementValueArrayInitializer ;
conditionalExpression = conditionalOrExpression ('?' expression ':' expression)? ;
conditionalOrExpression = conditionalAndExpression ('||' conditionalAndExpression)* ;
conditionalAndExpression = inclusiveOrExpression ('&&' inclusiveOrExpression)* ;
inclusiveOrExpression = exclusiveOrExpression ('|' exclusiveOrExpression)* ;
exclusiveOrExpression = andExpression ('^' andExpression)* ;
andExpression = equalityExpression ('&' equalityExpression)* ;
equalityExpression = instanceOfExpression (('==' | '!=') instanceOfExpression)* ;
instanceOfExpression = relationalExpression ('instanceof' type)? ;
relationalExpression = shiftExpression (relationalOp shiftExpression)* ;
shiftExpression = additiveExpression (shiftOp additiveExpression)* ;
additiveExpression = multiplicativeExpression (('+' | '-') multiplicativeExpression)* ;
multiplicativeExpression = unaryExpression (('*' | '/' | '%') unaryExpression)* ;
unaryExpression = '+' unaryExpression ;
unaryExpression = '-' unaryExpression ;
unaryExpression = '++' unaryExpression ;
unaryExpression = '--' unaryExpression ;
unaryExpression = unaryExpressionNotPlusMinus ;
unaryExpressionNotPlusMinus = '~' unaryExpression ;
unaryExpressionNotPlusMinus = '!' unaryExpression ;
unaryExpressionNotPlusMinus = castExpression ;
unaryExpressionNotPlusMinus = primary selector* ('++' | '--')? ;
castExpression = '(' primitiveType ')' unaryExpression ;
castExpression = '(' (type | expression) ')' unaryExpressionNotPlusMinus ;
primitiveType = 'boolean' ;
primitiveType = 'char' ;
primitiveType = 'byte' ;
primitiveType = 'short' ;
primitiveType = 'int' ;
primitiveType = 'long' ;
primitiveType = 'float' ;
primitiveType = 'double' ;
type = classOrInterfaceType ('[' ']')* ;
type = primitiveType ('[' ']')* ;
classOrInterfaceType = Identifier typeArguments? ('.' Identifier typeArguments?)* ;
typeArguments = '<' typeArgument (',' typeArgument)* '>' ;
typeArgument = type ;
typeArgument = '?' (('extends' | 'super') type)? ;
expression = conditionalExpression (assignmentOperator expression)? ;
assignmentOperator = '=' ;
assignmentOperator = '+=' ;
assignmentOperator = '-=' ;
assignmentOperator = '*=' ;
assignmentOperator = '/=' ;
assignmentOperator = '&=' ;
assignmentOperator = '|=' ;
assignmentOperator = '^=' ;
assignmentOperator = '%=' ;
assignmentOperator = t1::'<' t2::'<' t3::'=' ;
assignmentOperator = t1::'>' t2::'>' t3::'>' t4::('='?) ;
assignmentOperator = t1::'>' t2::'>' t3::'=' ;
primary = parExpression ;
primary = 'this' ('.' Identifier)* identifierSuffix? ;
primary = 'super' superSuffix ;
primary = literal ;
primary = 'new' creator ;
primary = Identifier ('.' Identifier)* identifierSuffix? ;
primary = primitiveType ('[' ']')* '.' 'class' ;
primary = 'void' '.' 'class' ;
parExpression = '(' expression ')' ;
identifierSuffix = ('[' ']')+ '.' 'class' ;
identifierSuffix = ('[' expression ']')+ ;
identifierSuffix = arguments ;
identifierSuffix = '.' 'class' ;
identifierSuffix = '.' explicitGenericInvocation ;
identifierSuffix = '.' 'this' ;
identifierSuffix = '.' 'super' arguments ;
identifierSuffix = '.' 'new' innerCreator ;
arguments = '(' expressionList? ')' ;
expressionList = expression (',' expression)* ;
explicitGenericInvocation = nonWildcardTypeArguments Identifier arguments ;
nonWildcardTypeArguments = '<' typeList '>' ;
typeList = type (',' type)* ;
innerCreator = nonWildcardTypeArguments? Identifier classCreatorRest ;
classCreatorRest = arguments classBody? ;
classBody = '{' classBodyDeclaration* '}' ;
classBodyDeclaration = ';' ;
classBodyDeclaration = 'static'? block ;
classBodyDeclaration = modifiers memberDecl ;
block = '{' blockStatement* '}' ;
blockStatement = localVariableDeclarationStatement ;
blockStatement = classOrInterfaceDeclaration ;
blockStatement = statement ;
localVariableDeclarationStatement = localVariableDeclaration ';' ;
localVariableDeclaration = variableModifiers type variableDeclarators ;
variableModifiers = variableModifier* ;
variableModifier = 'final' ;
variableModifier = annotation ;
variableDeclarators = variableDeclarator (',' variableDeclarator)* ;
variableDeclarator = variableDeclaratorId ('=' variableInitializer)? ;
variableDeclaratorId = Identifier ('[' ']')* ;
variableInitializer = arrayInitializer ;
variableInitializer = expression ;
arrayInitializer = '{' (variableInitializer (',' variableInitializer)* ','?)? '}' ;
classOrInterfaceDeclaration = classOrInterfaceModifiers (classDeclaration | interfaceDeclaration) ;
classOrInterfaceModifiers = classOrInterfaceModifier* ;
classOrInterfaceModifier = annotation ;
classOrInterfaceModifier = 'public' ;
classOrInterfaceModifier = 'protected' ;
classOrInterfaceModifier = 'private' ;
classOrInterfaceModifier = 'abstract' ;
classOrInterfaceModifier = 'static' ;
classOrInterfaceModifier = 'final' ;
classOrInterfaceModifier = 'strictfp' ;
classDeclaration = normalClassDeclaration ;
classDeclaration = enumDeclaration ;
normalClassDeclaration = 'class' Identifier typeParameters? ('extends' type)? ('implements' typeList)? classBody ;
typeParameters = '<' typeParameter (',' typeParameter)* '>' ;
typeParameter = Identifier ('extends' typeBound)? ;
typeBound = type ('&' type)* ;
enumDeclaration = ENUM Identifier ('implements' typeList)? enumBody ;
ENUM = 'enum' ;
enumBody = '{' enumConstants? ','? enumBodyDeclarations? '}' ;
enumConstants = enumConstant (',' enumConstant)* ;
enumConstant = annotations? Identifier arguments? classBody? ;
enumBodyDeclarations = ';' classBodyDeclaration* ;
interfaceDeclaration = normalInterfaceDeclaration ;
interfaceDeclaration = annotationTypeDeclaration ;
normalInterfaceDeclaration = 'interface' Identifier typeParameters? ('extends' typeList)? interfaceBody ;
interfaceBody = '{' interfaceBodyDeclaration* '}' ;
interfaceBodyDeclaration = modifiers interfaceMemberDecl ;
interfaceBodyDeclaration = ';' ;
modifiers = modifier* ;
modifier = annotation ;
modifier = 'public' ;
modifier = 'protected' ;
modifier = 'private' ;
modifier = 'static' ;
modifier = 'abstract' ;
modifier = 'final' ;
modifier = 'native' ;
modifier = 'synchronized' ;
modifier = 'transient' ;
modifier = 'volatile' ;
modifier = 'strictfp' ;
interfaceMemberDecl = interfaceMethodOrFieldDecl ;
interfaceMemberDecl = interfaceGenericMethodDecl ;
interfaceMemberDecl = 'void' Identifier voidInterfaceMethodDeclaratorRest ;
interfaceMemberDecl = interfaceDeclaration ;
interfaceMemberDecl = classDeclaration ;
interfaceMethodOrFieldDecl = type Identifier interfaceMethodOrFieldRest ;
interfaceMethodOrFieldRest = constantDeclaratorsRest ';' ;
interfaceMethodOrFieldRest = interfaceMethodDeclaratorRest ;
constantDeclaratorsRest = constantDeclaratorRest (',' constantDeclarator)* ;
constantDeclaratorRest = ('[' ']')* '=' variableInitializer ;
constantDeclarator = Identifier constantDeclaratorRest ;
interfaceMethodDeclaratorRest = formalParameters ('[' ']')* ('throws' qualifiedNameList)? ';' ;
formalParameters = '(' formalParameterDecls? ')' ;
formalParameterDecls = variableModifiers type formalParameterDeclsRest ;
formalParameterDeclsRest = variableDeclaratorId (',' formalParameterDecls)? ;
formalParameterDeclsRest = '...' variableDeclaratorId ;
qualifiedNameList = qualifiedName (',' qualifiedName)* ;
qualifiedName = Identifier ('.' Identifier)* ;
interfaceGenericMethodDecl = typeParameters (type | 'void') Identifier interfaceMethodDeclaratorRest ;
voidInterfaceMethodDeclaratorRest = formalParameters ('throws' qualifiedNameList)? ';' ;
annotationTypeDeclaration = '@' 'interface' Identifier annotationTypeBody ;
annotationTypeBody = '{' annotationTypeElementDeclaration* '}' ;
annotationTypeElementDeclaration = modifiers annotationTypeElementRest ;
annotationTypeElementRest = type annotationMethodOrConstantRest ';' ;
annotationTypeElementRest = normalClassDeclaration ';'? ;
annotationTypeElementRest = normalInterfaceDeclaration ';'? ;
annotationTypeElementRest = enumDeclaration ';'? ;
annotationTypeElementRest = annotationTypeDeclaration ';'? ;
annotationMethodOrConstantRest = annotationMethodRest ;
annotationMethodOrConstantRest = annotationConstantRest ;
annotationMethodRest = Identifier '(' ')' defaultValue? ;
defaultValue = 'default' elementValue ;
annotationConstantRest = variableDeclarators ;
statement = block ;
statement = ASSERT expression (':' expression)? ';' ;
statement = 'if' parExpression statement ('else' statement)? ;
statement = 'for' '(' forControl ')' statement ;
statement = 'while' parExpression statement ;
statement = 'do' statement 'while' parExpression ';' ;
statement = 'try' block ((catches 'finally' block) | catches | ('finally' block)) ;
statement = 'switch' parExpression '{' switchBlockStatementGroups '}' ;
statement = 'synchronized' parExpression block ;
statement = 'return' expression? ';' ;
statement = 'throw' expression ';' ;
statement = 'break' Identifier? ';' ;
statement = 'continue' Identifier? ';' ;
statement = ';' ;
statement = statementExpression ';' ;
statement = Identifier ':' statement ;
ASSERT = 'assert' ;
forControl = enhancedForControl ;
forControl = forInit? ';' expression? ';' forUpdate? ;
enhancedForControl = variableModifiers type Identifier ':' expression ;
forInit = localVariableDeclaration ;
forInit = expressionList ;
forUpdate = expressionList ;
catches = catchClause catchClause* ;
catchClause = 'catch' '(' formalParameter ')' block ;
formalParameter = variableModifiers type variableDeclaratorId ;
switchBlockStatementGroups = switchBlockStatementGroup* ;
switchBlockStatementGroup = switchLabel+ blockStatement* ;
switchLabel = 'case' constantExpression ':' ;
switchLabel = 'case' enumConstantName ':' ;
switchLabel = 'default' ':' ;
constantExpression = expression ;
enumConstantName = Identifier ;
statementExpression = expression ;
memberDecl = genericMethodOrConstructorDecl ;
memberDecl = memberDeclaration ;
memberDecl = 'void' Identifier voidMethodDeclaratorRest ;
memberDecl = Identifier constructorDeclaratorRest ;
memberDecl = interfaceDeclaration ;
memberDecl = classDeclaration ;
genericMethodOrConstructorDecl = typeParameters genericMethodOrConstructorRest ;
genericMethodOrConstructorRest = (type | 'void') Identifier methodDeclaratorRest ;
genericMethodOrConstructorRest = Identifier constructorDeclaratorRest ;
methodDeclaratorRest = formalParameters ('[' ']')* ('throws' qualifiedNameList)? (methodBody | ';') ;
methodBody = block ;
constructorDeclaratorRest = formalParameters ('throws' qualifiedNameList)? constructorBody ;
constructorBody = '{' explicitConstructorInvocation? blockStatement* '}' ;
explicitConstructorInvocation = nonWildcardTypeArguments? ('this' | 'super') arguments ';' ;
explicitConstructorInvocation = primary '.' nonWildcardTypeArguments? 'super' arguments ';' ;
memberDeclaration = type (methodDeclaration | fieldDeclaration) ;
methodDeclaration = Identifier methodDeclaratorRest ;
fieldDeclaration = variableDeclarators ';' ;
voidMethodDeclaratorRest = formalParameters ('throws' qualifiedNameList)? (methodBody | ';') ;
superSuffix = arguments ;
superSuffix = '.' Identifier arguments? ;
literal = integerLiteral ;
literal = FloatingPointLiteral ;
literal = CharacterLiteral ;
literal = StringLiteral ;
literal = booleanLiteral ;
literal = 'null' ;
integerLiteral = HexLiteral ;
integerLiteral = OctalLiteral ;
integerLiteral = DecimalLiteral ;
HexLiteral = '0' ('x' | 'X') HexDigit+ IntegerTypeSuffix? ;
HexDigit = '0' ;
HexDigit = '1' ;
HexDigit = '2' ;
HexDigit = '3' ;
HexDigit = '4' ;
HexDigit = '5' ;
HexDigit = '6' ;
HexDigit = '7' ;
HexDigit = '8' ;
HexDigit = '9' ;
HexDigit = 'a' ;
HexDigit = 'b' ;
HexDigit = 'c' ;
HexDigit = 'd' ;
HexDigit = 'e' ;
HexDigit = 'f' ;
HexDigit = 'A' ;
HexDigit = 'B' ;
HexDigit = 'C' ;
HexDigit = 'D' ;
HexDigit = 'E' ;
HexDigit = 'F' ;
IntegerTypeSuffix = 'l' ;
IntegerTypeSuffix = 'L' ;
OctalLiteral = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')+ IntegerTypeSuffix? ;
DecimalLiteral = ('0' | (('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)) IntegerTypeSuffix? ;
FloatingPointLiteral = ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* Exponent? FloatTypeSuffix? ;
FloatingPointLiteral = '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ Exponent? FloatTypeSuffix? ;
FloatingPointLiteral = ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ Exponent FloatTypeSuffix? ;
FloatingPointLiteral = ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ FloatTypeSuffix ;
Exponent = ('e' | 'E') ('+' | '-')? ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ;
FloatTypeSuffix = 'f' ;
FloatTypeSuffix = 'F' ;
FloatTypeSuffix = 'd' ;
FloatTypeSuffix = 'D' ;
CharacterLiteral = '\'' (EscapeSequence | STR) '\'' ;
EscapeSequence = '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\') ;
EscapeSequence = UnicodeEscape ;
EscapeSequence = OctalEscape ;
UnicodeEscape = '\\' 'u' HexDigit HexDigit HexDigit HexDigit ;
OctalEscape = '\\' ('0' | '1' | '2' | '3') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
OctalEscape = '\\' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
OctalEscape = '\\' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ;
StringLiteral = '"' (EscapeSequence | STR)* '"' ;
booleanLiteral = 'true' ;
booleanLiteral = 'false' ;
creator = nonWildcardTypeArguments createdName classCreatorRest ;
creator = createdName (arrayCreatorRest | classCreatorRest) ;
createdName = classOrInterfaceType ;
createdName = primitiveType ;
arrayCreatorRest = '[' ((']' ('[' ']')* arrayInitializer) | (expression ']' ('[' expression ']')* ('[' ']')*)) ;
selector = '.' Identifier arguments? ;
selector = '.' 'this' ;
selector = '.' 'super' superSuffix ;
selector = '.' 'new' innerCreator ;
selector = '[' expression ']' ;
shiftOp = t1::'<' t2::('<'?) ;
shiftOp = t1::'>' t2::'>' t3::'>' ;
shiftOp = t1::'>' t2::('>'?) ;
relationalOp = t1::'<' t2::('='?) ;
relationalOp = t1::'>' t2::('='?) ;
relationalOp = '<' ;
relationalOp = '>' ;
elementValueArrayInitializer = '{' (elementValue (',' elementValue)*)? ','? '}' ;
packageDeclaration = 'package' qualifiedName ';' ;
importDeclaration = 'import' 'static'? qualifiedName ('.' '*')? ';' ;
typeDeclaration = classOrInterfaceDeclaration ;
typeDeclaration = ';' ;
