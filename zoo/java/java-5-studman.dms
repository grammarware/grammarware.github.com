compilationUnit = (packageDefinition | ) importDefinition* typeDefinition* ;
packageDefinition = annotations p::'package' IDENTIFIER SEMI ;
annotations = annotation* ;
annotation = AT i::IDENTIFIER (LPAREN args::annotationArguments? RPAREN)? ;
AT = '@' ;
identifier = IDENT (DOT IDENT)* ;
IDENT = ('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | '$') ('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '$')* ;
DOT = '.' ;
LPAREN = '(' ;
annotationArguments = annotationMemberValueInitializer ;
annotationArguments = anntotationMemberValuePairs ;
annotationMemberValueInitializer = conditionalExpression ;
annotationMemberValueInitializer = annotation ;
annotationMemberValueInitializer = annotationMemberArrayInitializer ;
conditionalExpression = logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression = logicalAndExpression (LOR logicalAndExpression)* ;
logicalAndExpression = inclusiveOrExpression (LAND inclusiveOrExpression)* ;
inclusiveOrExpression = exclusiveOrExpression (BOR exclusiveOrExpression)* ;
exclusiveOrExpression = andExpression (BXOR andExpression)* ;
andExpression = equalityExpression (BAND equalityExpression)* ;
equalityExpression = relationalExpression ((NOT_EQUAL | EQUAL) relationalExpression)* ;
relationalExpression = shiftExpression (((LT | GT | LE | GE) shiftExpression)* | ('instanceof' typeSpec)) ;
shiftExpression = additiveExpression ((SL | SR | BSR) additiveExpression)* ;
additiveExpression = multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression = unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression = INC unaryExpression ;
unaryExpression = DEC unaryExpression ;
unaryExpression = MINUS unaryExpression ;
unaryExpression = PLUS unaryExpression ;
unaryExpression = unaryExpressionNotPlusMinus ;
INC = '++' ;
DEC = '--' ;
MINUS = '-' ;
PLUS = '+' ;
unaryExpressionNotPlusMinus = BNOT unaryExpression ;
unaryExpressionNotPlusMinus = LNOT unaryExpression ;
unaryExpressionNotPlusMinus = lpb::LPAREN builtInTypeSpec RPAREN unaryExpression ;
unaryExpressionNotPlusMinus = lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus ;
unaryExpressionNotPlusMinus = postfixExpression ;
BNOT = '~' ;
LNOT = '!' ;
builtInTypeSpec = builtInType (lb::LBRACK RBRACK)* ;
builtInType = 'void' ;
builtInType = 'boolean' ;
builtInType = 'byte' ;
builtInType = 'char' ;
builtInType = 'short' ;
builtInType = 'int' ;
builtInType = 'float' ;
builtInType = 'long' ;
builtInType = 'double' ;
LBRACK = '[' ;
RBRACK = ']' ;
RPAREN = ')' ;
classTypeSpec = classOrInterfaceType (lb::LBRACK RBRACK)* ;
classOrInterfaceType = IDENT typeArguments? (DOT IDENT typeArguments?)* ;
typeArguments = LT typeArgument (COMMA typeArgument)* typeArgumentsOrParametersEnd? ;
LT = '<' ;
typeArgument = typeArgumentSpec ;
typeArgument = wildcardType ;
typeArgumentSpec = classTypeSpec ;
typeArgumentSpec = builtInTypeArraySpec ;
builtInTypeArraySpec = builtInType (lb::LBRACK RBRACK)+ ;
wildcardType = q::QUESTION typeArgumentBounds? ;
QUESTION = '?' ;
typeArgumentBounds = ('extends' | 'super') classOrInterfaceType ;
COMMA = ',' ;
typeArgumentsOrParametersEnd = GT ;
typeArgumentsOrParametersEnd = SR ;
typeArgumentsOrParametersEnd = BSR ;
GT = '>' ;
SR = '>>' ;
BSR = '>>>' ;
postfixExpression = primaryExpression ((DOT typeArguments? ((IDENT (lp::LPAREN argList RPAREN)?) | ('super' ((lp3::LPAREN argList RPAREN) | (DOT typeArguments? IDENT (lps::LPAREN argList RPAREN)?))))) | (DOT 'this') | (DOT newExpression) | (lb::LBRACK expression RBRACK))* (in::INC | de::DEC)? ;
primaryExpression = identPrimary (DOT 'class')? ;
primaryExpression = constant ;
primaryExpression = 'true' ;
primaryExpression = 'false' ;
primaryExpression = 'null' ;
primaryExpression = newExpression ;
primaryExpression = 'this' ;
primaryExpression = 'super' ;
primaryExpression = LPAREN assignmentExpression RPAREN ;
primaryExpression = builtInType (lbt::LBRACK RBRACK)* DOT 'class' ;
identPrimary = ta1::typeArguments? IDENT ((DOT ta2::typeArguments? IDENT) | )* ((lp::LPAREN argList RPAREN) | (lbc::LBRACK RBRACK)+)? ;
argList = expressionList ;
argList =  ;
expressionList = expression (COMMA expression)* ;
expression = assignmentExpression ;
assignmentExpression = conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN) assignmentExpression)? ;
ASSIGN = '=' ;
PLUS_ASSIGN = '+=' ;
MINUS_ASSIGN = '-=' ;
STAR_ASSIGN = '*=' ;
DIV_ASSIGN = '/=' ;
MOD_ASSIGN = '%=' ;
SR_ASSIGN = '>>=' ;
BSR_ASSIGN = '>>>=' ;
SL_ASSIGN = '<<=' ;
BAND_ASSIGN = '&=' ;
BXOR_ASSIGN = '^=' ;
BOR_ASSIGN = '|=' ;
constant = NUM_INT ;
constant = CHAR_LITERAL ;
constant = STRING_LITERAL ;
constant = NUM_FLOAT ;
constant = NUM_LONG ;
constant = NUM_DOUBLE ;
NUM_INT = '.' ((('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? f1::FLOAT_SUFFIX?) | '..')? ;
NUM_INT = (('0' ((('x' | 'X') HEX_DIGIT+) | ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ | ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')+)?) | (('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)) ('l' | 'L' | ('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* EXPONENT? f2::FLOAT_SUFFIX?) | (EXPONENT f3::FLOAT_SUFFIX?) | f4::FLOAT_SUFFIX)? ;
EXPONENT = ('e' | 'E') ('+' | '-')? ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ;
FLOAT_SUFFIX = 'f' ;
FLOAT_SUFFIX = 'F' ;
FLOAT_SUFFIX = 'd' ;
FLOAT_SUFFIX = 'D' ;
HEX_DIGIT = '0' ;
HEX_DIGIT = '1' ;
HEX_DIGIT = '2' ;
HEX_DIGIT = '3' ;
HEX_DIGIT = '4' ;
HEX_DIGIT = '5' ;
HEX_DIGIT = '6' ;
HEX_DIGIT = '7' ;
HEX_DIGIT = '8' ;
HEX_DIGIT = '9' ;
HEX_DIGIT = 'A' ;
HEX_DIGIT = 'B' ;
HEX_DIGIT = 'C' ;
HEX_DIGIT = 'D' ;
HEX_DIGIT = 'E' ;
HEX_DIGIT = 'F' ;
HEX_DIGIT = 'a' ;
HEX_DIGIT = 'b' ;
HEX_DIGIT = 'c' ;
HEX_DIGIT = 'd' ;
HEX_DIGIT = 'e' ;
HEX_DIGIT = 'f' ;
CHAR_LITERAL = '\'' (ESC | STR) '\'' ;
ESC = '\\' ('n' | 'r' | 't' | 'b' | 'f' | '"' | '\'' | '\\' | ('u'+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | (('0' | '1' | '2' | '3') (('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')?)?) | (('4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')?)) ;
STRING_LITERAL = '"' (ESC | STR)* '"' ;
NUM_FLOAT = '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? ('f' | 'F') ;
NUM_FLOAT = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('.' | EXPONENT | 'f' | 'F') ;
NUM_FLOAT = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ((('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)? EXPONENT? ('f' | 'F')) | EXPONENT) ;
NUM_LONG = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ('l' | 'L') ;
NUM_DOUBLE = '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? ('d' | 'D') ;
NUM_DOUBLE = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('.' | EXPONENT | 'd' | 'D') ;
NUM_DOUBLE = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ((('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)? EXPONENT? ('d' | 'D')) | EXPONENT) ;
newExpression = 'new' typeArguments? type ((LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?)) ;
type = classOrInterfaceType ;
type = builtInType ;
classBlock = LCURLY (classField | SEMI)* RCURLY ;
LCURLY = '{' ;
classField = mods::modifiers (td::typeDefinitionInternal | (tp::typeParameters? ((h::ctorHead s::constructorBody) | (t::typeSpec ((IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets tc::throwsClause? (s2::compoundStatement | SEMI)) | (v::variableDefinitions SEMI)))))) ;
classField = 'static' s3::compoundStatement ;
classField = s4::compoundStatement ;
modifiers = (modifier | annotation)* ;
modifier = 'private' ;
modifier = 'public' ;
modifier = 'protected' ;
modifier = 'static' ;
modifier = 'transient' ;
modifier = 'final' ;
modifier = 'abstract' ;
modifier = 'native' ;
modifier = 'threadsafe' ;
modifier = 'synchronized' ;
modifier = 'volatile' ;
modifier = 'strictfp' ;
typeDefinitionInternal = classDefinition ;
typeDefinitionInternal = interfaceDefinition ;
typeDefinitionInternal = enumDefinition ;
typeDefinitionInternal = annotationDefinition ;
classDefinition = 'class' IDENT tp::typeParameters? sc::superClassClause ic::implementsClause cb::classBlock ;
typeParameters = LT typeParameter (COMMA typeParameter)* typeArgumentsOrParametersEnd? ;
typeParameter = id::IDENT typeParameterBounds? ;
typeParameterBounds = 'extends' classOrInterfaceType (BAND classOrInterfaceType)* ;
BAND = '&' ;
superClassClause = ('extends' c::classOrInterfaceType)? ;
implementsClause = (i::'implements' classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceDefinition = 'interface' IDENT tp::typeParameters? ie::interfaceExtends ib::interfaceBlock ;
interfaceExtends = (e::'extends' classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceBlock = LCURLY (interfaceField | SEMI)* RCURLY ;
interfaceField = mods::modifiers (td::typeDefinitionInternal | (tp::typeParameters? t::typeSpec ((IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets tc::throwsClause? SEMI) | (v::variableDefinitions SEMI)))) ;
typeSpec = classTypeSpec ;
typeSpec = builtInTypeSpec ;
parameterDeclarationList = ((parameterDeclaration (COMMA parameterDeclaration)* (COMMA variableLengthParameterDeclaration)?) | variableLengthParameterDeclaration)? ;
parameterDeclaration = pm::parameterModifier t::typeSpec id::IDENT pd::declaratorBrackets ;
parameterModifier = annotation* f::'final'? annotation* ;
declaratorBrackets = (lb::LBRACK RBRACK)* ;
variableLengthParameterDeclaration = pm::parameterModifier t::typeSpec TRIPLE_DOT id::IDENT pd::declaratorBrackets ;
TRIPLE_DOT = '...' ;
throwsClause = 'throws' IDENTIFIER (COMMA IDENTIFIER)* ;
SEMI = ';' ;
variableDefinitions = variableDeclarator (COMMA variableDeclarator)* ;
variableDeclarator = id::IDENT d::declaratorBrackets v::varInitializer ;
varInitializer = (ASSIGN initializer)? ;
initializer = expression ;
initializer = arrayInitializer ;
arrayInitializer = lc::LCURLY (initializer (COMMA initializer)* COMMA?)? RCURLY ;
RCURLY = '}' ;
enumDefinition = 'enum' IDENT ic::implementsClause eb::enumBlock ;
enumBlock = LCURLY (enumConstant (COMMA enumConstant)* COMMA?)? (SEMI (classField | SEMI)*)? RCURLY ;
enumConstant = an::annotations i::IDENT (LPAREN a::argList RPAREN)? b::enumConstantBlock? ;
enumConstantBlock = LCURLY (enumConstantField | SEMI)* RCURLY ;
enumConstantField = mods::modifiers (td::typeDefinitionInternal | (tp::typeParameters? t::typeSpec ((IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets tc::throwsClause? (s2::compoundStatement | SEMI)) | (v::variableDefinitions SEMI)))) ;
enumConstantField = s4::compoundStatement ;
compoundStatement = lc::LCURLY statement* RCURLY ;
statement = compoundStatement ;
statement = declaration SEMI ;
statement = expression SEMI ;
statement = m::modifiers classDefinition ;
statement = IDENT c::COLON statement ;
statement = 'if' LPAREN expression RPAREN statement ('else' statement)? ;
statement = forStatement ;
statement = 'while' LPAREN expression RPAREN statement ;
statement = 'do' statement 'while' LPAREN expression RPAREN SEMI ;
statement = 'break' IDENT? SEMI ;
statement = 'continue' IDENT? SEMI ;
statement = 'return' expression? SEMI ;
statement = 'switch' LPAREN expression RPAREN LCURLY casesGroup* RCURLY ;
statement = tryBlock ;
statement = 'throw' expression SEMI ;
statement = 'synchronized' LPAREN expression RPAREN compoundStatement ;
statement = 'assert' expression (COLON expression)? SEMI ;
statement = s::SEMI ;
declaration = m::modifiers t::typeSpec v::variableDefinitions ;
COLON = ':' ;
forStatement = f::'for' LPAREN (traditionalForClause | forEachClause) RPAREN statement ;
traditionalForClause = forInit SEMI forCond SEMI forIter ;
forInit = (declaration | expressionList)? ;
forCond = expression? ;
forIter = expressionList? ;
forEachClause = p::parameterDeclaration COLON expression ;
casesGroup = aCase+ caseSList ;
aCase = (('case' expression) | 'default') COLON ;
caseSList = statement* ;
tryBlock = 'try' compoundStatement handler* finallyClause? ;
handler = 'catch' LPAREN parameterDeclaration RPAREN compoundStatement ;
finallyClause = 'finally' compoundStatement ;
annotationDefinition = AT 'interface' IDENT ab::annotationBlock ;
annotationBlock = LCURLY (annotationField | SEMI)* RCURLY ;
annotationField = mods::modifiers (td::typeDefinitionInternal | (t::typeSpec ((i::IDENT LPAREN RPAREN rt::declaratorBrackets ('default' amvi::annotationMemberValueInitializer)? SEMI) | (v::variableDefinitions SEMI)))) ;
ctorHead = IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
constructorBody = lc::LCURLY explicitConstructorInvocation? statement* RCURLY ;
explicitConstructorInvocation = typeArguments? (('this' lp1::LPAREN argList RPAREN SEMI) | ('super' lp2::LPAREN argList RPAREN SEMI)) ;
newArrayDeclarator = (lb::LBRACK expression? RBRACK)+ ;
STAR = '*' ;
DIV = '/' ;
MOD = '%' ;
SL = '<<' ;
LE = '<=' ;
GE = '>=' ;
NOT_EQUAL = '!=' ;
EQUAL = '==' ;
BXOR = '^' ;
BOR = '|' ;
LAND = '&&' ;
LOR = '||' ;
annotationMemberArrayInitializer = lc::LCURLY (annotationMemberArrayValueInitializer (COMMA annotationMemberArrayValueInitializer)* COMMA?)? RCURLY ;
annotationMemberArrayValueInitializer = conditionalExpression ;
annotationMemberArrayValueInitializer = annotation ;
anntotationMemberValuePairs = annotationMemberValuePair (COMMA annotationMemberValuePair)* ;
annotationMemberValuePair = i::IDENT ASSIGN v::annotationMemberValueInitializer ;
importDefinition = i::'import' 'static'? identifierStar SEMI ;
identifierStar = IDENT (DOT IDENT)* (DOT STAR)? ;
typeDefinition = m::modifiers typeDefinitionInternal ;
typeDefinition = SEMI ;
