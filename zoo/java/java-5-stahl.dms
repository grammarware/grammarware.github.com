compilationUnit = (packageDefinition | ) importDefinition* typeDefinition* ;
packageDefinition = annotations p::'package' IDENTIFIER SEMI ;
annotations = annotation* ;
annotation = AT IDENTIFIER annotationInit ;
AT = '@' ;
identifier = IDENT (DOT IDENT)* ;
IDENT = ('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | '$') ('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '$')* ;
DOT = '.' ;
annotationInit = lp::LPAREN ((annotationMemberInit (COMMA annotationMemberInit)*) | annotationMemberValue | ) RPAREN ;
annotationInit =  ;
LPAREN = '(' ;
annotationMemberInit = IDENT ASSIGN annotationMemberValue ;
ASSIGN = '=' ;
annotationMemberValue = annotation ;
annotationMemberValue = conditionalExpression ;
annotationMemberValue = annotationMemberArrayInitializer ;
conditionalExpression = logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression = logicalAndExpression (LOR logicalAndExpression)* ;
logicalAndExpression = inclusiveOrExpression (LAND inclusiveOrExpression)* ;
inclusiveOrExpression = exclusiveOrExpression (BOR exclusiveOrExpression)* ;
exclusiveOrExpression = andExpression (BXOR andExpression)* ;
andExpression = equalityExpression (BAND equalityExpression)* ;
equalityExpression = relationalExpression ((NOT_EQUAL | EQUAL) relationalExpression)* ;
relationalExpression = shiftExpression (((LT | GT | LE | GE) shiftExpression)* | ('instanceof' typeSpec)) ;
shiftExpression = additiveExpression ((SL | SR | BSR) additiveExpression)* ;
additiveExpression = multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression = unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression = INC unaryExpression ;
unaryExpression = DEC unaryExpression ;
unaryExpression = MINUS unaryExpression ;
unaryExpression = PLUS unaryExpression ;
unaryExpression = unaryExpressionNotPlusMinus ;
INC = '++' ;
DEC = '--' ;
MINUS = '-' ;
PLUS = '+' ;
unaryExpressionNotPlusMinus = BNOT unaryExpression ;
unaryExpressionNotPlusMinus = LNOT unaryExpression ;
unaryExpressionNotPlusMinus = lpb::LPAREN builtInTypeSpec RPAREN unaryExpression ;
unaryExpressionNotPlusMinus = lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus ;
unaryExpressionNotPlusMinus = postfixExpression ;
BNOT = '~' ;
LNOT = '!' ;
builtInTypeSpec = builtInType (lb::LBRACK RBRACK)* ;
builtInType = 'void' ;
builtInType = 'boolean' ;
builtInType = 'byte' ;
builtInType = 'char' ;
builtInType = 'short' ;
builtInType = 'int' ;
builtInType = 'float' ;
builtInType = 'long' ;
builtInType = 'double' ;
LBRACK = '[' ;
RBRACK = ']' ;
RPAREN = ')' ;
classTypeSpec = classOrInterfaceType (lb::LBRACK RBRACK)* ;
classOrInterfaceType = IDENT typeArguments (DOT IDENT typeArguments)* ;
typeArguments = lt::LT typeArgument (COMMA typeArgument)* typeArgumentsEnd? ;
typeArguments =  ;
LT = '<' ;
typeArgument = q::QUESTION (('extends' referenceTypeSpec) | ('super' referenceTypeSpec))? ;
typeArgument = referenceTypeSpec ;
QUESTION = '?' ;
referenceTypeSpec = classTypeSpec ;
referenceTypeSpec = arrayTypeSpec ;
arrayTypeSpec = builtInType (lb::LBRACK RBRACK)+ ;
COMMA = ',' ;
typeArgumentsEnd = GT ;
typeArgumentsEnd = SR ;
typeArgumentsEnd = BSR ;
GT = '>' ;
SR = '>>' ;
BSR = '>>>' ;
postfixExpression = primaryExpression ((DOT 'this') | (DOT ta1::typeArguments ((IDENT (lp::LPAREN argList RPAREN)?) | ('super' ((lp3::LPAREN argList RPAREN) | (DOT ta2::typeArguments IDENT (lps::LPAREN argList RPAREN)?))))) | (DOT newExpression) | (lb::LBRACK expression RBRACK))* (in::INC | de::DEC)? ;
primaryExpression = identPrimary (DOT 'class')? ;
primaryExpression = constant ;
primaryExpression = 'true' ;
primaryExpression = 'false' ;
primaryExpression = 'null' ;
primaryExpression = newExpression ;
primaryExpression = 'this' ;
primaryExpression = 'super' ;
primaryExpression = LPAREN assignmentExpression RPAREN ;
primaryExpression = builtInType (lbt::LBRACK RBRACK)* DOT 'class' ;
identPrimary = ta1::typeArguments IDENT ((DOT ta2::typeArguments IDENT) | )* ((lp::LPAREN argList RPAREN) | (lbc::LBRACK RBRACK)+)? ;
argList = expressionList ;
argList =  ;
expressionList = expression (COMMA expression)* ;
expression = assignmentExpression ;
assignmentExpression = conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN) assignmentExpression)? ;
PLUS_ASSIGN = '+=' ;
MINUS_ASSIGN = '-=' ;
STAR_ASSIGN = '*=' ;
DIV_ASSIGN = '/=' ;
MOD_ASSIGN = '%=' ;
SR_ASSIGN = '>>=' ;
BSR_ASSIGN = '>>>=' ;
SL_ASSIGN = '<<=' ;
BAND_ASSIGN = '&=' ;
BXOR_ASSIGN = '^=' ;
BOR_ASSIGN = '|=' ;
constant = NUM_INT ;
constant = CHAR_LITERAL ;
constant = STRING_LITERAL ;
constant = NUM_FLOAT ;
constant = NUM_LONG ;
constant = NUM_DOUBLE ;
NUM_INT = '.' (('.' '.') | (('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? f1::FLOAT_SUFFIX?)?) ;
NUM_INT = (('0' ((('x' | 'X') HEX_DIGIT+) | ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ | ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')+)?) | (('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)) ('l' | 'L' | ('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* EXPONENT? f2::FLOAT_SUFFIX?) | (EXPONENT f3::FLOAT_SUFFIX?) | f4::FLOAT_SUFFIX)? ;
EXPONENT = ('e' | 'E') ('+' | '-')? ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ;
FLOAT_SUFFIX = 'f' ;
FLOAT_SUFFIX = 'F' ;
FLOAT_SUFFIX = 'd' ;
FLOAT_SUFFIX = 'D' ;
HEX_DIGIT = '0' ;
HEX_DIGIT = '1' ;
HEX_DIGIT = '2' ;
HEX_DIGIT = '3' ;
HEX_DIGIT = '4' ;
HEX_DIGIT = '5' ;
HEX_DIGIT = '6' ;
HEX_DIGIT = '7' ;
HEX_DIGIT = '8' ;
HEX_DIGIT = '9' ;
HEX_DIGIT = 'A' ;
HEX_DIGIT = 'B' ;
HEX_DIGIT = 'C' ;
HEX_DIGIT = 'D' ;
HEX_DIGIT = 'E' ;
HEX_DIGIT = 'F' ;
HEX_DIGIT = 'a' ;
HEX_DIGIT = 'b' ;
HEX_DIGIT = 'c' ;
HEX_DIGIT = 'd' ;
HEX_DIGIT = 'e' ;
HEX_DIGIT = 'f' ;
CHAR_LITERAL = '\'' (ESC | STR) '\'' ;
ESC = '\\' ('n' | 'r' | 't' | 'b' | 'f' | '"' | '\'' | '\\' | ('u'+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | (('0' | '1' | '2' | '3') (('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')?)?) | (('4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')?)) ;
STRING_LITERAL = '"' (ESC | STR)* '"' ;
NUM_FLOAT = '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? ('f' | 'F') ;
NUM_FLOAT = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('.' | EXPONENT | 'f' | 'F') ;
NUM_FLOAT = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ((('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)? EXPONENT? ('f' | 'F')) | EXPONENT) ;
NUM_LONG = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ('l' | 'L') ;
NUM_DOUBLE = '.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ EXPONENT? ('d' | 'D') ;
NUM_DOUBLE = '0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('.' | EXPONENT | 'd' | 'D') ;
NUM_DOUBLE = ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')+ ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')* ((('.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*)? EXPONENT? ('d' | 'D')) | EXPONENT) ;
newExpression = 'new' typeArguments type ((LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?)) ;
type = classOrInterfaceType ;
type = builtInType ;
classBlock = LCURLY (classField | SEMI)* RCURLY ;
LCURLY = '{' ;
classField = mods::modifiers (it::innerTypeDef | (tp::typeParameters ((h::ctorHead s::constructorBody) | md::memberDef))) ;
classField = 'static' s3::compoundStatement ;
classField = s4::compoundStatement ;
modifiers = (modifier | annotation)* ;
modifier = 'private' ;
modifier = 'public' ;
modifier = 'protected' ;
modifier = 'static' ;
modifier = 'transient' ;
modifier = 'final' ;
modifier = 'abstract' ;
modifier = 'native' ;
modifier = 'threadsafe' ;
modifier = 'synchronized' ;
modifier = 'volatile' ;
modifier = 'strictfp' ;
innerTypeDef = ed::enumDefinition ;
innerTypeDef = cd::classDefinition ;
innerTypeDef = id::interfaceDefinition ;
innerTypeDef = ad::annotationTypeDefinition ;
enumDefinition = ENUM IDENT ic::implementsClause eb::enumBlock ;
ENUM = 'enum' ;
implementsClause = (i::'implements' classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
enumBlock = LCURLY (enumConst (COMMA enumConst)*)? COMMA? (SEMI (classField | SEMI)*)? RCURLY ;
enumConst = annotations IDENT enumConstInit classBlock? ;
enumConstInit = lp::LPAREN argList RPAREN ;
enumConstInit =  ;
SEMI = ';' ;
RCURLY = '}' ;
classDefinition = 'class' IDENT tp::typeParameters sc::superClassClause ic::implementsClause cb::classBlock ;
typeParameters = lt::LT typeParameter (COMMA typeParameter)* typeArgumentsEnd? ;
typeParameters =  ;
typeParameter = IDENT ('extends' classOrInterfaceType (BAND classOrInterfaceType)*)? ;
BAND = '&' ;
superClassClause = ('extends' classOrInterfaceType)? ;
interfaceDefinition = 'interface' IDENT tp::typeParameters ie::interfaceExtends ib::interfaceBlock ;
interfaceExtends = (e::'extends' classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceBlock = LCURLY (interfaceField | SEMI)* RCURLY ;
interfaceField = mods::modifiers (it::innerTypeDef | (tp::typeParameters md::memberDef)) ;
memberDef = t::typeSpec ((IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets tc::throwsClause? (SEMI | s2::compoundStatement)) | (v::variableDefinitions SEMI)) ;
typeSpec = classTypeSpec ;
typeSpec = builtInTypeSpec ;
parameterDeclarationList = (parameterDeclaration (COMMA parameterDeclaration)*)? ;
parameterDeclaration = pm::parameterModifier t::typeSpec el::ELLIPSIS? id::IDENT pd::declaratorBrackets ;
parameterModifier = ('final' | annotation)* ;
ELLIPSIS = '...' ;
declaratorBrackets = (lb::LBRACK RBRACK)* ;
throwsClause = 'throws' IDENTIFIER (COMMA IDENTIFIER)* ;
compoundStatement = lc::LCURLY statement* RCURLY ;
statement = compoundStatement ;
statement = declaration SEMI ;
statement = expression SEMI ;
statement = m::modifiers (enumDefinition | classDefinition) ;
statement = IDENT c::COLON statement ;
statement = 'if' LPAREN expression RPAREN statement ('else' statement)? ;
statement = 'for' LPAREN ((parameterDeclaration COLON expression) | (forInit SEMI forCond SEMI forIter)) RPAREN statement ;
statement = 'while' LPAREN expression RPAREN statement ;
statement = 'do' statement 'while' LPAREN expression RPAREN SEMI ;
statement = 'break' IDENT? SEMI ;
statement = 'continue' IDENT? SEMI ;
statement = 'return' expression? SEMI ;
statement = 'switch' LPAREN expression RPAREN LCURLY casesGroup* RCURLY ;
statement = tryBlock ;
statement = 'throw' expression SEMI ;
statement = 'synchronized' LPAREN expression RPAREN compoundStatement ;
statement = ASSERT expression (COLON expression)? SEMI ;
statement = s::SEMI ;
declaration = m::modifiers t::typeSpec v::variableDefinitions ;
variableDefinitions = variableDeclarator (COMMA variableDeclarator)* ;
variableDeclarator = id::IDENT d::declaratorBrackets v::varInitializer ;
varInitializer = (ASSIGN initializer)? ;
initializer = expression ;
initializer = arrayInitializer ;
arrayInitializer = lc::LCURLY (initializer (COMMA initializer)*)? COMMA? RCURLY ;
COLON = ':' ;
forInit = (declaration | expressionList)? ;
forCond = expression? ;
forIter = expressionList? ;
casesGroup = aCase+ caseSList ;
aCase = (('case' expression) | 'default') COLON ;
caseSList = statement* ;
tryBlock = 'try' compoundStatement handler* finallyClause? ;
handler = 'catch' LPAREN parameterDeclaration RPAREN compoundStatement ;
finallyClause = 'finally' compoundStatement ;
ASSERT = 'assert' ;
annotationTypeDefinition = AT 'interface' IDENT ab::annotationBlock ;
annotationBlock = LCURLY (annotationField | SEMI)* RCURLY ;
annotationField = mods::modifiers (it::innerTypeDef | (ts::typeSpec ((i::IDENT LPAREN RPAREN dv::defaultValue SEMI) | (v::variableDefinitions SEMI)))) ;
defaultValue = ('default' annotationMemberValue)? ;
ctorHead = IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
constructorBody = lc::LCURLY explicitConstructorInvocation? statement* RCURLY ;
explicitConstructorInvocation = typeArguments (('this' lp1::LPAREN argList RPAREN SEMI) | ('super' lp2::LPAREN argList RPAREN SEMI)) ;
newArrayDeclarator = (lb::LBRACK expression? RBRACK)+ ;
STAR = '*' ;
DIV = '/' ;
MOD = '%' ;
SL = '<<' ;
LE = '<=' ;
GE = '>=' ;
NOT_EQUAL = '!=' ;
EQUAL = '==' ;
BXOR = '^' ;
BOR = '|' ;
LAND = '&&' ;
LOR = '||' ;
annotationMemberArrayInitializer = lc::LCURLY (annotationMemberValue (COMMA annotationMemberValue)*)? COMMA? RCURLY ;
importDefinition = i::'import' 'static'? identifierStar SEMI ;
identifierStar = IDENT (DOT IDENT)* (DOT STAR)? ;
typeDefinition = m::modifiers (classDefinition | enumDefinition | interfaceDefinition | annotationTypeDefinition) ;
typeDefinition = SEMI ;
