module Main

exports
  sorts
        Character Graphic-character Identifier Letter-or-digit Numeric-literal Decimal-literal Numeral Exponent Based-literal Base Based-numeral Extended-digit Character-literal String-literal String-element Comment Pragma Pragma-argument-association Basic-declaration Defining-identifier Type-declaration Full-type-declaration Type-definition Subtype-declaration Subtype-indication Subtype-mark Constraint Scalar-constraint Composite-constraint Object-declaration Defining-identifier-list Number-declaration Derived-type-definition Range-constraint Range Enumeration-type-definition Enumeration-literal-specification Defining-character-literal Integer-type-definition Signed-integer-type-definition Modular-type-definition Real-type-definition Floating-point-definition Real-range-specification Fixed-point-definition Ordinary-fixed-point-definition Decimal-fixed-point-definition Digits-constraint Array-type-definition Unconstrained-array-definition Index-subtype-definition Constrained-array-definition Discrete-subtype-definition Component-definition Index-constraint Discrete-range Discriminant-part Unknown-discriminant-part Known-discriminant-part Discriminant-specification Default-expression Discriminant-constraint Discriminant-association Record-type-definition Record-definition Component-list Component-item Component-declaration Variant-part Variant Discrete-choice-list Discrete-choice Record-extension-part Access-type-definition Access-to-object-definition General-access-modifier Access-to-subprogram-definition Access-definition Incomplete-type-declaration Declarative-part Declarative-item Basic-declarative-item Body Proper-body Name Direct-name Prefix Explicit-dereference Implicit-dereference Indexed-component Slice Selected-component Selector-name Attribute-reference Attribute-designator Range-attribute-reference Range-attribute-designator Aggregate Record-aggregate Record-component-association-list Record-component-association Component-choice-list Extension-aggregate Ancestor-part Array-aggregate Positional-array-aggregate Named-array-aggregate Array-component-association Expression Relation Simple-expression Term Factor Primary Logical-operator Relational-operator Binary-adding-operator Unary-adding-operator Multiplying-operator Highest-precedence-operator Type-conversion Qualified-expression Allocator Sequence-of-statements Statement Simple-statement Compound-statement Null-statement Label Statement-identifier Assignment-statement If-statement Condition Case-statement Case-statement-alternative Loop-statement Iteration-scheme Loop-parameter-specification Block-statement Exit-statement Goto-statement Subprogram-declaration Abstract-subprogram-declaration Subprogram-specification Designator Defining-designator Defining-program-unit-name Operator-symbol Defining-operator-symbol Parameter-profile Parameter-and-result-profile Formal-part Parameter-specification Mode Subprogram-body Procedure-call-statement Function-call Actual-parameter-part Parameter-association Explicit-actual-parameter Return-statement Package-declaration Package-specification Package-body Private-type-declaration Private-extension-declaration Use-clause Use-package-clause Use-type-clause Renaming-declaration Object-renaming-declaration Exception-renaming-declaration Package-renaming-declaration Subprogram-renaming-declaration Generic-renaming-declaration Task-type-declaration Single-task-declaration Task-definition Task-item Task-body Protected-type-declaration Single-protected-declaration Protected-definition Protected-operation-declaration Protected-element-declaration Protected-body Protected-operation-item Entry-declaration Accept-statement Entry-index Entry-body Entry-body-formal-part Entry-barrier Entry-index-specification Entry-call-statement Requeue-statement Delay-statement Delay-until-statement Delay-relative-statement Select-statement Selective-accept Guard Select-alternative Accept-alternative Delay-alternative Terminate-alternative Timed-entry-call Entry-call-alternative Conditional-entry-call Asynchronous-select Triggering-alternative Triggering-statement Abortable-part Abort-statement Compilation Compilation-unit Library-item Library-unit-declaration Library-unit-renaming-declaration Library-unit-body Parent-unit-name Context-clause Context-item With-clause Body-stub Subprogram-body-stub Package-body-stub Task-body-stub Protected-body-stub Subunit Exception-declaration Handled-sequence-of-statements Exception-handler Choice-parameter-specification Exception-choice Raise-statement Generic-declaration Generic-subprogram-declaration Generic-package-declaration Generic-formal-part Generic-formal-parameter-declaration Generic-instantiation Generic-actual-part Generic-association Explicit-generic-actual-parameter Formal-object-declaration Formal-type-declaration Formal-type-definition Formal-private-type-definition Formal-derived-type-definition Formal-discrete-type-definition Formal-signed-integer-type-definition Formal-modular-type-definition Formal-floating-point-definition Formal-ordinary-fixed-point-definition Formal-decimal-fixed-point-definition Formal-array-type-definition Formal-access-type-definition Formal-subprogram-declaration Subprogram-default Default-name Formal-package-declaration Formal-package-actual-part Representation-clause Local-name Attribute-definition-clause Enumeration-representation-clause Enumeration-aggregate Record-representation-clause Component-clause Position First-bit Last-bit Code-statement Restriction Delta-constraint At-clause Mod-clause 
  context-free syntax
        Graphic-character
		| Format-effector
		| Other-control-function -> Character

        Identifier-letter
		| Digit
		| Space-character
		| Special-character -> Graphic-character

        Identifier-letter (Underline? Letter-or-digit)* -> Identifier

        Identifier-letter
		| Digit -> Letter-or-digit

        Decimal-literal
		| Based-literal -> Numeric-literal

        Numeral ("." Numeral)? Exponent? -> Decimal-literal

        Digit (Underline? Digit)* -> Numeral

        "E" "+"? Numeral
		| "E" "-" Numeral -> Exponent

        Base "#" Based-numeral ("." Based-numeral)? "#" Exponent? -> Based-literal

        Numeral -> Base

        Extended-digit (Underline? Extended-digit)* -> Based-numeral

        Digit
		| "A"
		| "B"
		| "C"
		| "D"
		| "E"
		| "F" -> Extended-digit

        "'" Graphic-character "'" -> Character-literal

        """ String-element* """ -> String-literal

        """"
		| Non-quotation-mark-graphic-character -> String-element

        "-" "-" Non-end-of-line-character* -> Comment

        "pragma" Identifier ("(" Pragma-argument-association ("," Pragma-argument-association)* ")")? ";" -> Pragma

        (Pragma-argument-identifier "=>")? Name
		| (Pragma-argument-identifier "=>")? Expression -> Pragma-argument-association

        Type-declaration
		| Subtype-declaration
		| Object-declaration
		| Number-declaration
		| Subprogram-declaration
		| Abstract-subprogram-declaration
		| Package-declaration
		| Renaming-declaration
		| Exception-declaration
		| Generic-declaration
		| Generic-instantiation -> Basic-declaration

        Identifier -> Defining-identifier

        Full-type-declaration
		| Incomplete-type-declaration
		| Private-type-declaration
		| Private-extension-declaration -> Type-declaration

        "type" Defining-identifier Known-discriminant-part? "is" Type-definition ";"
		| Task-type-declaration
		| Protected-type-declaration -> Full-type-declaration

        Enumeration-type-definition
		| Integer-type-definition
		| Real-type-definition
		| Array-type-definition
		| Record-type-definition
		| Access-type-definition
		| Derived-type-definition -> Type-definition

        "subtype" Defining-identifier "is" Subtype-indication ";" -> Subtype-declaration

        Subtype-mark Constraint? -> Subtype-indication

        Subtype-name -> Subtype-mark

        Scalar-constraint
		| Composite-constraint -> Constraint

        Range-constraint
		| Digits-constraint
		| Delta-constraint -> Scalar-constraint

        Index-constraint
		| Discriminant-constraint -> Composite-constraint

        Defining-identifier-list ":" "aliased"? "constant"? Subtype-indication (":=" Expression)? ";"
		| Defining-identifier-list ":" "aliased"? "constant"? Array-type-definition (":=" Expression)? ";"
		| Single-task-declaration
		| Single-protected-declaration -> Object-declaration

        Defining-identifier ("," Defining-identifier)* -> Defining-identifier-list

        Defining-identifier-list ":" "constant" ":=" Static-expression ";" -> Number-declaration

        "abstract"? "new" Parent-subtype-indication Record-extension-part? -> Derived-type-definition

        "range" Range -> Range-constraint

        Range-attribute-reference
		| Simple-expression ".." Simple-expression -> Range

        "(" Enumeration-literal-specification ("," Enumeration-literal-specification)* ")" -> Enumeration-type-definition

        Defining-identifier
		| Defining-character-literal -> Enumeration-literal-specification

        Character-literal -> Defining-character-literal

        Signed-integer-type-definition
		| Modular-type-definition -> Integer-type-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Signed-integer-type-definition

        "mod" Static-expression -> Modular-type-definition

        Floating-point-definition
		| Fixed-point-definition -> Real-type-definition

        "digits" Static-expression Real-range-specification? -> Floating-point-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Real-range-specification

        Ordinary-fixed-point-definition
		| Decimal-fixed-point-definition -> Fixed-point-definition

        "delta" Static-expression Real-range-specification -> Ordinary-fixed-point-definition

        "delta" Static-expression "digits" Static-expression Real-range-specification? -> Decimal-fixed-point-definition

        "digits" Static-expression Range-constraint? -> Digits-constraint

        Unconstrained-array-definition
		| Constrained-array-definition -> Array-type-definition

        "array" "(" Index-subtype-definition ("," Index-subtype-definition)* ")" "of" Component-definition -> Unconstrained-array-definition

        Subtype-mark "range" "<>" -> Index-subtype-definition

        "array" "(" Discrete-subtype-definition ("," Discrete-subtype-definition)* ")" "of" Component-definition -> Constrained-array-definition

        Discrete-subtype-indication
		| "range" -> Discrete-subtype-definition

        "aliased"? Subtype-indication -> Component-definition

        "(" Discrete-range ("," Discrete-range)* ")" -> Index-constraint

        Discrete-subtype-indication
		| Range -> Discrete-range

        Unknown-discriminant-part
		| Known-discriminant-part -> Discriminant-part

        "(<>)" -> Unknown-discriminant-part

        "(" Discriminant-specification (";" Discriminant-specification)* ")" -> Known-discriminant-part

        Defining-identifier-list ":" Subtype-mark (":=" Default-expression)?
		| Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Discriminant-specification

        Expression -> Default-expression

        "(" Discriminant-association ("," Discriminant-association)* ")" -> Discriminant-constraint

        (Discriminant-selector-name ("|" Discriminant-selector-name)* "=>")? Expression -> Discriminant-association

        ("abstract"? "tagged")? "limited"? Record-definition -> Record-type-definition

        "record" Component-list "end" "record"
		| "null" "record" -> Record-definition

        Component-item Component-item*
		| Component-item* Variant-part
		| "null" ";" -> Component-list

        Component-declaration
		| Representation-clause -> Component-item

        Defining-identifier-list ":" Component-definition (":=" Default-expression)? ";" -> Component-declaration

        "case" Discriminant-direct-name "is" Variant Variant* "end" "case" ";" -> Variant-part

        "when" Discrete-choice-list "=>" Component-list -> Variant

        Discrete-choice ("|" Discrete-choice)* -> Discrete-choice-list

        Expression
		| Discrete-range
		| "others" -> Discrete-choice

        "with" Record-definition -> Record-extension-part

        Access-to-object-definition
		| Access-to-subprogram-definition -> Access-type-definition

        "access" General-access-modifier? Subtype-indication -> Access-to-object-definition

        "all"
		| "constant" -> General-access-modifier

        "access" "protected"? "procedure" Parameter-profile
		| "access" "protected"? "function" Parameter-and-result-profile -> Access-to-subprogram-definition

        "access" Subtype-mark -> Access-definition

        "type" Defining-identifier Discriminant-part? ";" -> Incomplete-type-declaration

        Declarative-item* -> Declarative-part

        Basic-declarative-item
		| Body -> Declarative-item

        Basic-declaration
		| Representation-clause
		| Use-clause -> Basic-declarative-item

        Proper-body
		| Body-stub -> Body

        Subprogram-body
		| Package-body
		| Task-body
		| Protected-body -> Proper-body

        Direct-name
		| Explicit-dereference
		| Indexed-component
		| Slice
		| Selected-component
		| Attribute-reference
		| Type-conversion
		| Function-call
		| Character-literal -> Name

        Identifier
		| Operator-symbol -> Direct-name

        Name
		| Implicit-dereference -> Prefix

        Name "." "all" -> Explicit-dereference

        Name -> Implicit-dereference

        Prefix "(" Expression ("," Expression)* ")" -> Indexed-component

        Prefix "(" Discrete-range ")" -> Slice

        Prefix "." Selector-name -> Selected-component

        Identifier
		| Character-literal
		| Operator-symbol -> Selector-name

        Prefix "'" Attribute-designator -> Attribute-reference

        Identifier ("(" Static-expression ")")?
		| "Access"
		| "Delta"
		| "Digits" -> Attribute-designator

        Prefix "'" Range-attribute-designator -> Range-attribute-reference

        "Range" ("(" Static-expression ")")? -> Range-attribute-designator

        Record-aggregate
		| Extension-aggregate
		| Array-aggregate -> Aggregate

        "(" Record-component-association-list ")" -> Record-aggregate

        Record-component-association ("," Record-component-association)*
		| "null" "record" -> Record-component-association-list

        (Component-choice-list "=>")? Expression -> Record-component-association

        Component-selector-name ("|" Component-selector-name)*
		| "others" -> Component-choice-list

        "(" Ancestor-part "with" Record-component-association-list ")" -> Extension-aggregate

        Expression
		| Subtype-mark -> Ancestor-part

        Positional-array-aggregate
		| Named-array-aggregate -> Array-aggregate

        "(" Expression "," Expression ("," Expression)* ")"
		| "(" Expression ("," Expression)* "," "others" "=>" Expression ")" -> Positional-array-aggregate

        "(" Array-component-association ("," Array-component-association)* ")" -> Named-array-aggregate

        Discrete-choice-list "=>" Expression -> Array-component-association

        Relation ("and" Relation)*
		| Relation ("and" "then" Relation)*
		| Relation ("or" Relation)*
		| Relation ("or" "else" Relation)*
		| Relation ("xor" Relation)* -> Expression

        Simple-expression (Relational-operator Simple-expression)?
		| Simple-expression "not"? "in" Range
		| Simple-expression "not"? "in" Subtype-mark -> Relation

        Unary-adding-operator? Term (Binary-adding-operator Term)* -> Simple-expression

        Factor (Multiplying-operator Factor)* -> Term

        Primary ("**" Primary)?
		| "abs" Primary
		| "not" Primary -> Factor

        Numeric-literal
		| "null"
		| String-literal
		| Aggregate
		| Name
		| Qualified-expression
		| Allocator
		| "(" Expression ")" -> Primary

        "and"
		| "or"
		| "xor" -> Logical-operator

        "="
		| "/="
		| "<"
		| "<="
		| ">"
		| ">=" -> Relational-operator

        "+"
		| "-"
		| "&" -> Binary-adding-operator

        "+"
		| "-" -> Unary-adding-operator

        "*"
		| "/"
		| "mod"
		| "rem" -> Multiplying-operator

        "**"
		| "abs"
		| "not" -> Highest-precedence-operator

        Subtype-mark "(" Expression ")"
		| Subtype-mark "(" Name ")" -> Type-conversion

        Subtype-mark "'(" Expression ")"
		| Subtype-mark "'" Aggregate -> Qualified-expression

        "new" Subtype-indication
		| "new" Qualified-expression -> Allocator

        Statement Statement* -> Sequence-of-statements

        Label* Simple-statement
		| Label* Compound-statement -> Statement

        Null-statement
		| Assignment-statement
		| Exit-statement
		| Goto-statement
		| Procedure-call-statement
		| Return-statement
		| Entry-call-statement
		| Requeue-statement
		| Delay-statement
		| Abort-statement
		| Raise-statement
		| Code-statement -> Simple-statement

        If-statement
		| Case-statement
		| Loop-statement
		| Block-statement
		| Accept-statement
		| Select-statement -> Compound-statement

        "null" ";" -> Null-statement

        "<<" Label-statement-identifier ">>" -> Label

        Direct-name -> Statement-identifier

        Variable-name ":=" Expression ";" -> Assignment-statement

        "if" Condition "then" Sequence-of-statements ("elsif" Condition "then" Sequence-of-statements)* ("else" Sequence-of-statements)? "end" "if" ";" -> If-statement

        Boolean-expression -> Condition

        "case" Expression "is" Case-statement-alternative Case-statement-alternative* "end" "case" ";" -> Case-statement

        "when" Discrete-choice-list "=>" Sequence-of-statements -> Case-statement-alternative

        (Loop-statement-identifier ":")? Iteration-scheme? "loop" Sequence-of-statements "end" "loop" Loop-identifier? ";" -> Loop-statement

        "while" Condition
		| "for" Loop-parameter-specification -> Iteration-scheme

        Defining-identifier "in" "reverse"? Discrete-subtype-definition -> Loop-parameter-specification

        (Block-statement-identifier ":")? ("declare" Declarative-part)? "begin" Handled-sequence-of-statements "end" Block-identifier? ";" -> Block-statement

        "exit" Loop-name? ("when" Condition)? ";" -> Exit-statement

        "goto" Label-name ";" -> Goto-statement

        Subprogram-specification ";" -> Subprogram-declaration

        Subprogram-specification "is" "abstract" ";" -> Abstract-subprogram-declaration

        "procedure" Defining-program-unit-name Parameter-profile
		| "function" Defining-designator Parameter-and-result-profile -> Subprogram-specification

        (Parent-unit-name ".")? Identifier
		| Operator-symbol -> Designator

        Defining-program-unit-name
		| Defining-operator-symbol -> Defining-designator

        (Parent-unit-name ".")? Defining-identifier -> Defining-program-unit-name

        String-literal -> Operator-symbol

        Operator-symbol -> Defining-operator-symbol

        Formal-part? -> Parameter-profile

        Formal-part? "return" Subtype-mark -> Parameter-and-result-profile

        "(" Parameter-specification (";" Parameter-specification)* ")" -> Formal-part

        Defining-identifier-list ":" Mode Subtype-mark (":=" Default-expression)?
		| Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Parameter-specification

        "in"?
		| "in" "out"
		| "out" -> Mode

        Subprogram-specification "is" Declarative-part "begin" Handled-sequence-of-statements "end" Designator? ";" -> Subprogram-body

        Procedure-name ";"
		| Procedure-prefix Actual-parameter-part ";" -> Procedure-call-statement

        Function-name
		| Function-prefix Actual-parameter-part -> Function-call

        "(" Parameter-association ("," Parameter-association)* ")" -> Actual-parameter-part

        (Formal-parameter-selector-name "=>")? Explicit-actual-parameter -> Parameter-association

        Expression
		| Variable-name -> Explicit-actual-parameter

        "return" Expression? ";" -> Return-statement

        Package-specification ";" -> Package-declaration

        "package" Defining-program-unit-name "is" Basic-declarative-item* ("private" Basic-declarative-item*)? "end" ((Parent-unit-name ".")? Identifier)? -> Package-specification

        "package" Body Defining-program-unit-name "is" Declarative-part ("begin" Handled-sequence-of-statements)? "end" ((Parent-unit-name ".")? Identifier)? ";" -> Package-body

        "type" Defining-identifier Discriminant-part? "is" ("abstract"? "tagged")? "limited"? "private" ";" -> Private-type-declaration

        "type" Defining-identifier Discriminant-part? "is" "abstract"? "new" Ancestor-subtype-indication "with" "private" ";" -> Private-extension-declaration

        Use-package-clause
		| Use-type-clause -> Use-clause

        "use" Package-name ("," Package-name)* ";" -> Use-package-clause

        "use" "type" Subtype-mark ("," Subtype-mark)* ";" -> Use-type-clause

        Object-renaming-declaration
		| Exception-renaming-declaration
		| Package-renaming-declaration
		| Subprogram-renaming-declaration
		| Generic-renaming-declaration -> Renaming-declaration

        Defining-identifier ":" Subtype-mark "renames" Object-name ";" -> Object-renaming-declaration

        Defining-identifier ":" "exception" "renames" Exception-name ";" -> Exception-renaming-declaration

        "package" Defining-program-unit-name Renamespackage-name ";" -> Package-renaming-declaration

        Subprogram-specification "renames" Callable-entity-name ";" -> Subprogram-renaming-declaration

        "generic" "package" Defining-program-unit-name "renames" Generic-package-name ";"
		| "generic" "procedure" Defining-program-unit-name "renames" Generic-procedure-name ";"
		| "generic" "function" Defining-program-unit-name "renames" Generic-function-name ";" -> Generic-renaming-declaration

        "task" "type" Defining-identifier Known-discriminant-part? ("is" Task-definition)? ";" -> Task-type-declaration

        "task" Defining-identifier ("is" Task-definition)? ";" -> Single-task-declaration

        Task-item* ("private" Task-item*)? "end" Task-identifier? -> Task-definition

        Entry-declaration
		| Representation-clause -> Task-item

        "task" Body Defining-identifier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Task-identifier? ";" -> Task-body

        "protected" "type" Defining-identifier Known-discriminant-part? "is" Protected-definition ";" -> Protected-type-declaration

        "protected" Defining-identifier "is" Protected-definition ";" -> Single-protected-declaration

        Protected-operation-declaration* ("private" Protected-element-declaration*)? "end" Protected-identifier? -> Protected-definition

        Subprogram-declaration
		| Entry-declaration
		| Representation-clause -> Protected-operation-declaration

        Protected-operation-declaration
		| Component-declaration -> Protected-element-declaration

        "protected" Body Defining-identifier "is" Protected-operation-item* "end" Protected-identifier? ";" -> Protected-body

        Subprogram-declaration
		| Subprogram-body
		| Entry-body
		| Representation-clause -> Protected-operation-item

        "entry" Defining-identifier ("(" Discrete-subtype-definition ")")? Parameter-profile ";" -> Entry-declaration

        "accept" Entry-direct-name ("(" Entry-index ")")? Parameter-profile ("do" Handled-sequence-of-statements "end" Entry-identifier?)? ";" -> Accept-statement

        Expression -> Entry-index

        "entry" Defining-identifier Entry-body-formal-part Entry-barrier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Entry-identifier? ";" -> Entry-body

        ("(" Entry-index-specification ")")? Parameter-profile -> Entry-body-formal-part

        "when" Condition -> Entry-barrier

        "for" Defining-identifier "in" Discrete-subtype-definition -> Entry-index-specification

        Entry-name Actual-parameter-part? ";" -> Entry-call-statement

        "requeue" Entry-name ("with" "abort")? ";" -> Requeue-statement

        Delay-until-statement
		| Delay-relative-statement -> Delay-statement

        "delay" "until" Delay-expression ";" -> Delay-until-statement

        "delay" Delay-expression ";" -> Delay-relative-statement

        Selective-accept
		| Timed-entry-call
		| Conditional-entry-call
		| Asynchronous-select -> Select-statement

        "select" Guard? Select-alternative ("or" Guard? Select-alternative)* ("else" Sequence-of-statements)? "end" "select" ";" -> Selective-accept

        "when" Condition "=>" -> Guard

        Accept-alternative
		| Delay-alternative
		| Terminate-alternative -> Select-alternative

        Accept-statement Sequence-of-statements? -> Accept-alternative

        Delay-statement Sequence-of-statements? -> Delay-alternative

        "terminate" ";" -> Terminate-alternative

        "select" Entry-call-alternative "or" Delay-alternative "end" "select" ";" -> Timed-entry-call

        Entry-call-statement Sequence-of-statements? -> Entry-call-alternative

        "select" Entry-call-alternative "else" Sequence-of-statements "end" "select" ";" -> Conditional-entry-call

        "select" Triggering-alternative "then" "abort" Abortable-part "end" "select" ";" -> Asynchronous-select

        Triggering-statement Sequence-of-statements? -> Triggering-alternative

        Entry-call-statement
		| Delay-statement -> Triggering-statement

        Sequence-of-statements -> Abortable-part

        "abort" Task-name ("," Task-name)* ";" -> Abort-statement

        Compilation-unit* -> Compilation

        Context-clause Library-item
		| Context-clause Subunit -> Compilation-unit

        "private"? Library-unit-declaration
		| Library-unit-body
		| "private"? Library-unit-renaming-declaration -> Library-item

        Subprogram-declaration
		| Package-declaration
		| Generic-declaration
		| Generic-instantiation -> Library-unit-declaration

        Package-renaming-declaration
		| Generic-renaming-declaration
		| Subprogram-renaming-declaration -> Library-unit-renaming-declaration

        Subprogram-body
		| Package-body -> Library-unit-body

        Name -> Parent-unit-name

        Context-item* -> Context-clause

        With-clause
		| Use-clause -> Context-item

        "with" Library-unit-name ("," Library-unit-name)* ";" -> With-clause

        Subprogram-body-stub
		| Package-body-stub
		| Task-body-stub
		| Protected-body-stub -> Body-stub

        Subprogram-specification "is" "separate" ";" -> Subprogram-body-stub

        "package" Body Defining-identifier "is" "separate" ";" -> Package-body-stub

        "task" Body Defining-identifier "is" "separate" ";" -> Task-body-stub

        "protected" Body Defining-identifier "is" "separate" ";" -> Protected-body-stub

        "separate" "(" Parent-unit-name ")" Proper-body -> Subunit

        Defining-identifier-list ":" "exception" ";" -> Exception-declaration

        Sequence-of-statements ("exception" Exception-handler Exception-handler*)? -> Handled-sequence-of-statements

        "when" (Choice-parameter-specification ":")? Exception-choice ("|" Exception-choice)* "=>" Sequence-of-statements -> Exception-handler

        Defining-identifier -> Choice-parameter-specification

        Exception-name
		| "others" -> Exception-choice

        "raise" Exception-name? ";" -> Raise-statement

        Generic-subprogram-declaration
		| Generic-package-declaration -> Generic-declaration

        Generic-formal-part Subprogram-specification ";" -> Generic-subprogram-declaration

        Generic-formal-part Package-specification ";" -> Generic-package-declaration

        "generic" (Generic-formal-parameter-declaration | Use-clause)* -> Generic-formal-part

        Formal-object-declaration
		| Formal-type-declaration
		| Formal-subprogram-declaration
		| Formal-package-declaration -> Generic-formal-parameter-declaration

        "package" Defining-program-unit-name "is" "new" Generic-package-name Generic-actual-part? ";"
		| "procedure" Defining-program-unit-name "is" "new" Generic-procedure-name Generic-actual-part? ";"
		| "function" Defining-designator "is" "new" Generic-function-name Generic-actual-part? ";" -> Generic-instantiation

        "(" Generic-association ("," Generic-association)* ")" -> Generic-actual-part

        (Generic-formal-parameter-selector-name "=>")? Explicit-generic-actual-parameter -> Generic-association

        Expression
		| Variable-name
		| Subprogram-name
		| Entry-name
		| Subtype-mark
		| Package-instance-name -> Explicit-generic-actual-parameter

        Defining-identifier-list ":" Mode Subtype-mark (":=" Default-expression)? ";" -> Formal-object-declaration

        "type" Defining-identifier Discriminant-part? "is" Formal-type-definition ";" -> Formal-type-declaration

        Formal-private-type-definition
		| Formal-derived-type-definition
		| Formal-discrete-type-definition
		| Formal-signed-integer-type-definition
		| Formal-modular-type-definition
		| Formal-floating-point-definition
		| Formal-ordinary-fixed-point-definition
		| Formal-decimal-fixed-point-definition
		| Formal-array-type-definition
		| Formal-access-type-definition -> Formal-type-definition

        ("abstract"? "tagged")? "limited"? "private" -> Formal-private-type-definition

        "abstract"? "new" Subtype-mark ("with" "private")? -> Formal-derived-type-definition

        "(<>)" -> Formal-discrete-type-definition

        "range" "<>" -> Formal-signed-integer-type-definition

        "mod" "<>" -> Formal-modular-type-definition

        "digits" "<>" -> Formal-floating-point-definition

        "delta" "<>" -> Formal-ordinary-fixed-point-definition

        "delta" "<>" "digits" "<>" -> Formal-decimal-fixed-point-definition

        Array-type-definition -> Formal-array-type-definition

        Access-type-definition -> Formal-access-type-definition

        "with" Subprogram-specification ("is" Subprogram-default)? ";" -> Formal-subprogram-declaration

        Default-name
		| "<>" -> Subprogram-default

        Name -> Default-name

        "with" "package" Defining-identifier "is" "new" Generic-package-name Formal-package-actual-part ";" -> Formal-package-declaration

        "(<>)"
		| Generic-actual-part? -> Formal-package-actual-part

        Attribute-definition-clause
		| Enumeration-representation-clause
		| Record-representation-clause
		| At-clause -> Representation-clause

        Direct-name
		| Direct-name "'" Attribute-designator
		| Library-unit-name -> Local-name

        "for" Local-name "'" Attribute-designator "use" Expression ";"
		| "for" Local-name "'" Attribute-designator "use" Name ";" -> Attribute-definition-clause

        "for" First-subtype-local-name "use" Enumeration-aggregate ";" -> Enumeration-representation-clause

        Array-aggregate -> Enumeration-aggregate

        "for" First-subtype-local-name "use" "record" Mod-clause? Component-clause* "end" "record" ";" -> Record-representation-clause

        Component-local-name "at" Position "range" First-bit ".." Last-bit ";" -> Component-clause

        Static-expression -> Position

        Static-simple-expression -> First-bit

        Static-simple-expression -> Last-bit

        Qualified-expression ";" -> Code-statement

        Restriction-identifier
		| Restriction-parameter-identifier "=>" Expression -> Restriction

        "delta" Static-expression Range-constraint? -> Delta-constraint

        "for" Direct-name "use" "at" Expression ";" -> At-clause

        "at" "mod" Static-expression ";" -> Mod-clause
