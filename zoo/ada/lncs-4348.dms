identifier = identifier_start (identifier_start | identifier_extend)* ;
identifier_start = letter_uppercase ;
identifier_start = letter_lowercase ;
identifier_start = letter_titlecase ;
identifier_start = letter_modifier ;
identifier_start = letter_other ;
identifier_start = number_letter ;
identifier_extend = mark_non_spacing ;
identifier_extend = mark_spacing_combining ;
identifier_extend = number_decimal ;
identifier_extend = punctuation_connector ;
identifier_extend = other_format ;
numeric_literal = decimal_literal ;
numeric_literal = based_literal ;
decimal_literal = numeral ('.' numeral)? exponent? ;
numeral = digit (underline? digit)* ;
exponent = 'E' '+'? numeral ;
exponent = 'E' '-' numeral ;
digit = '0' ;
digit = '1' ;
digit = '2' ;
digit = '3' ;
digit = '4' ;
digit = '5' ;
digit = '6' ;
digit = '7' ;
digit = '8' ;
digit = '9' ;
based_literal = base '#' based_numeral ('.' based_numeral)? '#' exponent? ;
base = numeral ;
based_numeral = extended_digit (underline? extended_digit)* ;
extended_digit = digit ;
extended_digit = 'A' ;
extended_digit = 'B' ;
extended_digit = 'C' ;
extended_digit = 'D' ;
extended_digit = 'E' ;
extended_digit = 'F' ;
character_literal = ''' graphic_character ''' ;
string_literal = '"' string_element* '"' ;
string_element = '""' ;
string_element = non_quotation_mark_graphic_character ;
comment = '-' '-' non_end_of_line_character* ;
pragma = 'pragma' IDENTIFIER ('(' pragma_argument_association (',' pragma_argument_association)* ')')? ';' ;
pragma_argument_association = (pragma_argument_identifier '=>')? name ;
pragma_argument_association = (pragma_argument_identifier '=>')? expression ;
basic_declaration = type_declaration ;
basic_declaration = object_declaration ;
basic_declaration = subprogram_declaration ;
basic_declaration = null_procedure_declaration ;
basic_declaration = renaming_declaration ;
basic_declaration = generic_declaration ;
basic_declaration = subtype_declaration ;
basic_declaration = number_declaration ;
basic_declaration = abstract_subprogram_declaration ;
basic_declaration = package_declaration ;
basic_declaration = exception_declaration ;
basic_declaration = generic_instantiation ;
defining_identifier = IDENTIFIER ;
type_declaration = full_type_declaration ;
type_declaration = incomplete_type_declaration ;
type_declaration = private_type_declaration ;
type_declaration = private_extension_declaration ;
full_type_declaration = 'type' defining_identifier known_discriminant_part? 'is' type_definition ';' ;
full_type_declaration = task_type_declaration ;
full_type_declaration = protected_type_declaration ;
type_definition = enumeration_type_definition ;
type_definition = real_type_definition ;
type_definition = record_type_definition ;
type_definition = derived_type_definition ;
type_definition = integer_type_definition ;
type_definition = array_type_definition ;
type_definition = access_type_definition ;
type_definition = interface_type_definition ;
subtype_declaration = 'subtype' defining_identifier 'is' subtype_indication ';' ;
subtype_indication = null_exclusion? subtype_mark constraint? ;
subtype_mark = subtype_name ;
constraint = scalar_constraint ;
constraint = composite_constraint ;
scalar_constraint = range_constraint ;
scalar_constraint = digits_constraint ;
scalar_constraint = delta_constraint ;
composite_constraint = index_constraint ;
composite_constraint = discriminant_constraint ;
object_declaration = defining_identifier_list ':' 'aliased'? 'constant'? subtype_indication (':=' expression)? ';' ;
object_declaration = defining_identifier_list ':' 'aliased'? 'constant'? access_definition (':=' expression)? ';' ;
object_declaration = defining_identifier_list ':' 'aliased'? 'constant'? array_type_definition (':=' expression)? ';' ;
object_declaration = single_task_declaration ;
object_declaration = single_protected_declaration ;
defining_identifier_list = defining_identifier (',' defining_identifier)* ;
number_declaration = defining_identifier_list ':' 'constant' ':=' static_expression ';' ;
derived_type_definition = 'abstract'? 'limited'? 'new' parent_subtype_indication (('and' interface_list)? record_extension_part)? ;
range_constraint = 'range' range ;
range = range_attribute_reference ;
range = simple_expression '..' simple_expression ;
enumeration_type_definition = '(' enumeration_literal_specification (',' enumeration_literal_specification)* ')' ;
enumeration_literal_specification = defining_identifier ;
enumeration_literal_specification = defining_character_literal ;
defining_character_literal = character_literal ;
integer_type_definition = signed_integer_type_definition ;
integer_type_definition = modular_type_definition ;
signed_integer_type_definition = 'range' static_simple_expression '..' static_simple_expression ;
modular_type_definition = 'mod' static_expression ;
real_type_definition = floating_point_definition ;
real_type_definition = fixed_point_definition ;
floating_point_definition = 'digits' static_expression real_range_specification? ;
real_range_specification = 'range' static_simple_expression '..' static_simple_expression ;
fixed_point_definition = ordinary_fixed_point_definition ;
fixed_point_definition = decimal_fixed_point_definition ;
ordinary_fixed_point_definition = 'delta' static_expression real_range_specification ;
decimal_fixed_point_definition = 'delta' static_expression 'digits' static_expression real_range_specification? ;
digits_constraint = 'digits' static_expression range_constraint? ;
array_type_definition = unconstrained_array_definition ;
array_type_definition = constrained_array_definition ;
unconstrained_array_definition = 'array' '(' index_subtype_definition (',' index_subtype_definition)* ')' 'of' component_definition ;
index_subtype_definition = subtype_mark 'range' '<>' ;
constrained_array_definition = 'array' '(' discrete_subtype_definition (',' discrete_subtype_definition)* ')' 'of' component_definition ;
discrete_subtype_definition = discrete_subtype_indication ;
discrete_subtype_definition = range ;
component_definition = 'aliased'? subtype_indication ;
component_definition = 'aliased'? access_definition ;
index_constraint = '(' discrete_range (',' discrete_range)* ')' ;
discrete_range = discrete_subtype_indication ;
discrete_range = range ;
discriminant_part = unknown_discriminant_part ;
discriminant_part = known_discriminant_part ;
unknown_discriminant_part = '(<>)' ;
known_discriminant_part = '(' discriminant_specification (';' discriminant_specification)* ')' ;
discriminant_specification = defining_identifier_list ':' null_exclusion? subtype_mark (':=' default_expression)? ;
discriminant_specification = defining_identifier_list ':' access_definition (':=' default_expression)? ;
default_expression = expression ;
discriminant_constraint = '(' discriminant_association (',' discriminant_association)* ')' ;
discriminant_association = (discriminant_selector_name ('|' discriminant_selector_name)* '=>')? expression ;
record_type_definition = ('abstract'? 'tagged')? 'limited'? record_definition ;
record_definition = 'record' component_list 'end' 'record' ;
record_definition = 'null' 'record' ;
component_list = component_item component_item* ;
component_list = component_item* variant_part ;
component_list = 'null' ';' ;
component_item = component_declaration ;
component_item = aspect_clause ;
component_declaration = defining_identifier_list ':' component_definition (':=' default_expression)? ';' ;
variant_part = 'case' discriminant_direct_name 'is' variant+ 'end' 'case' ';' ;
variant = 'when' discrete_choice_list '=>' component_list ;
discrete_choice_list = discrete_choice ('|' discrete_choice)* ;
discrete_choice = expression ;
discrete_choice = discrete_range ;
discrete_choice = 'others' ;
record_extension_part = 'with' record_definition ;
abstract_subprogram_declaration = overriding_indicator? subprogram_specification 'is' 'abstract' ';' ;
interface_type_definition = ('limited' | 'task' | 'protected' | 'synchronized')? 'interface' ('and' interface_list)? ;
interface_list = interface_subtype_mark ('and' interface_subtype_mark)* ;
access_type_definition = null_exclusion? access_to_object_definition ;
access_type_definition = null_exclusion? access_to_subprogram_definition ;
access_to_object_definition = 'access' general_access_modifier? subtype_indication ;
general_access_modifier = 'all' ;
general_access_modifier = 'constant' ;
access_to_subprogram_definition = 'access' 'protected'? 'procedure' parameter_profile ;
access_to_subprogram_definition = 'access' 'protected'? 'function' parameter_and_result_profile ;
null_exclusion = 'not' 'null' ;
access_definition = null_exclusion? 'access' 'constant'? subtype_mark ;
access_definition = null_exclusion? 'access' 'protected'? 'procedure' parameter_profile ;
access_definition = null_exclusion? 'access' 'protected'? 'function' parameter_and_result_profile ;
incomplete_type_declaration = 'type' defining_identifier discriminant_part? ('is' 'tagged')? ';' ;
declarative_part = declarative_item* ;
declarative_item = basic_declarative_item ;
declarative_item = body ;
basic_declarative_item = basic_declaration ;
basic_declarative_item = aspect_clause ;
basic_declarative_item = use_clause ;
body = proper_body ;
body = body_stub ;
proper_body = subprogram_body ;
proper_body = package_body ;
proper_body = task_body ;
proper_body = protected_body ;
name = direct_name ;
name = indexed_component ;
name = selected_component ;
name = type_conversion ;
name = character_literal ;
name = explicit_dereference ;
name = slice ;
name = attribute_reference ;
name = function_call ;
direct_name = IDENTIFIER ;
direct_name = operator_symbol ;
prefix = name ;
prefix = implicit_dereference ;
explicit_dereference = name '.' 'all' ;
implicit_dereference = name ;
indexed_component = prefix '(' expression (',' expression)* ')' ;
slice = prefix '(' discrete_range ')' ;
selected_component = prefix '.' selector_name ;
selector_name = IDENTIFIER ;
selector_name = character_literal ;
selector_name = operator_symbol ;
attribute_reference = prefix ''' attribute_designator ;
attribute_designator = IDENTIFIER ('(' static_expression ')')? ;
attribute_designator = 'Access' ;
attribute_designator = 'Delta' ;
attribute_designator = 'Digits' ;
range_attribute_reference = prefix ''' range_attribute_designator ;
range_attribute_designator = 'Range' ('(' static_expression ')')? ;
aggregate = record_aggregate ;
aggregate = extension_aggregate ;
aggregate = array_aggregate ;
record_aggregate = '(' record_component_association_list ')' ;
record_component_association_list = record_component_association (',' record_component_association)* ;
record_component_association_list = 'null' 'record' ;
record_component_association = (component_choice_list '=>')? expression ;
record_component_association = component_choice_list '=><>' ;
component_choice_list = component_selector_name ('|' component_selector_name)* ;
component_choice_list = 'others' ;
extension_aggregate = '(' ancestor_part 'with' record_component_association_list ')' ;
ancestor_part = expression ;
ancestor_part = subtype_mark ;
array_aggregate = positional_array_aggregate ;
array_aggregate = named_array_aggregate ;
positional_array_aggregate = '(' expression ',' expression (',' expression)* ')' ;
positional_array_aggregate = '(' expression (',' expression)* ',' 'others' '=>' expression ')' ;
positional_array_aggregate = '(' expression (',' expression)* ',' 'others' '=><>)' ;
named_array_aggregate = '(' array_component_association (',' array_component_association)* ')' ;
array_component_association = discrete_choice_list '=>' expression ;
array_component_association = discrete_choice_list '=><>' ;
expression = relation ('and' relation)* ;
expression = relation ('or' relation)* ;
expression = relation ('xor' relation)* ;
expression = relation ('and' 'then' relation)* ;
expression = relation ('or' 'else' relation)* ;
relation = simple_expression (relational_operator simple_expression)? ;
relation = simple_expression 'not'? 'in' range ;
relation = simple_expression 'not'? 'in' subtype_mark ;
simple_expression = unary_adding_operator? term (binary_adding_operator term)* ;
term = factor (multiplying_operator factor)* ;
factor = primary ('**' primary)? ;
factor = 'abs' primary ;
factor = 'not' primary ;
primary = numeric_literal ;
primary = 'null' ;
primary = string_literal ;
primary = aggregate ;
primary = name ;
primary = qualified_expression ;
primary = allocator ;
primary = '(' expression ')' ;
logical_operator = 'and' ;
logical_operator = 'or' ;
logical_operator = 'xor' ;
relational_operator = '=' ;
relational_operator = '/=' ;
relational_operator = '<' ;
relational_operator = '<=' ;
relational_operator = '>' ;
relational_operator = '>=' ;
binary_adding_operator = '+' ;
binary_adding_operator = '-' ;
binary_adding_operator = '&' ;
unary_adding_operator = '+' ;
unary_adding_operator = '-' ;
multiplying_operator = '*' ;
multiplying_operator = '/' ;
multiplying_operator = 'mod' ;
multiplying_operator = 'rem' ;
highest_precedence_operator = '**' ;
highest_precedence_operator = 'abs' ;
highest_precedence_operator = 'not' ;
type_conversion = subtype_mark '(' expression ')' ;
type_conversion = subtype_mark '(' name ')' ;
qualified_expression = subtype_mark ''(' expression ')' ;
qualified_expression = subtype_mark ''' aggregate ;
allocator = 'new' subtype_indication ;
allocator = 'new' qualified_expression ;
sequence_of_statements = statement statement* ;
statement = label* simple_statement ;
statement = label* compound_statement ;
simple_statement = null_statement ;
simple_statement = assignment_statement ;
simple_statement = goto_statement ;
simple_statement = simple_return_statement ;
simple_statement = requeue_statement ;
simple_statement = abort_statement ;
simple_statement = code_statement ;
simple_statement = exit_statement ;
simple_statement = procedure_call_statement ;
simple_statement = entry_call_statement ;
simple_statement = delay_statement ;
simple_statement = raise_statement ;
compound_statement = if_statement ;
compound_statement = loop_statement ;
compound_statement = extended_return_statement ;
compound_statement = accept_statement ;
compound_statement = case_statement ;
compound_statement = block_statement ;
compound_statement = select_statement ;
null_statement = 'null' ';' ;
label = '<<' label_statement_identifier '>>' ;
statement_identifier = direct_name ;
assignment_statement = variable_name ':=' expression ';' ;
if_statement = 'if' condition 'then' sequence_of_statements ('elsif' condition 'then' sequence_of_statements)* ('else' sequence_of_statements)? 'end' 'if' ';' ;
condition = boolean_expression ;
case_statement = 'case' expression 'is' case_statement_alternative case_statement_alternative* 'end' 'case' ';' ;
case_statement_alternative = 'when' discrete_choice_list '=>' sequence_of_statements ;
loop_statement = (loop_statement_identifier ':')? iteration_scheme? 'loop' sequence_of_statements 'end' 'loop' loop_identifier? ';' ;
iteration_scheme = 'while' condition ;
iteration_scheme = 'for' loop_parameter_specification ;
loop_parameter_specification = defining_identifier 'in' 'reverse'? discrete_subtype_definition ;
block_statement = (block_statement_identifier ':')? ('declare' declarative_part)? 'begin' handled_sequence_of_statements 'end' block_identifier? ';' ;
exit_statement = 'exit' loop_name? ('when' condition)? ';' ;
goto_statement = 'goto' label_name ';' ;
subprogram_declaration = overriding_indicator? subprogram_specification ';' ;
subprogram_specification = procedure_specification ;
subprogram_specification = function_specification ;
procedure_specification = 'procedure' defining_program_unit_name parameter_profile ;
function_specification = 'function' defining_designator parameter_and_result_profile ;
designator = (parent_unit_name '.')? IDENTIFIER ;
designator = operator_symbol ;
defining_designator = defining_program_unit_name ;
defining_designator = defining_operator_symbol ;
defining_program_unit_name = (parent_unit_name '.')? defining_identifier ;
operator_symbol = string_literal ;
defining_operator_symbol = operator_symbol ;
parameter_profile = formal_part? ;
parameter_and_result_profile = formal_part? 'return' null_exclusion? subtype_mark ;
parameter_and_result_profile = formal_part? 'return' access_definition ;
formal_part = '(' parameter_specification (';' parameter_specification)* ')' ;
parameter_specification = defining_identifier_list ':' mode null_exclusion? subtype_mark (':=' default_expression)? ;
parameter_specification = defining_identifier_list ':' access_definition (':=' default_expression)? ;
mode = 'in'? ;
mode = 'in' 'out' ;
mode = 'out' ;
subprogram_body = overriding_indicator? subprogram_specification 'is' declarative_part 'begin' handled_sequence_of_statements 'end' designator? ';' ;
procedure_call_statement = procedure_name ';' ;
procedure_call_statement = procedure_prefix actual_parameter_part ';' ;
function_call = function_name ;
function_call = function_prefix actual_parameter_part ;
actual_parameter_part = '(' parameter_association (',' parameter_association)* ')' ;
parameter_association = (formal_parameter_selector_name '=>')? explicit_actual_parameter ;
explicit_actual_parameter = expression ;
explicit_actual_parameter = variable_name ;
simple_return_statement = 'return' expression? ';' ;
extended_return_statement = 'return' defining_identifier ':' 'aliased'? return_subtype_indication (':=' expression)? ('do' handled_sequence_of_statements 'end' 'return')? ';' ;
return_subtype_indication = subtype_indication ;
return_subtype_indication = access_definition ;
null_procedure_declaration = overriding_indicator? procedure_specification 'is' 'null' ';' ;
package_declaration = package_specification ';' ;
package_specification = 'package' defining_program_unit_name 'is' basic_declarative_item* ('private' basic_declarative_item*)? 'end' ((parent_unit_name '.')? IDENTIFIER)? ;
package_body = 'package' 'body' defining_program_unit_name 'is' declarative_part ('begin' handled_sequence_of_statements)? 'end' ((parent_unit_name '.')? IDENTIFIER)? ';' ;
private_type_declaration = 'type' defining_identifier discriminant_part? 'is' ('abstract'? 'tagged')? 'limited'? 'private' ';' ;
private_extension_declaration = 'type' defining_identifier discriminant_part? 'is' 'abstract'? ('limited' | 'synchronized')? 'new' ancestor_subtype_indication ('and' interface_list)? 'with' 'private' ';' ;
overriding_indicator = 'not'? 'overriding' ;
use_clause = use_package_clause ;
use_clause = use_type_clause ;
use_package_clause = 'use' package_name (',' package_name)* ';' ;
use_type_clause = 'use' 'type' subtype_mark (',' subtype_mark)* ';' ;
renaming_declaration = object_renaming_declaration ;
renaming_declaration = exception_renaming_declaration ;
renaming_declaration = package_renaming_declaration ;
renaming_declaration = subprogram_renaming_declaration ;
renaming_declaration = generic_renaming_declaration ;
object_renaming_declaration = defining_identifier ':' null_exclusion? subtype_mark 'renames' object_name ';' ;
object_renaming_declaration = defining_identifier ':' access_definition 'renames' object_name ';' ;
exception_renaming_declaration = defining_identifier ':' 'exception' 'renames' exception_name ';' ;
package_renaming_declaration = 'package' defining_program_unit_name 'renames' package_name ';' ;
subprogram_renaming_declaration = overriding_indicator? subprogram_specification 'renames' callable_entity_name ';' ;
generic_renaming_declaration = 'generic' 'package' defining_program_unit_name 'renames' generic_package_name ';' ;
generic_renaming_declaration = 'generic' 'procedure' defining_program_unit_name 'renames' generic_procedure_name ';' ;
generic_renaming_declaration = 'generic' 'function' defining_program_unit_name 'renames' generic_function_name ';' ;
task_type_declaration = 'task' 'type' defining_identifier known_discriminant_part? ('is' ('new' interface_list 'with')? task_definition)? ';' ;
single_task_declaration = 'task' defining_identifier ('is' ('new' interface_list 'with')? task_definition)? ';' ;
task_definition = task_item* ('private' task_item*)? 'end' task_identifier? ;
task_item = entry_declaration ;
task_item = aspect_clause ;
task_body = 'task' 'body' defining_identifier 'is' declarative_part 'begin' handled_sequence_of_statements 'end' task_identifier? ';' ;
protected_type_declaration = 'protected' 'type' defining_identifier known_discriminant_part? 'is' ('new' interface_list 'with')? protected_definition ';' ;
single_protected_declaration = 'protected' defining_identifier 'is' ('new' interface_list 'with')? protected_definition ';' ;
protected_definition = protected_operation_declaration* ('private' protected_element_declaration*)? 'end' protected_identifier? ;
protected_operation_declaration = subprogram_declaration ;
protected_operation_declaration = entry_declaration ;
protected_operation_declaration = aspect_clause ;
protected_element_declaration = protected_operation_declaration ;
protected_element_declaration = component_declaration ;
protected_body = 'protected' 'body' defining_identifier 'is' protected_operation_item* 'end' protected_identifier? ';' ;
protected_operation_item = subprogram_declaration ;
protected_operation_item = subprogram_body ;
protected_operation_item = entry_body ;
protected_operation_item = aspect_clause ;
entry_declaration = overriding_indicator? 'entry' defining_identifier ('(' discrete_subtype_definition ')')? parameter_profile ';' ;
accept_statement = 'accept' entry_direct_name ('(' entry_index ')')? parameter_profile ('do' handled_sequence_of_statements 'end' entry_identifier?)? ';' ;
entry_index = expression ;
entry_body = 'entry' defining_identifier entry_body_formal_part entry_barrier 'is' declarative_part 'begin' handled_sequence_of_statements 'end' entry_identifier? ';' ;
entry_body_formal_part = ('(' entry_index_specification ')')? parameter_profile ;
entry_barrier = 'when' condition ;
entry_index_specification = 'for' defining_identifier 'in' discrete_subtype_definition ;
entry_call_statement = entry_name actual_parameter_part? ';' ;
requeue_statement = 'requeue' entry_name ('with' 'abort')? ';' ;
delay_statement = delay_until_statement ;
delay_statement = delay_relative_statement ;
delay_until_statement = 'delay' 'until' delay_expression ';' ;
delay_relative_statement = 'delay' delay_expression ';' ;
select_statement = selective_accept ;
select_statement = timed_entry_call ;
select_statement = conditional_entry_call ;
select_statement = asynchronous_select ;
selective_accept = 'select' guard? select_alternative ('or' guard? select_alternative)* ('else' sequence_of_statements)? 'end' 'select' ';' ;
guard = 'when' condition '=>' ;
select_alternative = accept_alternative ;
select_alternative = delay_alternative ;
select_alternative = terminate_alternative ;
accept_alternative = accept_statement sequence_of_statements? ;
delay_alternative = delay_statement sequence_of_statements? ;
terminate_alternative = 'terminate' ';' ;
timed_entry_call = 'select' entry_call_alternative 'or' delay_alternative 'end' 'select' ';' ;
entry_call_alternative = procedure_or_entry_call sequence_of_statements? ;
procedure_or_entry_call = procedure_call_statement ;
procedure_or_entry_call = entry_call_statement ;
conditional_entry_call = 'select' entry_call_alternative 'else' sequence_of_statements 'end' 'select' ';' ;
asynchronous_select = 'select' triggering_alternative 'then' 'abort' abortable_part 'end' 'select' ';' ;
triggering_alternative = triggering_statement sequence_of_statements? ;
triggering_statement = procedure_or_entry_call ;
triggering_statement = delay_statement ;
abortable_part = sequence_of_statements ;
abort_statement = 'abort' task_name (',' task_name)* ';' ;
compilation = compilation_unit* ;
compilation_unit = context_clause library_item ;
compilation_unit = context_clause subunit ;
library_item = 'private'? library_unit_declaration ;
library_item = library_unit_body ;
library_item = 'private'? library_unit_renaming_declaration ;
library_unit_declaration = subprogram_declaration ;
library_unit_declaration = package_declaration ;
library_unit_declaration = generic_declaration ;
library_unit_declaration = generic_instantiation ;
library_unit_renaming_declaration = package_renaming_declaration ;
library_unit_renaming_declaration = generic_renaming_declaration ;
library_unit_renaming_declaration = subprogram_renaming_declaration ;
library_unit_body = subprogram_body ;
library_unit_body = package_body ;
parent_unit_name = name ;
context_clause = context_item* ;
context_item = with_clause ;
context_item = use_clause ;
with_clause = limited_with_clause ;
with_clause = nonlimited_with_clause ;
limited_with_clause = 'limited' 'private'? 'with' library_unit_name (',' library_unit_name)* ';' ;
nonlimited_with_clause = 'private'? 'with' library_unit_name (',' library_unit_name)* ';' ;
body_stub = subprogram_body_stub ;
body_stub = package_body_stub ;
body_stub = task_body_stub ;
body_stub = protected_body_stub ;
subprogram_body_stub = overriding_indicator? subprogram_specification 'is' 'separate' ';' ;
package_body_stub = 'package' 'body' defining_identifier 'is' 'separate' ';' ;
task_body_stub = 'task' 'body' defining_identifier 'is' 'separate' ';' ;
protected_body_stub = 'protected' 'body' defining_identifier 'is' 'separate' ';' ;
subunit = 'separate' '(' parent_unit_name ')' proper_body ;
exception_declaration = defining_identifier_list ':' 'exception' ';' ;
handled_sequence_of_statements = sequence_of_statements ('exception' exception_handler exception_handler*)? ;
exception_handler = 'when' (choice_parameter_specification ':')? exception_choice ('|' exception_choice)* '=>' sequence_of_statements ;
choice_parameter_specification = defining_identifier ;
exception_choice = exception_name ;
exception_choice = 'others' ;
raise_statement = 'raise' ';' ;
raise_statement = 'raise' exception_name ('with' string_expression)? ';' ;
generic_declaration = generic_subprogram_declaration ;
generic_declaration = generic_package_declaration ;
generic_subprogram_declaration = generic_formal_part subprogram_specification ';' ;
generic_package_declaration = generic_formal_part package_specification ';' ;
generic_formal_part = 'generic' (generic_formal_parameter_declaration | use_clause)* ;
generic_formal_parameter_declaration = formal_object_declaration ;
generic_formal_parameter_declaration = formal_type_declaration ;
generic_formal_parameter_declaration = formal_subprogram_declaration ;
generic_formal_parameter_declaration = formal_package_declaration ;
generic_instantiation = 'package' defining_program_unit_name 'is' 'new' generic_package_name generic_actual_part? ';' ;
generic_instantiation = overriding_indicator? 'procedure' defining_program_unit_name 'is' 'new' generic_procedure_name generic_actual_part? ';' ;
generic_instantiation = overriding_indicator? 'function' defining_designator 'is' 'new' generic_function_name generic_actual_part? ';' ;
generic_actual_part = '(' generic_association (',' generic_association)* ')' ;
generic_association = (generic_formal_parameter_selector_name '=>')? explicit_generic_actual_parameter ;
explicit_generic_actual_parameter = expression ;
explicit_generic_actual_parameter = variable_name ;
explicit_generic_actual_parameter = subprogram_name ;
explicit_generic_actual_parameter = entry_name ;
explicit_generic_actual_parameter = subtype_mark ;
explicit_generic_actual_parameter = package_instance_name ;
formal_object_declaration = defining_identifier_list ':' mode null_exclusion? subtype_mark (':=' default_expression)? ';' defining_identifier_list ':' mode access_definition (':=' default_expression)? ';' ;
formal_type_declaration = 'type' defining_identifier discriminant_part? 'is' formal_type_definition ';' ;
formal_type_definition = formal_private_type_definition ;
formal_type_definition = formal_derived_type_definition ;
formal_type_definition = formal_discrete_type_definition ;
formal_type_definition = formal_signed_integer_type_definition ;
formal_type_definition = formal_modular_type_definition ;
formal_type_definition = formal_floating_point_definition ;
formal_type_definition = formal_ordinary_fixed_point_definition ;
formal_type_definition = formal_decimal_fixed_point_definition ;
formal_type_definition = formal_array_type_definition ;
formal_type_definition = formal_access_type_definition ;
formal_type_definition = formal_interface_type_definition ;
formal_private_type_definition = ('abstract'? 'tagged')? 'limited'? 'private' ;
formal_derived_type_definition = 'abstract'? ('limited' | 'synchronized')? 'new' subtype_mark (('and' interface_list)? 'with' 'private')? ;
formal_discrete_type_definition = '(<>)' ;
formal_signed_integer_type_definition = 'range' '<>' ;
formal_modular_type_definition = 'mod' '<>' ;
formal_floating_point_definition = 'digits' '<>' ;
formal_ordinary_fixed_point_definition = 'delta' '<>' ;
formal_decimal_fixed_point_definition = 'delta' '<>' 'digits' '<>' ;
formal_array_type_definition = array_type_definition ;
formal_access_type_definition = access_type_definition ;
formal_interface_type_definition = interface_type_definition ;
formal_subprogram_declaration = formal_concrete_subprogram_declaration ;
formal_subprogram_declaration = formal_abstract_subprogram_declaration ;
formal_concrete_subprogram_declaration = 'with' subprogram_specification ('is' subprogram_default)? ';' ;
formal_abstract_subprogram_declaration = 'with' subprogram_specification 'is' 'abstract' subprogram_default? ';' ;
subprogram_default = default_name ;
subprogram_default = '<>' ;
subprogram_default = 'null' ;
default_name = name ;
formal_package_declaration = 'with' 'package' defining_identifier 'is' 'new' generic_package_name formal_package_actual_part ';' ;
formal_package_actual_part = '(' ('others' '=>')? '<>)' ;
formal_package_actual_part = generic_actual_part? ;
formal_package_actual_part = '(' formal_package_association (',' formal_package_association)* (',' 'others' '=><>')? ')' ;
formal_package_association = generic_association ;
formal_package_association = generic_formal_parameter_selector_name '=><>' ;
aspect_clause = attribute_definition_clause ;
aspect_clause = enumeration_representation_clause ;
aspect_clause = record_representation_clause ;
aspect_clause = at_clause ;
local_name = direct_name ;
local_name = direct_name ''' attribute_designator ;
local_name = library_unit_name ;
attribute_definition_clause = 'for' local_name ''' attribute_designator 'use' expression ';' ;
attribute_definition_clause = 'for' local_name ''' attribute_designator 'use' name ';' ;
enumeration_representation_clause = 'for' first_subtype_local_name 'use' enumeration_aggregate ';' ;
enumeration_aggregate = array_aggregate ;
record_representation_clause = 'for' first_subtype_local_name 'use' 'record' mod_clause? component_clause* 'end' 'record' ';' ;
component_clause = component_local_name 'at' position 'range' first_bit '..' last_bit ';' ;
position = static_expression ;
first_bit = static_simple_expression ;
last_bit = static_simple_expression ;
code_statement = qualified_expression ';' ;
restriction = restriction_identifier ;
restriction = restriction_parameter_identifier '=>' restriction_parameter_argument ;
restriction_parameter_argument = name ;
restriction_parameter_argument = expression ;
delta_constraint = 'delta' static_expression range_constraint? ;
at_clause = 'for' direct_name 'use' 'at' expression ';' ;
mod_clause = 'at' 'mod' static_expression ';' ;
non_quotation_mark_graphic_character = graphic_character ;
non_end_of_line_character = 'character' ;
pragma_argument_identifier = IDENTIFIER ;
subtype_name = name ;
static_expression = expression ;
parent_subtype_indication = subtype_indication ;
static_simple_expression = simple_expression ;
discrete_subtype_indication = subtype_indication ;
discriminant_selector_name = selector_name ;
discriminant_direct_name = direct_name ;
interface_subtype_mark = subtype_mark ;
component_selector_name = selector_name ;
label_statement_identifier = statement_identifier ;
variable_name = name ;
boolean_expression = expression ;
loop_statement_identifier = statement_identifier ;
loop_identifier = IDENTIFIER ;
block_statement_identifier = statement_identifier ;
block_identifier = IDENTIFIER ;
loop_name = name ;
label_name = name ;
procedure_name = name ;
procedure_prefix = prefix ;
function_name = name ;
function_prefix = prefix ;
formal_parameter_selector_name = selector_name ;
ancestor_subtype_indication = subtype_indication ;
package_name = name ;
object_name = name ;
exception_name = name ;
callable_entity_name = name ;
generic_package_name = name ;
generic_procedure_name = name ;
generic_function_name = name ;
task_identifier = IDENTIFIER ;
protected_identifier = IDENTIFIER ;
entry_direct_name = direct_name ;
entry_identifier = IDENTIFIER ;
entry_name = name ;
delay_expression = expression ;
task_name = name ;
library_unit_name = name ;
string_expression = expression ;
generic_formal_parameter_selector_name = selector_name ;
subprogram_name = name ;
package_instance_name = name ;
first_subtype_local_name = local_name ;
component_local_name = local_name ;
restriction_identifier = IDENTIFIER ;
restriction_parameter_identifier = IDENTIFIER ;
