module Main

exports
  sorts
        Identifier Identifier-start Identifier-extend Numeric-literal Decimal-literal Numeral Exponent Digit Based-literal Base Based-numeral Extended-digit Character-literal String-literal String-element Comment Pragma Pragma-argument-association Basic-declaration Defining-identifier Type-declaration Full-type-declaration Type-definition Subtype-declaration Subtype-indication Subtype-mark Constraint Scalar-constraint Composite-constraint Object-declaration Defining-identifier-list Number-declaration Derived-type-definition Range-constraint Range Enumeration-type-definition Enumeration-literal-specification Defining-character-literal Integer-type-definition Signed-integer-type-definition Modular-type-definition Real-type-definition Floating-point-definition Real-range-specification Fixed-point-definition Ordinary-fixed-point-definition Decimal-fixed-point-definition Digits-constraint Array-type-definition Unconstrained-array-definition Index-subtype-definition Constrained-array-definition Discrete-subtype-definition Component-definition Index-constraint Discrete-range Discriminant-part Unknown-discriminant-part Known-discriminant-part Discriminant-specification Default-expression Discriminant-constraint Discriminant-association Record-type-definition Record-definition Component-list Component-item Component-declaration Variant-part Variant Discrete-choice-list Discrete-choice Record-extension-part Abstract-subprogram-declaration Interface-type-definition Interface-list Access-type-definition Access-to-object-definition General-access-modifier Access-to-subprogram-definition Null-exclusion Access-definition Incomplete-type-declaration Declarative-part Declarative-item Basic-declarative-item Body Proper-body Name Direct-name Prefix Explicit-dereference Implicit-dereference Indexed-component Slice Selected-component Selector-name Attribute-reference Attribute-designator Range-attribute-reference Range-attribute-designator Aggregate Record-aggregate Record-component-association-list Record-component-association Component-choice-list Extension-aggregate Ancestor-part Array-aggregate Positional-array-aggregate Named-array-aggregate Array-component-association Expression Relation Simple-expression Term Factor Primary Logical-operator Relational-operator Binary-adding-operator Unary-adding-operator Multiplying-operator Highest-precedence-operator Type-conversion Qualified-expression Allocator Sequence-of-statements Statement Simple-statement Compound-statement Null-statement Label Statement-identifier Assignment-statement If-statement Condition Case-statement Case-statement-alternative Loop-statement Iteration-scheme Loop-parameter-specification Block-statement Exit-statement Goto-statement Subprogram-declaration Subprogram-specification Procedure-specification Function-specification Designator Defining-designator Defining-program-unit-name Operator-symbol Defining-operator-symbol Parameter-profile Parameter-and-result-profile Formal-part Parameter-specification Mode Subprogram-body Procedure-call-statement Function-call Actual-parameter-part Parameter-association Explicit-actual-parameter Simple-return-statement Extended-return-statement Return-subtype-indication Null-procedure-declaration Package-declaration Package-specification Package-body Private-type-declaration Private-extension-declaration Overriding-indicator Use-clause Use-package-clause Use-type-clause Renaming-declaration Object-renaming-declaration Exception-renaming-declaration Package-renaming-declaration Subprogram-renaming-declaration Generic-renaming-declaration Task-type-declaration Single-task-declaration Task-definition Task-item Task-body Protected-type-declaration Single-protected-declaration Protected-definition Protected-operation-declaration Protected-element-declaration Protected-body Protected-operation-item Entry-declaration Accept-statement Entry-index Entry-body Entry-body-formal-part Entry-barrier Entry-index-specification Entry-call-statement Requeue-statement Delay-statement Delay-until-statement Delay-relative-statement Select-statement Selective-accept Guard Select-alternative Accept-alternative Delay-alternative Terminate-alternative Timed-entry-call Entry-call-alternative Procedure-or-entry-call Conditional-entry-call Asynchronous-select Triggering-alternative Triggering-statement Abortable-part Abort-statement Compilation Compilation-unit Library-item Library-unit-declaration Library-unit-renaming-declaration Library-unit-body Parent-unit-name Context-clause Context-item With-clause Limited-with-clause Nonlimited-with-clause Body-stub Subprogram-body-stub Package-body-stub Task-body-stub Protected-body-stub Subunit Exception-declaration Handled-sequence-of-statements Exception-handler Choice-parameter-specification Exception-choice Raise-statement Generic-declaration Generic-subprogram-declaration Generic-package-declaration Generic-formal-part Generic-formal-parameter-declaration Generic-instantiation Generic-actual-part Generic-association Explicit-generic-actual-parameter Formal-object-declaration Formal-type-declaration Formal-type-definition Formal-private-type-definition Formal-derived-type-definition Formal-discrete-type-definition Formal-signed-integer-type-definition Formal-modular-type-definition Formal-floating-point-definition Formal-ordinary-fixed-point-definition Formal-decimal-fixed-point-definition Formal-array-type-definition Formal-access-type-definition Formal-interface-type-definition Formal-subprogram-declaration Formal-concrete-subprogram-declaration Formal-abstract-subprogram-declaration Subprogram-default Default-name Formal-package-declaration Formal-package-actual-part Formal-package-association Aspect-clause Local-name Attribute-definition-clause Enumeration-representation-clause Enumeration-aggregate Record-representation-clause Component-clause Position First-bit Last-bit Code-statement Restriction Restriction-parameter-argument Delta-constraint At-clause Mod-clause Non-quotation-mark-graphic-character Non-end-of-line-character Pragma-argument-identifier Subtype-name Static-expression Parent-subtype-indication Static-simple-expression Discrete-subtype-indication Discriminant-selector-name Discriminant-direct-name Interface-subtype-mark Component-selector-name Label-statement-identifier Variable-name Boolean-expression Loop-statement-identifier Loop-identifier Block-statement-identifier Block-identifier Loop-name Label-name Procedure-name Procedure-prefix Function-name Function-prefix Formal-parameter-selector-name Ancestor-subtype-indication Package-name Object-name Exception-name Callable-entity-name Generic-package-name Generic-procedure-name Generic-function-name Task-identifier Protected-identifier Entry-direct-name Entry-identifier Entry-name Delay-expression Task-name Library-unit-name String-expression Generic-formal-parameter-selector-name Subprogram-name Package-instance-name First-subtype-local-name Component-local-name Restriction-identifier Restriction-parameter-identifier 
  context-free syntax
        Identifier-start (Identifier-start | Identifier-extend)* -> Identifier

        Letter-uppercase
		| Letter-lowercase
		| Letter-titlecase
		| Letter-modifier
		| Letter-other
		| Number-letter -> Identifier-start

        Mark-non-spacing
		| Mark-spacing-combining
		| Number-decimal
		| Punctuation-connector
		| Other-format -> Identifier-extend

        Decimal-literal
		| Based-literal -> Numeric-literal

        Numeral ("." Numeral)? Exponent? -> Decimal-literal

        Digit (Underline? Digit)* -> Numeral

        "E" "+"? Numeral
		| "E" "-" Numeral -> Exponent

        "0"
		| "1"
		| "2"
		| "3"
		| "4"
		| "5"
		| "6"
		| "7"
		| "8"
		| "9" -> Digit

        Base "#" Based-numeral ("." Based-numeral)? "#" Exponent? -> Based-literal

        Numeral -> Base

        Extended-digit (Underline? Extended-digit)* -> Based-numeral

        Digit
		| "A"
		| "B"
		| "C"
		| "D"
		| "E"
		| "F" -> Extended-digit

        "'" Graphic-character "'" -> Character-literal

        """ String-element* """ -> String-literal

        """"
		| Non-quotation-mark-graphic-character -> String-element

        "-" "-" Non-end-of-line-character* -> Comment

        "pragma" Identifier ("(" Pragma-argument-association ("," Pragma-argument-association)* ")")? ";" -> Pragma

        (Pragma-argument-identifier "=>")? Name
		| (Pragma-argument-identifier "=>")? Expression -> Pragma-argument-association

        Type-declaration
		| Object-declaration
		| Subprogram-declaration
		| Null-procedure-declaration
		| Renaming-declaration
		| Generic-declaration
		| Subtype-declaration
		| Number-declaration
		| Abstract-subprogram-declaration
		| Package-declaration
		| Exception-declaration
		| Generic-instantiation -> Basic-declaration

        Identifier -> Defining-identifier

        Full-type-declaration
		| Incomplete-type-declaration
		| Private-type-declaration
		| Private-extension-declaration -> Type-declaration

        "type" Defining-identifier Known-discriminant-part? "is" Type-definition ";"
		| Task-type-declaration
		| Protected-type-declaration -> Full-type-declaration

        Enumeration-type-definition
		| Real-type-definition
		| Record-type-definition
		| Derived-type-definition
		| Integer-type-definition
		| Array-type-definition
		| Access-type-definition
		| Interface-type-definition -> Type-definition

        "subtype" Defining-identifier "is" Subtype-indication ";" -> Subtype-declaration

        Null-exclusion? Subtype-mark Constraint? -> Subtype-indication

        Subtype-name -> Subtype-mark

        Scalar-constraint
		| Composite-constraint -> Constraint

        Range-constraint
		| Digits-constraint
		| Delta-constraint -> Scalar-constraint

        Index-constraint
		| Discriminant-constraint -> Composite-constraint

        Defining-identifier-list ":" "aliased"? "constant"? Subtype-indication (":=" Expression)? ";"
		| Defining-identifier-list ":" "aliased"? "constant"? Access-definition (":=" Expression)? ";"
		| Defining-identifier-list ":" "aliased"? "constant"? Array-type-definition (":=" Expression)? ";"
		| Single-task-declaration
		| Single-protected-declaration -> Object-declaration

        Defining-identifier ("," Defining-identifier)* -> Defining-identifier-list

        Defining-identifier-list ":" "constant" ":=" Static-expression ";" -> Number-declaration

        "abstract"? "limited"? "new" Parent-subtype-indication (("and" Interface-list)? Record-extension-part)? -> Derived-type-definition

        "range" Range -> Range-constraint

        Range-attribute-reference
		| Simple-expression ".." Simple-expression -> Range

        "(" Enumeration-literal-specification ("," Enumeration-literal-specification)* ")" -> Enumeration-type-definition

        Defining-identifier
		| Defining-character-literal -> Enumeration-literal-specification

        Character-literal -> Defining-character-literal

        Signed-integer-type-definition
		| Modular-type-definition -> Integer-type-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Signed-integer-type-definition

        "mod" Static-expression -> Modular-type-definition

        Floating-point-definition
		| Fixed-point-definition -> Real-type-definition

        "digits" Static-expression Real-range-specification? -> Floating-point-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Real-range-specification

        Ordinary-fixed-point-definition
		| Decimal-fixed-point-definition -> Fixed-point-definition

        "delta" Static-expression Real-range-specification -> Ordinary-fixed-point-definition

        "delta" Static-expression "digits" Static-expression Real-range-specification? -> Decimal-fixed-point-definition

        "digits" Static-expression Range-constraint? -> Digits-constraint

        Unconstrained-array-definition
		| Constrained-array-definition -> Array-type-definition

        "array" "(" Index-subtype-definition ("," Index-subtype-definition)* ")" "of" Component-definition -> Unconstrained-array-definition

        Subtype-mark "range" "<>" -> Index-subtype-definition

        "array" "(" Discrete-subtype-definition ("," Discrete-subtype-definition)* ")" "of" Component-definition -> Constrained-array-definition

        Discrete-subtype-indication
		| Range -> Discrete-subtype-definition

        "aliased"? Subtype-indication
		| "aliased"? Access-definition -> Component-definition

        "(" Discrete-range ("," Discrete-range)* ")" -> Index-constraint

        Discrete-subtype-indication
		| Range -> Discrete-range

        Unknown-discriminant-part
		| Known-discriminant-part -> Discriminant-part

        "(<>)" -> Unknown-discriminant-part

        "(" Discriminant-specification (";" Discriminant-specification)* ")" -> Known-discriminant-part

        Defining-identifier-list ":" Null-exclusion? Subtype-mark (":=" Default-expression)?
		| Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Discriminant-specification

        Expression -> Default-expression

        "(" Discriminant-association ("," Discriminant-association)* ")" -> Discriminant-constraint

        (Discriminant-selector-name ("|" Discriminant-selector-name)* "=>")? Expression -> Discriminant-association

        ("abstract"? "tagged")? "limited"? Record-definition -> Record-type-definition

        "record" Component-list "end" "record"
		| "null" "record" -> Record-definition

        Component-item Component-item*
		| Component-item* Variant-part
		| "null" ";" -> Component-list

        Component-declaration
		| Aspect-clause -> Component-item

        Defining-identifier-list ":" Component-definition (":=" Default-expression)? ";" -> Component-declaration

        "case" Discriminant-direct-name "is" Variant+ "end" "case" ";" -> Variant-part

        "when" Discrete-choice-list "=>" Component-list -> Variant

        Discrete-choice ("|" Discrete-choice)* -> Discrete-choice-list

        Expression
		| Discrete-range
		| "others" -> Discrete-choice

        "with" Record-definition -> Record-extension-part

        Overriding-indicator? Subprogram-specification "is" "abstract" ";" -> Abstract-subprogram-declaration

        ("limited" | "task" | "protected" | "synchronized")? "interface" ("and" Interface-list)? -> Interface-type-definition

        Interface-subtype-mark ("and" Interface-subtype-mark)* -> Interface-list

        Null-exclusion? Access-to-object-definition
		| Null-exclusion? Access-to-subprogram-definition -> Access-type-definition

        "access" General-access-modifier? Subtype-indication -> Access-to-object-definition

        "all"
		| "constant" -> General-access-modifier

        "access" "protected"? "procedure" Parameter-profile
		| "access" "protected"? "function" Parameter-and-result-profile -> Access-to-subprogram-definition

        "not" "null" -> Null-exclusion

        Null-exclusion? "access" "constant"? Subtype-mark
		| Null-exclusion? "access" "protected"? "procedure" Parameter-profile
		| Null-exclusion? "access" "protected"? "function" Parameter-and-result-profile -> Access-definition

        "type" Defining-identifier Discriminant-part? ("is" "tagged")? ";" -> Incomplete-type-declaration

        Declarative-item* -> Declarative-part

        Basic-declarative-item
		| Body -> Declarative-item

        Basic-declaration
		| Aspect-clause
		| Use-clause -> Basic-declarative-item

        Proper-body
		| Body-stub -> Body

        Subprogram-body
		| Package-body
		| Task-body
		| Protected-body -> Proper-body

        Direct-name
		| Indexed-component
		| Selected-component
		| Type-conversion
		| Character-literal
		| Explicit-dereference
		| Slice
		| Attribute-reference
		| Function-call -> Name

        Identifier
		| Operator-symbol -> Direct-name

        Name
		| Implicit-dereference -> Prefix

        Name "." "all" -> Explicit-dereference

        Name -> Implicit-dereference

        Prefix "(" Expression ("," Expression)* ")" -> Indexed-component

        Prefix "(" Discrete-range ")" -> Slice

        Prefix "." Selector-name -> Selected-component

        Identifier
		| Character-literal
		| Operator-symbol -> Selector-name

        Prefix "'" Attribute-designator -> Attribute-reference

        Identifier ("(" Static-expression ")")?
		| "Access"
		| "Delta"
		| "Digits" -> Attribute-designator

        Prefix "'" Range-attribute-designator -> Range-attribute-reference

        "Range" ("(" Static-expression ")")? -> Range-attribute-designator

        Record-aggregate
		| Extension-aggregate
		| Array-aggregate -> Aggregate

        "(" Record-component-association-list ")" -> Record-aggregate

        Record-component-association ("," Record-component-association)*
		| "null" "record" -> Record-component-association-list

        (Component-choice-list "=>")? Expression
		| Component-choice-list "=><>" -> Record-component-association

        Component-selector-name ("|" Component-selector-name)*
		| "others" -> Component-choice-list

        "(" Ancestor-part "with" Record-component-association-list ")" -> Extension-aggregate

        Expression
		| Subtype-mark -> Ancestor-part

        Positional-array-aggregate
		| Named-array-aggregate -> Array-aggregate

        "(" Expression "," Expression ("," Expression)* ")"
		| "(" Expression ("," Expression)* "," "others" "=>" Expression ")"
		| "(" Expression ("," Expression)* "," "others" "=><>)" -> Positional-array-aggregate

        "(" Array-component-association ("," Array-component-association)* ")" -> Named-array-aggregate

        Discrete-choice-list "=>" Expression
		| Discrete-choice-list "=><>" -> Array-component-association

        Relation ("and" Relation)*
		| Relation ("or" Relation)*
		| Relation ("xor" Relation)*
		| Relation ("and" "then" Relation)*
		| Relation ("or" "else" Relation)* -> Expression

        Simple-expression (Relational-operator Simple-expression)?
		| Simple-expression "not"? "in" Range
		| Simple-expression "not"? "in" Subtype-mark -> Relation

        Unary-adding-operator? Term (Binary-adding-operator Term)* -> Simple-expression

        Factor (Multiplying-operator Factor)* -> Term

        Primary ("**" Primary)?
		| "abs" Primary
		| "not" Primary -> Factor

        Numeric-literal
		| "null"
		| String-literal
		| Aggregate
		| Name
		| Qualified-expression
		| Allocator
		| "(" Expression ")" -> Primary

        "and"
		| "or"
		| "xor" -> Logical-operator

        "="
		| "/="
		| "<"
		| "<="
		| ">"
		| ">=" -> Relational-operator

        "+"
		| "-"
		| "&" -> Binary-adding-operator

        "+"
		| "-" -> Unary-adding-operator

        "*"
		| "/"
		| "mod"
		| "rem" -> Multiplying-operator

        "**"
		| "abs"
		| "not" -> Highest-precedence-operator

        Subtype-mark "(" Expression ")"
		| Subtype-mark "(" Name ")" -> Type-conversion

        Subtype-mark "'(" Expression ")"
		| Subtype-mark "'" Aggregate -> Qualified-expression

        "new" Subtype-indication
		| "new" Qualified-expression -> Allocator

        Statement Statement* -> Sequence-of-statements

        Label* Simple-statement
		| Label* Compound-statement -> Statement

        Null-statement
		| Assignment-statement
		| Goto-statement
		| Simple-return-statement
		| Requeue-statement
		| Abort-statement
		| Code-statement
		| Exit-statement
		| Procedure-call-statement
		| Entry-call-statement
		| Delay-statement
		| Raise-statement -> Simple-statement

        If-statement
		| Loop-statement
		| Extended-return-statement
		| Accept-statement
		| Case-statement
		| Block-statement
		| Select-statement -> Compound-statement

        "null" ";" -> Null-statement

        "<<" Label-statement-identifier ">>" -> Label

        Direct-name -> Statement-identifier

        Variable-name ":=" Expression ";" -> Assignment-statement

        "if" Condition "then" Sequence-of-statements ("elsif" Condition "then" Sequence-of-statements)* ("else" Sequence-of-statements)? "end" "if" ";" -> If-statement

        Boolean-expression -> Condition

        "case" Expression "is" Case-statement-alternative Case-statement-alternative* "end" "case" ";" -> Case-statement

        "when" Discrete-choice-list "=>" Sequence-of-statements -> Case-statement-alternative

        (Loop-statement-identifier ":")? Iteration-scheme? "loop" Sequence-of-statements "end" "loop" Loop-identifier? ";" -> Loop-statement

        "while" Condition
		| "for" Loop-parameter-specification -> Iteration-scheme

        Defining-identifier "in" "reverse"? Discrete-subtype-definition -> Loop-parameter-specification

        (Block-statement-identifier ":")? ("declare" Declarative-part)? "begin" Handled-sequence-of-statements "end" Block-identifier? ";" -> Block-statement

        "exit" Loop-name? ("when" Condition)? ";" -> Exit-statement

        "goto" Label-name ";" -> Goto-statement

        Overriding-indicator? Subprogram-specification ";" -> Subprogram-declaration

        Procedure-specification
		| Function-specification -> Subprogram-specification

        "procedure" Defining-program-unit-name Parameter-profile -> Procedure-specification

        "function" Defining-designator Parameter-and-result-profile -> Function-specification

        (Parent-unit-name ".")? Identifier
		| Operator-symbol -> Designator

        Defining-program-unit-name
		| Defining-operator-symbol -> Defining-designator

        (Parent-unit-name ".")? Defining-identifier -> Defining-program-unit-name

        String-literal -> Operator-symbol

        Operator-symbol -> Defining-operator-symbol

        Formal-part? -> Parameter-profile

        Formal-part? "return" Null-exclusion? Subtype-mark
		| Formal-part? "return" Access-definition -> Parameter-and-result-profile

        "(" Parameter-specification (";" Parameter-specification)* ")" -> Formal-part

        Defining-identifier-list ":" Mode Null-exclusion? Subtype-mark (":=" Default-expression)?
		| Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Parameter-specification

        "in"?
		| "in" "out"
		| "out" -> Mode

        Overriding-indicator? Subprogram-specification "is" Declarative-part "begin" Handled-sequence-of-statements "end" Designator? ";" -> Subprogram-body

        Procedure-name ";"
		| Procedure-prefix Actual-parameter-part ";" -> Procedure-call-statement

        Function-name
		| Function-prefix Actual-parameter-part -> Function-call

        "(" Parameter-association ("," Parameter-association)* ")" -> Actual-parameter-part

        (Formal-parameter-selector-name "=>")? Explicit-actual-parameter -> Parameter-association

        Expression
		| Variable-name -> Explicit-actual-parameter

        "return" Expression? ";" -> Simple-return-statement

        "return" Defining-identifier ":" "aliased"? Return-subtype-indication (":=" Expression)? ("do" Handled-sequence-of-statements "end" "return")? ";" -> Extended-return-statement

        Subtype-indication
		| Access-definition -> Return-subtype-indication

        Overriding-indicator? Procedure-specification "is" "null" ";" -> Null-procedure-declaration

        Package-specification ";" -> Package-declaration

        "package" Defining-program-unit-name "is" Basic-declarative-item* ("private" Basic-declarative-item*)? "end" ((Parent-unit-name ".")? Identifier)? -> Package-specification

        "package" "body" Defining-program-unit-name "is" Declarative-part ("begin" Handled-sequence-of-statements)? "end" ((Parent-unit-name ".")? Identifier)? ";" -> Package-body

        "type" Defining-identifier Discriminant-part? "is" ("abstract"? "tagged")? "limited"? "private" ";" -> Private-type-declaration

        "type" Defining-identifier Discriminant-part? "is" "abstract"? ("limited" | "synchronized")? "new" Ancestor-subtype-indication ("and" Interface-list)? "with" "private" ";" -> Private-extension-declaration

        "not"? "overriding" -> Overriding-indicator

        Use-package-clause
		| Use-type-clause -> Use-clause

        "use" Package-name ("," Package-name)* ";" -> Use-package-clause

        "use" "type" Subtype-mark ("," Subtype-mark)* ";" -> Use-type-clause

        Object-renaming-declaration
		| Exception-renaming-declaration
		| Package-renaming-declaration
		| Subprogram-renaming-declaration
		| Generic-renaming-declaration -> Renaming-declaration

        Defining-identifier ":" Null-exclusion? Subtype-mark "renames" Object-name ";"
		| Defining-identifier ":" Access-definition "renames" Object-name ";" -> Object-renaming-declaration

        Defining-identifier ":" "exception" "renames" Exception-name ";" -> Exception-renaming-declaration

        "package" Defining-program-unit-name "renames" Package-name ";" -> Package-renaming-declaration

        Overriding-indicator? Subprogram-specification "renames" Callable-entity-name ";" -> Subprogram-renaming-declaration

        "generic" "package" Defining-program-unit-name "renames" Generic-package-name ";"
		| "generic" "procedure" Defining-program-unit-name "renames" Generic-procedure-name ";"
		| "generic" "function" Defining-program-unit-name "renames" Generic-function-name ";" -> Generic-renaming-declaration

        "task" "type" Defining-identifier Known-discriminant-part? ("is" ("new" Interface-list "with")? Task-definition)? ";" -> Task-type-declaration

        "task" Defining-identifier ("is" ("new" Interface-list "with")? Task-definition)? ";" -> Single-task-declaration

        Task-item* ("private" Task-item*)? "end" Task-identifier? -> Task-definition

        Entry-declaration
		| Aspect-clause -> Task-item

        "task" "body" Defining-identifier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Task-identifier? ";" -> Task-body

        "protected" "type" Defining-identifier Known-discriminant-part? "is" ("new" Interface-list "with")? Protected-definition ";" -> Protected-type-declaration

        "protected" Defining-identifier "is" ("new" Interface-list "with")? Protected-definition ";" -> Single-protected-declaration

        Protected-operation-declaration* ("private" Protected-element-declaration*)? "end" Protected-identifier? -> Protected-definition

        Subprogram-declaration
		| Entry-declaration
		| Aspect-clause -> Protected-operation-declaration

        Protected-operation-declaration
		| Component-declaration -> Protected-element-declaration

        "protected" "body" Defining-identifier "is" Protected-operation-item* "end" Protected-identifier? ";" -> Protected-body

        Subprogram-declaration
		| Subprogram-body
		| Entry-body
		| Aspect-clause -> Protected-operation-item

        Overriding-indicator? "entry" Defining-identifier ("(" Discrete-subtype-definition ")")? Parameter-profile ";" -> Entry-declaration

        "accept" Entry-direct-name ("(" Entry-index ")")? Parameter-profile ("do" Handled-sequence-of-statements "end" Entry-identifier?)? ";" -> Accept-statement

        Expression -> Entry-index

        "entry" Defining-identifier Entry-body-formal-part Entry-barrier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Entry-identifier? ";" -> Entry-body

        ("(" Entry-index-specification ")")? Parameter-profile -> Entry-body-formal-part

        "when" Condition -> Entry-barrier

        "for" Defining-identifier "in" Discrete-subtype-definition -> Entry-index-specification

        Entry-name Actual-parameter-part? ";" -> Entry-call-statement

        "requeue" Entry-name ("with" "abort")? ";" -> Requeue-statement

        Delay-until-statement
		| Delay-relative-statement -> Delay-statement

        "delay" "until" Delay-expression ";" -> Delay-until-statement

        "delay" Delay-expression ";" -> Delay-relative-statement

        Selective-accept
		| Timed-entry-call
		| Conditional-entry-call
		| Asynchronous-select -> Select-statement

        "select" Guard? Select-alternative ("or" Guard? Select-alternative)* ("else" Sequence-of-statements)? "end" "select" ";" -> Selective-accept

        "when" Condition "=>" -> Guard

        Accept-alternative
		| Delay-alternative
		| Terminate-alternative -> Select-alternative

        Accept-statement Sequence-of-statements? -> Accept-alternative

        Delay-statement Sequence-of-statements? -> Delay-alternative

        "terminate" ";" -> Terminate-alternative

        "select" Entry-call-alternative "or" Delay-alternative "end" "select" ";" -> Timed-entry-call

        Procedure-or-entry-call Sequence-of-statements? -> Entry-call-alternative

        Procedure-call-statement
		| Entry-call-statement -> Procedure-or-entry-call

        "select" Entry-call-alternative "else" Sequence-of-statements "end" "select" ";" -> Conditional-entry-call

        "select" Triggering-alternative "then" "abort" Abortable-part "end" "select" ";" -> Asynchronous-select

        Triggering-statement Sequence-of-statements? -> Triggering-alternative

        Procedure-or-entry-call
		| Delay-statement -> Triggering-statement

        Sequence-of-statements -> Abortable-part

        "abort" Task-name ("," Task-name)* ";" -> Abort-statement

        Compilation-unit* -> Compilation

        Context-clause Library-item
		| Context-clause Subunit -> Compilation-unit

        "private"? Library-unit-declaration
		| Library-unit-body
		| "private"? Library-unit-renaming-declaration -> Library-item

        Subprogram-declaration
		| Package-declaration
		| Generic-declaration
		| Generic-instantiation -> Library-unit-declaration

        Package-renaming-declaration
		| Generic-renaming-declaration
		| Subprogram-renaming-declaration -> Library-unit-renaming-declaration

        Subprogram-body
		| Package-body -> Library-unit-body

        Name -> Parent-unit-name

        Context-item* -> Context-clause

        With-clause
		| Use-clause -> Context-item

        Limited-with-clause
		| Nonlimited-with-clause -> With-clause

        "limited" "private"? "with" Library-unit-name ("," Library-unit-name)* ";" -> Limited-with-clause

        "private"? "with" Library-unit-name ("," Library-unit-name)* ";" -> Nonlimited-with-clause

        Subprogram-body-stub
		| Package-body-stub
		| Task-body-stub
		| Protected-body-stub -> Body-stub

        Overriding-indicator? Subprogram-specification "is" "separate" ";" -> Subprogram-body-stub

        "package" "body" Defining-identifier "is" "separate" ";" -> Package-body-stub

        "task" "body" Defining-identifier "is" "separate" ";" -> Task-body-stub

        "protected" "body" Defining-identifier "is" "separate" ";" -> Protected-body-stub

        "separate" "(" Parent-unit-name ")" Proper-body -> Subunit

        Defining-identifier-list ":" "exception" ";" -> Exception-declaration

        Sequence-of-statements ("exception" Exception-handler Exception-handler*)? -> Handled-sequence-of-statements

        "when" (Choice-parameter-specification ":")? Exception-choice ("|" Exception-choice)* "=>" Sequence-of-statements -> Exception-handler

        Defining-identifier -> Choice-parameter-specification

        Exception-name
		| "others" -> Exception-choice

        "raise" ";"
		| "raise" Exception-name ("with" String-expression)? ";" -> Raise-statement

        Generic-subprogram-declaration
		| Generic-package-declaration -> Generic-declaration

        Generic-formal-part Subprogram-specification ";" -> Generic-subprogram-declaration

        Generic-formal-part Package-specification ";" -> Generic-package-declaration

        "generic" (Generic-formal-parameter-declaration | Use-clause)* -> Generic-formal-part

        Formal-object-declaration
		| Formal-type-declaration
		| Formal-subprogram-declaration
		| Formal-package-declaration -> Generic-formal-parameter-declaration

        "package" Defining-program-unit-name "is" "new" Generic-package-name Generic-actual-part? ";"
		| Overriding-indicator? "procedure" Defining-program-unit-name "is" "new" Generic-procedure-name Generic-actual-part? ";"
		| Overriding-indicator? "function" Defining-designator "is" "new" Generic-function-name Generic-actual-part? ";" -> Generic-instantiation

        "(" Generic-association ("," Generic-association)* ")" -> Generic-actual-part

        (Generic-formal-parameter-selector-name "=>")? Explicit-generic-actual-parameter -> Generic-association

        Expression
		| Variable-name
		| Subprogram-name
		| Entry-name
		| Subtype-mark
		| Package-instance-name -> Explicit-generic-actual-parameter

        Defining-identifier-list ":" Mode Null-exclusion? Subtype-mark (":=" Default-expression)? ";" Defining-identifier-list ":" Mode Access-definition (":=" Default-expression)? ";" -> Formal-object-declaration

        "type" Defining-identifier Discriminant-part? "is" Formal-type-definition ";" -> Formal-type-declaration

        Formal-private-type-definition
		| Formal-derived-type-definition
		| Formal-discrete-type-definition
		| Formal-signed-integer-type-definition
		| Formal-modular-type-definition
		| Formal-floating-point-definition
		| Formal-ordinary-fixed-point-definition
		| Formal-decimal-fixed-point-definition
		| Formal-array-type-definition
		| Formal-access-type-definition
		| Formal-interface-type-definition -> Formal-type-definition

        ("abstract"? "tagged")? "limited"? "private" -> Formal-private-type-definition

        "abstract"? ("limited" | "synchronized")? "new" Subtype-mark (("and" Interface-list)? "with" "private")? -> Formal-derived-type-definition

        "(<>)" -> Formal-discrete-type-definition

        "range" "<>" -> Formal-signed-integer-type-definition

        "mod" "<>" -> Formal-modular-type-definition

        "digits" "<>" -> Formal-floating-point-definition

        "delta" "<>" -> Formal-ordinary-fixed-point-definition

        "delta" "<>" "digits" "<>" -> Formal-decimal-fixed-point-definition

        Array-type-definition -> Formal-array-type-definition

        Access-type-definition -> Formal-access-type-definition

        Interface-type-definition -> Formal-interface-type-definition

        Formal-concrete-subprogram-declaration
		| Formal-abstract-subprogram-declaration -> Formal-subprogram-declaration

        "with" Subprogram-specification ("is" Subprogram-default)? ";" -> Formal-concrete-subprogram-declaration

        "with" Subprogram-specification "is" "abstract" Subprogram-default? ";" -> Formal-abstract-subprogram-declaration

        Default-name
		| "<>"
		| "null" -> Subprogram-default

        Name -> Default-name

        "with" "package" Defining-identifier "is" "new" Generic-package-name Formal-package-actual-part ";" -> Formal-package-declaration

        "(" ("others" "=>")? "<>)"
		| Generic-actual-part?
		| "(" Formal-package-association ("," Formal-package-association)* ("," "others" "=><>")? ")" -> Formal-package-actual-part

        Generic-association
		| Generic-formal-parameter-selector-name "=><>" -> Formal-package-association

        Attribute-definition-clause
		| Enumeration-representation-clause
		| Record-representation-clause
		| At-clause -> Aspect-clause

        Direct-name
		| Direct-name "'" Attribute-designator
		| Library-unit-name -> Local-name

        "for" Local-name "'" Attribute-designator "use" Expression ";"
		| "for" Local-name "'" Attribute-designator "use" Name ";" -> Attribute-definition-clause

        "for" First-subtype-local-name "use" Enumeration-aggregate ";" -> Enumeration-representation-clause

        Array-aggregate -> Enumeration-aggregate

        "for" First-subtype-local-name "use" "record" Mod-clause? Component-clause* "end" "record" ";" -> Record-representation-clause

        Component-local-name "at" Position "range" First-bit ".." Last-bit ";" -> Component-clause

        Static-expression -> Position

        Static-simple-expression -> First-bit

        Static-simple-expression -> Last-bit

        Qualified-expression ";" -> Code-statement

        Restriction-identifier
		| Restriction-parameter-identifier "=>" Restriction-parameter-argument -> Restriction

        Name
		| Expression -> Restriction-parameter-argument

        "delta" Static-expression Range-constraint? -> Delta-constraint

        "for" Direct-name "use" "at" Expression ";" -> At-clause

        "at" "mod" Static-expression ";" -> Mod-clause

        Graphic-character -> Non-quotation-mark-graphic-character

        "character" -> Non-end-of-line-character

        Identifier -> Pragma-argument-identifier

        Name -> Subtype-name

        Expression -> Static-expression

        Subtype-indication -> Parent-subtype-indication

        Simple-expression -> Static-simple-expression

        Subtype-indication -> Discrete-subtype-indication

        Selector-name -> Discriminant-selector-name

        Direct-name -> Discriminant-direct-name

        Subtype-mark -> Interface-subtype-mark

        Selector-name -> Component-selector-name

        Statement-identifier -> Label-statement-identifier

        Name -> Variable-name

        Expression -> Boolean-expression

        Statement-identifier -> Loop-statement-identifier

        Identifier -> Loop-identifier

        Statement-identifier -> Block-statement-identifier

        Identifier -> Block-identifier

        Name -> Loop-name

        Name -> Label-name

        Name -> Procedure-name

        Prefix -> Procedure-prefix

        Name -> Function-name

        Prefix -> Function-prefix

        Selector-name -> Formal-parameter-selector-name

        Subtype-indication -> Ancestor-subtype-indication

        Name -> Package-name

        Name -> Object-name

        Name -> Exception-name

        Name -> Callable-entity-name

        Name -> Generic-package-name

        Name -> Generic-procedure-name

        Name -> Generic-function-name

        Identifier -> Task-identifier

        Identifier -> Protected-identifier

        Direct-name -> Entry-direct-name

        Identifier -> Entry-identifier

        Name -> Entry-name

        Expression -> Delay-expression

        Name -> Task-name

        Name -> Library-unit-name

        Expression -> String-expression

        Selector-name -> Generic-formal-parameter-selector-name

        Name -> Subprogram-name

        Name -> Package-instance-name

        Local-name -> First-subtype-local-name

        Local-name -> Component-local-name

        Identifier -> Restriction-identifier

        Identifier -> Restriction-parameter-identifier
