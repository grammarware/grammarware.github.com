variableDeclaration = declaredIdentifier (',' IDENTIFIER)* ;
initializedVariableDeclaration = declaredIdentifier ('=' expression)? (',' initializedIdentifier)* ;
initializedIdentifierList = initializedIdentifier (',' initializedIdentifier)* ;
initializedIdentifier = IDENTIFIER ('=' expression)? ;
declaredIdentifier = finalVarOrType IDENTIFIER ;
finalVarOrType = 'final' type? ;
finalVarOrType = 'var' ;
finalVarOrType = type ;
functionSignature = returnType? IDENTIFIER formalParameterList ;
functionPrefix = returnType? IDENTIFIER ;
functionBody = '=>' expression ';' ;
functionBody = block ;
block = '{' statements '}' ;
formalParameterList = '(' ')' ;
formalParameterList = '(' normalFormalParameters (',' namedFormalParameters)? ')' ;
formalParameterList = namedFormalParameters ;
normalFormalParameters = normalFormalParameter (',' normalFormalParameter)* ;
namedFormalParameters = '[' defaultFormalParameter (',' defaultFormalParameter)* ']' ;
normalFormalParameter = functionSignature ;
normalFormalParameter = fieldFormalParameter ;
normalFormalParameter = simpleFormalParameter ;
simpleFormalParameter = declaredIdentifier ;
simpleFormalParameter = IDENTIFIER ;
fieldFormalParameter = finalVarOrType? 'this' '.' IDENTIFIER ;
defaultFormalParameter = normalFormalParameter ('=' expression)? ;
classDefinition = 'class' IDENTIFIER typeParameters? superclass? interfaces? '{' classMemberDefinition* '}' ;
classMemberDefinition = declaration ';' ;
classMemberDefinition = methodSignature functionBody ;
methodSignature = factoryConstructorSignature ;
methodSignature = 'static' functionSignature ;
methodSignature = getterSignature ;
methodSignature = setterSignature ;
methodSignature = operatorSignature ;
methodSignature = functionSignature initializers? ;
methodSignature = namedConstructorSignature initializers? ;
declaration = constantConstructorSignature (redirection | initializers)? ;
declaration = constructorSignature (redirection | initializers)? ;
declaration = functionSignature redirection ;
declaration = namedConstructorSignature redirection ;
declaration = 'abstract' getterSignature ;
declaration = 'abstract' setterSignature ;
declaration = 'abstract' operatorSignature ;
declaration = 'abstract' functionSignature ;
declaration = 'static' 'final' type? staticFinalDeclarationList ;
declaration = 'static'? initializedVariableDeclaration ;
staticFinalDeclarationList = staticFinalDeclaration (',' staticFinalDeclaration)* ;
staticFinalDeclaration = IDENTIFIER '=' expression ;
operatorSignature = returnType? 'operator' operator formalParameterList ;
operator = unaryOperator ;
operator = binaryOperator ;
operator = '[]' ;
operator = '[]=' ;
operator = 'negate' ;
unaryOperator = negateOperator ;
binaryOperator = multiplicativeOperator ;
binaryOperator = additiveOperator ;
binaryOperator = shiftOperator ;
binaryOperator = relationalOperator ;
binaryOperator = equalityOperator ;
binaryOperator = bitwiseOperator ;
prefixOperator = additiveOperator ;
prefixOperator = negateOperator ;
negateOperator = '!' ;
negateOperator = '~' ;
getterSignature = 'static'? returnType? 'get' IDENTIFIER formalParameterList ;
setterSignature = 'static'? returnType? 'set' IDENTIFIER formalParameterList ;
constructorSignature = IDENTIFIER formalParameterList ;
constructorSignature = namedConstructorSignature ;
namedConstructorSignature = IDENTIFIER '.' IDENTIFIER formalParameterList ;
redirection = ':' 'this' ('.' IDENTIFIER)? arguments ;
initializers = ':' superCallOrFieldInitializer (',' superCallOrFieldInitializer)* ;
superCallOrFieldInitializer = 'super' arguments ;
superCallOrFieldInitializer = 'super' '.' IDENTIFIER arguments ;
superCallOrFieldInitializer = fieldInitializer ;
fieldInitializer = ('this' '.')? IDENTIFIER '=' conditionalExpression ;
factoryConstructorSignature = 'factory' qualified typeVariables? ('.' IDENTIFIER)? formalParameterList ;
constantConstructorSignature = 'const' qualified formalParameterList ;
superclass = 'extends' type ;
interfaces = 'implements' typeList ;
interfaceDefinition = 'interface' IDENTIFIER typeParameters? superinterfaces? factorySpecification? '{' interfaceMemberDefinition* '}' ;
interfaceMemberDefinition = 'static' 'final' type? initializedIdentifierList ';' ;
interfaceMemberDefinition = functionSignature ';' ;
interfaceMemberDefinition = constantConstructorSignature ';' ;
interfaceMemberDefinition = namedConstructorSignature ';' ;
interfaceMemberDefinition = getterSignature ';' ;
interfaceMemberDefinition = setterSignature ';' ;
interfaceMemberDefinition = operatorSignature ';' ;
interfaceMemberDefinition = variableDeclaration ';' ;
factorySpecification = 'factory' IDENTIFIER typeParameters? ;
superinterfaces = 'extends' typeList ;
typeParameter = IDENTIFIER ('extends' type)? ;
typeParameters = '<' typeParameter (',' typeParameter)* '>' ;
expression = assignableExpression assignmentOperator expression ;
expression = conditionalExpression ;
expressionList = expression (',' expression)* ;
primary = thisExpression ;
primary = 'super' assignableSelector ;
primary = functionExpression ;
primary = literal ;
primary = IDENTIFIER ;
primary = newExpression constantObjectExpression ;
primary = '(' expression ')' ;
literal = nullLiteral ;
literal = booleanLiteral ;
literal = numericLiteral ;
literal = stringLiteral ;
literal = mapLiteral ;
literal = listLiteral ;
nullLiteral = 'null' ;
numericLiteral = NUMBER ;
numericLiteral = HEX_NUMBER ;
NUMBER = DIGIT+ ('.' DIGIT*)? EXPONENT? ;
NUMBER = '.' DIGIT+ EXPONENT? ;
EXPONENT = ('e' | 'E') ('+' | '-')? DIGIT+ ;
HEX_NUMBER = '0x' HEX_DIGIT+ ;
HEX_NUMBER = '0X' HEX_DIGIT+ ;
HEX_DIGIT = 'a' ;
HEX_DIGIT = 'b' ;
HEX_DIGIT = 'c' ;
HEX_DIGIT = 'd' ;
HEX_DIGIT = 'e' ;
HEX_DIGIT = 'f' ;
HEX_DIGIT = 'A' ;
HEX_DIGIT = 'B' ;
HEX_DIGIT = 'C' ;
HEX_DIGIT = 'D' ;
HEX_DIGIT = 'E' ;
HEX_DIGIT = 'F' ;
HEX_DIGIT = DIGIT ;
booleanLiteral = 'true' ;
booleanLiteral = 'false' ;
stringLiteral = '@'? MULTI_LINE_STRING ;
stringLiteral = SINGLE_LINE_STRING ;
SINGLE_LINE_STRING = '"' STRING_CONTENT_DQ* '"' ;
SINGLE_LINE_STRING = ''' STRING_CONTENT_SQ* ''' ;
SINGLE_LINE_STRING = '@' ''' ANY* ''' ;
SINGLE_LINE_STRING = '@' '"' ANY* '"' ;
MULTI_LINE_STRING = '"""' ANY* '"""' ;
MULTI_LINE_STRING = ''''' ANY* ''''' ;
ESCAPE_SEQUENCE = '\' 'n' ;
ESCAPE_SEQUENCE = '\' 'r' ;
ESCAPE_SEQUENCE = '\' 'f' ;
ESCAPE_SEQUENCE = '\' 'b' ;
ESCAPE_SEQUENCE = '\' 't' ;
ESCAPE_SEQUENCE = '\' 'v' ;
ESCAPE_SEQUENCE = '\' 'x' HEX_DIGIT HEX_DIGIT ;
ESCAPE_SEQUENCE = '\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;
ESCAPE_SEQUENCE = '\' 'u' ;
HEX_DIGIT_SEQUENCE = HEX_DIGIT HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? ;
STRING_CONTENT_DQ = ANY ;
STRING_CONTENT_DQ = '\' ANY ;
STRING_CONTENT_DQ = STRING_INTERPOLATION ;
STRING_CONTENT_SQ = ANY ;
STRING_CONTENT_SQ = '\' ANY ;
STRING_CONTENT_SQ = STRING_INTERPOLATION ;
NEWLINE = '\n' ;
NEWLINE = '\r' ;
STRING_INTERPOLATION = '$' IDENTIFIER_NO_DOLLAR ;
STRING_INTERPOLATION = '$' '{' expression '}' ;
listLiteral = 'const'? typeArguments? '[' (expressionList ','?)? ']' ;
mapLiteral = 'const'? typeArguments? '{' (mapLiteralEntry (',' mapLiteralEntry)* ','?)? '}' ;
mapLiteralEntry = IDENTIFIER ':' expression ;
mapLiteralEntry = stringLiteral ':' expression ;
functionExpression = (returnType? IDENTIFIER)? formalParameterList functionExpressionBody ;
functionExpressionBody = '=>' expression ;
functionExpressionBody = block ;
thisExpression = 'this' ;
newExpression = 'new' type ('.' IDENTIFIER)? arguments ;
constantObjectExpression = 'const' type ('.' IDENTIFIER)? arguments ;
arguments = '(' argumentList? ')' ;
argumentList = namedArgument (',' namedArgument)* ;
argumentList = expressionList (',' namedArgument)* ;
namedArgument = label expression ;
assignmentOperator = '=' ;
assignmentOperator = compoundAssignmentOperator ;
compoundAssignmentOperator = '*=' ;
compoundAssignmentOperator = '/=' ;
compoundAssignmentOperator = '~/=' ;
compoundAssignmentOperator = '%=' ;
compoundAssignmentOperator = '+=' ;
compoundAssignmentOperator = '-=' ;
compoundAssignmentOperator = '<<=' ;
compoundAssignmentOperator = '>' '>' '>' '='? ;
compoundAssignmentOperator = '<' '<' '='? ;
compoundAssignmentOperator = '&=' ;
compoundAssignmentOperator = '^=' ;
compoundAssignmentOperator = '|=' ;
conditionalExpression = logicalOrExpression ('?' expression ':' expression)? ;
logicalOrExpression = logicalAndExpression ('||' logicalAndExpression)* ;
logicalAndExpression = bitwiseOrExpression ('&&' bitwiseOrExpression)* ;
bitwiseOrExpression = bitwiseXorExpression ('|' bitwiseXorExpression)* ;
bitwiseOrExpression = 'super' ('|' bitwiseXorExpression)+ ;
bitwiseXorExpression = bitwiseAndExpression ('^' bitwiseAndExpression)* ;
bitwiseXorExpression = 'super' ('^' bitwiseAndExpression)+ ;
bitwiseAndExpression = equalityExpression ('&' equalityExpression)* ;
bitwiseAndExpression = 'super' ('&' equalityExpression)+ ;
bitwiseOperator = '&' ;
bitwiseOperator = '^' ;
bitwiseOperator = '|' ;
equalityExpression = relationalExpression (equalityOperator relationalExpression)? ;
equalityExpression = 'super' equalityOperator relationalExpression ;
equalityOperator = '==' ;
equalityOperator = '!=' ;
equalityOperator = '===' ;
equalityOperator = '!==' ;
relationalExpression = shiftExpression ((isOperator type) | (relationalOperator shiftExpression))? ;
relationalExpression = 'super' relationalOperator shiftExpression ;
relationalOperator = '>=' ;
relationalOperator = '>' ;
relationalOperator = '<=' ;
relationalOperator = '<' ;
shiftExpression = additiveExpression (shiftOperator additiveExpression)* ;
shiftExpression = 'super' (shiftOperator additiveExpression)+ ;
shiftOperator = '<<' ;
shiftOperator = '>>>' ;
shiftOperator = '>>' ;
additiveExpression = multiplicativeExpression (additiveOperator multiplicativeExpression)* ;
additiveExpression = 'super' (additiveOperator multiplicativeExpression)+ ;
additiveOperator = '+' ;
additiveOperator = '-' ;
multiplicativeExpression = unaryExpression (multiplicativeOperator unaryExpression)* ;
multiplicativeExpression = 'super' (multiplicativeOperator unaryExpression)+ ;
multiplicativeOperator = '*' ;
multiplicativeOperator = '/' ;
multiplicativeOperator = '%' ;
multiplicativeOperator = '~/' ;
unaryExpression = prefixExpression ;
unaryExpression = postfixExpression ;
unaryExpression = unaryOperator 'super' ;
unaryExpression = '-' 'super' ;
unaryExpression = incrementOperator assignableExpression ;
prefixExpression = prefixOperator unaryExpression ;
postfixExpression = assignableExpression postfixOperator ;
postfixExpression = primary selector* ;
postfixOperator = incrementOperator ;
incrementOperator = '++' ;
incrementOperator = '--' ;
assignableExpression = primary (arguments* assignableSelector)+ ;
assignableExpression = 'super' assignableSelector ;
assignableExpression = IDENTIFIER ;
selector = assignableSelector ;
selector = arguments ;
assignableSelector = '[' expression ']' ;
assignableSelector = '.' IDENTIFIER ;
identifier = IDENTIFIER_NO_DOLLAR ;
identifier = IDENTIFIER ;
identifier = BUILT_IN_IDENTIFIER ;
IDENTIFIER_NO_DOLLAR = IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR* ;
IDENTIFIER = IDENTIFIER_START IDENTIFIER_PART* ;
BUILT_IN_IDENTIFIER = 'abstract' ;
BUILT_IN_IDENTIFIER = 'assert' ;
BUILT_IN_IDENTIFIER = 'class' ;
BUILT_IN_IDENTIFIER = 'extends' ;
BUILT_IN_IDENTIFIER = 'factory' ;
BUILT_IN_IDENTIFIER = 'get' ;
BUILT_IN_IDENTIFIER = 'implements' ;
BUILT_IN_IDENTIFIER = 'import' ;
BUILT_IN_IDENTIFIER = 'interface' ;
BUILT_IN_IDENTIFIER = 'is' ;
BUILT_IN_IDENTIFIER = 'library' ;
BUILT_IN_IDENTIFIER = 'negate' ;
BUILT_IN_IDENTIFIER = 'operator' ;
BUILT_IN_IDENTIFIER = 'set' ;
BUILT_IN_IDENTIFIER = 'source' ;
BUILT_IN_IDENTIFIER = 'static' ;
BUILT_IN_IDENTIFIER = 'typedef' ;
IDENTIFIER_START = IDENTIFIER_START_NO_DOLLAR ;
IDENTIFIER_START = '$' ;
IDENTIFIER_START_NO_DOLLAR = LETTER ;
IDENTIFIER_START_NO_DOLLAR = '_' ;
IDENTIFIER_PART_NO_DOLLAR = IDENTIFIER_START_NO_DOLLAR ;
IDENTIFIER_PART_NO_DOLLAR = DIGIT ;
IDENTIFIER_PART = IDENTIFIER_START ;
IDENTIFIER_PART = DIGIT ;
qualified = IDENTIFIER ('.' IDENTIFIER)? ;
isOperator = 'is' '!'? ;
statements = statement* ;
statement = label* nonLabelledStatement ;
nonLabelledStatement = block ;
nonLabelledStatement = initializedVariableDeclaration ';' ;
nonLabelledStatement = forStatement ;
nonLabelledStatement = whileStatement ;
nonLabelledStatement = doStatement ;
nonLabelledStatement = switchStatement ;
nonLabelledStatement = ifStatement ;
nonLabelledStatement = tryStatement ;
nonLabelledStatement = breakStatement ;
nonLabelledStatement = continueStatement ;
nonLabelledStatement = returnStatement ;
nonLabelledStatement = throwStatement ;
nonLabelledStatement = expressionStatement ;
nonLabelledStatement = assertStatement ;
nonLabelledStatement = functionSignature functionBody ;
expressionStatement = expression? ';' ;
ifStatement = 'if' '(' expression ')' statement ('else' statement)? ;
forStatement = 'for' '(' forLoopParts ')' statement ;
forLoopParts = forInitializerStatement expression? ';' expressionList? ;
forLoopParts = declaredIdentifier 'in' expression ;
forLoopParts = IDENTIFIER 'in' expression ;
forInitializerStatement = initializedVariableDeclaration ';' ;
forInitializerStatement = expression? ';' ;
whileStatement = 'while' '(' expression ')' statement ;
doStatement = 'do' statement 'while' '(' expression ')' ';' ;
switchStatement = 'switch' '(' expression ')' '{' switchCase* defaultCase? '}' ;
switchCase = label? ('case' expression ':')+ statements ;
defaultCase = label? ('case' expression ':')* 'default' ':' statements ;
tryStatement = 'try' block ((catchPart+ finallyPart?) | finallyPart) ;
catchPart = 'catch' '(' declaredIndentifier (',' declaredIndentifier)? ')' block ;
finallyPart = 'finally' block ;
returnStatement = 'return' expression? ';' ;
label = IDENTIFIER ':' ;
breakStatement = 'break' IDENTIFIER? ';' ;
continueStatement = 'continue' IDENTIFIER? ';' ;
throwStatement = 'throw' expression? ';' ;
assertStatement = 'assert' '(' conditionalExpression ')' ';' ;
topLevelDefinition = classDefinition ;
topLevelDefinition = interfaceDefinition ;
topLevelDefinition = functionTypeAlias ;
topLevelDefinition = functionSignature functionBody ;
topLevelDefinition = returnType? getOrSet IDENTIFIER formalParameterList functionBody ;
topLevelDefinition = 'final' type? staticFinalDeclarationList ';' ;
topLevelDefinition = variableDeclaration ';' ;
getOrSet = 'get' ;
getOrSet = 'set' ;
libraryDefinition = scriptTag? libraryName libraryImport* include* resource* topLevelDefinition* ;
scriptTag = '#!' ANY* NEWLINE ;
libraryName = '#' 'library' '(' stringLiteral ')' ';' ;
resource = '#' 'resource' '(' stringLiteral ')' ';' ;
libraryImport = '#' 'import' '(' stringLiteral (',' 'prefix:' stringLiteral)? ')' ';' ;
include = '#' 'source' '(' stringLiteral ')' ';' ;
compilationUnit = topLevelDefinition* EOF ;
scriptDefinition = scriptTag? libraryName? libraryImport* include* resource* topLevelDefinition* ;
type = qualified typeArguments? ;
typeArguments = '<' typeList '>' ;
typeList = type (',' type)* ;
functionTypeAlias = 'typedef' functionPrefix typeParameters? formalParameterList ';' ;
LETTER = 'a' ;
LETTER = 'b' ;
LETTER = 'c' ;
LETTER = 'd' ;
LETTER = 'e' ;
LETTER = 'f' ;
LETTER = 'g' ;
LETTER = 'h' ;
LETTER = 'i' ;
LETTER = 'j' ;
LETTER = 'k' ;
LETTER = 'l' ;
LETTER = 'm' ;
LETTER = 'n' ;
LETTER = 'o' ;
LETTER = 'p' ;
LETTER = 'q' ;
LETTER = 'r' ;
LETTER = 's' ;
LETTER = 't' ;
LETTER = 'u' ;
LETTER = 'v' ;
LETTER = 'w' ;
LETTER = 'x' ;
LETTER = 'y' ;
LETTER = 'z' ;
LETTER = 'A' ;
LETTER = 'B' ;
LETTER = 'C' ;
LETTER = 'D' ;
LETTER = 'E' ;
LETTER = 'F' ;
LETTER = 'G' ;
LETTER = 'H' ;
LETTER = 'I' ;
LETTER = 'J' ;
LETTER = 'K' ;
LETTER = 'L' ;
LETTER = 'M' ;
LETTER = 'N' ;
LETTER = 'O' ;
LETTER = 'P' ;
LETTER = 'Q' ;
LETTER = 'R' ;
LETTER = 'S' ;
LETTER = 'T' ;
LETTER = 'U' ;
LETTER = 'V' ;
LETTER = 'W' ;
LETTER = 'X' ;
LETTER = 'Y' ;
LETTER = 'Z' ;
DIGIT = '0' ;
DIGIT = '1' ;
DIGIT = '2' ;
DIGIT = '3' ;
DIGIT = '4' ;
DIGIT = '5' ;
DIGIT = '6' ;
DIGIT = '7' ;
DIGIT = '8' ;
DIGIT = '9' ;
WHITESPACE = ('\t' | ' ' | NEWLINE)+ ;
SINGLE_LINE_COMMENT = '//' ANY* NEWLINE? ;
MULTI_LINE_COMMENT = '/*' ANY* ;
returnType = 'void' ;
returnType = type ;
