module Main

exports
  sorts
        VariableDeclaration InitializedVariableDeclaration InitializedIdentifierList InitializedIdentifier DeclaredIdentifier FinalVarOrType FunctionSignature FunctionPrefix FunctionBody Block FormalParameterList NormalFormalParameters NamedFormalParameters NormalFormalParameter SimpleFormalParameter FieldFormalParameter DefaultFormalParameter ClassDefinition ClassMemberDefinition MethodSignature Declaration StaticFinalDeclarationList StaticFinalDeclaration OperatorSignature Operator UnaryOperator BinaryOperator PrefixOperator NegateOperator GetterSignature SetterSignature ConstructorSignature NamedConstructorSignature Redirection Initializers SuperCallOrFieldInitializer FieldInitializer FactoryConstructorSignature ConstantConstructorSignature Superclass Interfaces InterfaceDefinition InterfaceMemberDefinition FactorySpecification Superinterfaces TypeParameter TypeParameters Expression ExpressionList Primary Literal NullLiteral NumericLiteral NUMBER EXPONENT HEX-NUMBER HEX-DIGIT BooleanLiteral StringLiteral SINGLE-LINE-STRING MULTI-LINE-STRING ESCAPE-SEQUENCE HEX-DIGIT-SEQUENCE STRING-CONTENT-DQ STRING-CONTENT-SQ NEWLINE STRING-INTERPOLATION ListLiteral MapLiteral MapLiteralEntry FunctionExpression FunctionExpressionBody ThisExpression NewExpression ConstantObjectExpression Arguments ArgumentList NamedArgument AssignmentOperator CompoundAssignmentOperator ConditionalExpression LogicalOrExpression LogicalAndExpression BitwiseOrExpression BitwiseXorExpression BitwiseAndExpression BitwiseOperator EqualityExpression EqualityOperator RelationalExpression RelationalOperator ShiftExpression ShiftOperator AdditiveExpression AdditiveOperator MultiplicativeExpression MultiplicativeOperator UnaryExpression PrefixExpression PostfixExpression PostfixOperator IncrementOperator AssignableExpression Selector AssignableSelector Identifier IDENTIFIER-NO-DOLLAR IDENTIFIER BUILT-IN-IDENTIFIER IDENTIFIER-START IDENTIFIER-START-NO-DOLLAR IDENTIFIER-PART-NO-DOLLAR IDENTIFIER-PART Qualified IsOperator Statements Statement NonLabelledStatement ExpressionStatement IfStatement ForStatement ForLoopParts ForInitializerStatement WhileStatement DoStatement SwitchStatement SwitchCase DefaultCase TryStatement CatchPart FinallyPart ReturnStatement Label BreakStatement ContinueStatement ThrowStatement AssertStatement TopLevelDefinition GetOrSet LibraryDefinition ScriptTag LibraryName Resource LibraryImport Include CompilationUnit ScriptDefinition Type TypeArguments TypeList FunctionTypeAlias LETTER DIGIT WHITESPACE SINGLE-LINE-COMMENT MULTI-LINE-COMMENT ReturnType 
  context-free syntax
        DeclaredIdentifier ("," Identifier)* -> VariableDeclaration

        DeclaredIdentifier ("=" Expression)? ("," InitializedIdentifier)* -> InitializedVariableDeclaration

        InitializedIdentifier ("," InitializedIdentifier)* -> InitializedIdentifierList

        Identifier ("=" Expression)? -> InitializedIdentifier

        FinalVarOrType Identifier -> DeclaredIdentifier

        "final" Type?
		| "var"
		| Type -> FinalVarOrType

        ReturnType? Identifier FormalParameterList -> FunctionSignature

        ReturnType? Identifier -> FunctionPrefix

        "=>" Expression ";"
		| Block -> FunctionBody

        "{" Statements "}" -> Block

        "(" ")"
		| "(" NormalFormalParameters ("," NamedFormalParameters)? ")"
		| NamedFormalParameters -> FormalParameterList

        NormalFormalParameter ("," NormalFormalParameter)* -> NormalFormalParameters

        "[" DefaultFormalParameter ("," DefaultFormalParameter)* "]" -> NamedFormalParameters

        FunctionSignature
		| FieldFormalParameter
		| SimpleFormalParameter -> NormalFormalParameter

        DeclaredIdentifier
		| Identifier -> SimpleFormalParameter

        FinalVarOrType? "this" "." Identifier -> FieldFormalParameter

        NormalFormalParameter ("=" Expression)? -> DefaultFormalParameter

        "class" Identifier TypeParameters? Superclass? Interfaces? "{" ClassMemberDefinition* "}" -> ClassDefinition

        Declaration ";"
		| MethodSignature FunctionBody -> ClassMemberDefinition

        FactoryConstructorSignature
		| "static" FunctionSignature
		| GetterSignature
		| SetterSignature
		| OperatorSignature
		| FunctionSignature Initializers?
		| NamedConstructorSignature Initializers? -> MethodSignature

        ConstantConstructorSignature (Redirection | Initializers)?
		| ConstructorSignature (Redirection | Initializers)?
		| FunctionSignature Redirection
		| NamedConstructorSignature Redirection
		| "abstract" GetterSignature
		| "abstract" SetterSignature
		| "abstract" OperatorSignature
		| "abstract" FunctionSignature
		| "static" "final" Type? StaticFinalDeclarationList
		| "static"? InitializedVariableDeclaration -> Declaration

        StaticFinalDeclaration ("," StaticFinalDeclaration)* -> StaticFinalDeclarationList

        Identifier "=" Expression -> StaticFinalDeclaration

        ReturnType? "operator" Operator FormalParameterList -> OperatorSignature

        UnaryOperator
		| BinaryOperator
		| "[]"
		| "[]="
		| "negate" -> Operator

        NegateOperator -> UnaryOperator

        MultiplicativeOperator
		| AdditiveOperator
		| ShiftOperator
		| RelationalOperator
		| EqualityOperator
		| BitwiseOperator -> BinaryOperator

        AdditiveOperator
		| NegateOperator -> PrefixOperator

        "!"
		| "~" -> NegateOperator

        "static"? ReturnType? "get" Identifier FormalParameterList -> GetterSignature

        "static"? ReturnType? "set" Identifier FormalParameterList -> SetterSignature

        Identifier FormalParameterList
		| NamedConstructorSignature -> ConstructorSignature

        Identifier "." Identifier FormalParameterList -> NamedConstructorSignature

        ":" "this" ("." Identifier)? Arguments -> Redirection

        ":" SuperCallOrFieldInitializer ("," SuperCallOrFieldInitializer)* -> Initializers

        "super" Arguments
		| "super" "." Identifier Arguments
		| FieldInitializer -> SuperCallOrFieldInitializer

        ("this" ".")? Identifier "=" ConditionalExpression -> FieldInitializer

        "factory" Qualified TypeVariables? ("." Identifier)? FormalParameterList -> FactoryConstructorSignature

        "const" Qualified FormalParameterList -> ConstantConstructorSignature

        "extends" Type -> Superclass

        "implements" TypeList -> Interfaces

        "interface" Identifier TypeParameters? Superinterfaces? FactorySpecification? "{" InterfaceMemberDefinition* "}" -> InterfaceDefinition

        "static" "final" Type? InitializedIdentifierList ";"
		| FunctionSignature ";"
		| ConstantConstructorSignature ";"
		| NamedConstructorSignature ";"
		| GetterSignature ";"
		| SetterSignature ";"
		| OperatorSignature ";"
		| VariableDeclaration ";" -> InterfaceMemberDefinition

        "factory" Identifier TypeParameters? -> FactorySpecification

        "extends" TypeList -> Superinterfaces

        Identifier ("extends" Type)? -> TypeParameter

        "<" TypeParameter ("," TypeParameter)* ">" -> TypeParameters

        AssignableExpression AssignmentOperator Expression
		| ConditionalExpression -> Expression

        Expression ("," Expression)* -> ExpressionList

        ThisExpression
		| "super" AssignableSelector
		| FunctionExpression
		| Literal
		| Identifier
		| NewExpression ConstantObjectExpression
		| "(" Expression ")" -> Primary

        NullLiteral
		| BooleanLiteral
		| NumericLiteral
		| StringLiteral
		| MapLiteral
		| ListLiteral -> Literal

        "null" -> NullLiteral

        NUMBER
		| HEX-NUMBER -> NumericLiteral

        DIGIT+ ("." DIGIT*)? EXPONENT?
		| "." DIGIT+ EXPONENT? -> NUMBER

        ("e" | "E") ("+" | "-")? DIGIT+ -> EXPONENT

        "0x" HEX-DIGIT+
		| "0X" HEX-DIGIT+ -> HEX-NUMBER

        "a"
		| "b"
		| "c"
		| "d"
		| "e"
		| "f"
		| "A"
		| "B"
		| "C"
		| "D"
		| "E"
		| "F"
		| DIGIT -> HEX-DIGIT

        "true"
		| "false" -> BooleanLiteral

        "@"? MULTI-LINE-STRING
		| SINGLE-LINE-STRING -> StringLiteral

        """ STRING-CONTENT-DQ* """
		| "'" STRING-CONTENT-SQ* "'"
		| "@" "'" ANY* "'"
		| "@" """ ANY* """ -> SINGLE-LINE-STRING

        """"" ANY* """""
		| "'''" ANY* "'''" -> MULTI-LINE-STRING

        "\" "n"
		| "\" "r"
		| "\" "f"
		| "\" "b"
		| "\" "t"
		| "\" "v"
		| "\" "x" HEX-DIGIT HEX-DIGIT
		| "\" "u" HEX-DIGIT HEX-DIGIT HEX-DIGIT HEX-DIGIT
		| "\" "u" -> ESCAPE-SEQUENCE

        HEX-DIGIT HEX-DIGIT? HEX-DIGIT? HEX-DIGIT? HEX-DIGIT? HEX-DIGIT? HEX-DIGIT? -> HEX-DIGIT-SEQUENCE

        ANY
		| "\" ANY
		| STRING-INTERPOLATION -> STRING-CONTENT-DQ

        ANY
		| "\" ANY
		| STRING-INTERPOLATION -> STRING-CONTENT-SQ

        "\n"
		| "\r" -> NEWLINE

        "$" IDENTIFIER-NO-DOLLAR
		| "$" "{" Expression "}" -> STRING-INTERPOLATION

        "const"? TypeArguments? "[" (ExpressionList ","?)? "]" -> ListLiteral

        "const"? TypeArguments? "{" (MapLiteralEntry ("," MapLiteralEntry)* ","?)? "}" -> MapLiteral

        Identifier ":" Expression
		| StringLiteral ":" Expression -> MapLiteralEntry

        (ReturnType? Identifier)? FormalParameterList FunctionExpressionBody -> FunctionExpression

        "=>" Expression
		| Block -> FunctionExpressionBody

        "this" -> ThisExpression

        "new" Type ("." Identifier)? Arguments -> NewExpression

        "const" Type ("." Identifier)? Arguments -> ConstantObjectExpression

        "(" ArgumentList? ")" -> Arguments

        NamedArgument ("," NamedArgument)*
		| ExpressionList ("," NamedArgument)* -> ArgumentList

        Label Expression -> NamedArgument

        "="
		| CompoundAssignmentOperator -> AssignmentOperator

        "*="
		| "/="
		| "~/="
		| "%="
		| "+="
		| "-="
		| "<<="
		| ">" ">" ">" "="?
		| "<" "<" "="?
		| "&="
		| "^="
		| "|=" -> CompoundAssignmentOperator

        LogicalOrExpression ("?" Expression ":" Expression)? -> ConditionalExpression

        LogicalAndExpression ("||" LogicalAndExpression)* -> LogicalOrExpression

        BitwiseOrExpression ("&&" BitwiseOrExpression)* -> LogicalAndExpression

        BitwiseXorExpression ("|" BitwiseXorExpression)*
		| "super" ("|" BitwiseXorExpression)+ -> BitwiseOrExpression

        BitwiseAndExpression ("^" BitwiseAndExpression)*
		| "super" ("^" BitwiseAndExpression)+ -> BitwiseXorExpression

        EqualityExpression ("&" EqualityExpression)*
		| "super" ("&" EqualityExpression)+ -> BitwiseAndExpression

        "&"
		| "^"
		| "|" -> BitwiseOperator

        RelationalExpression (EqualityOperator RelationalExpression)?
		| "super" EqualityOperator RelationalExpression -> EqualityExpression

        "=="
		| "!="
		| "==="
		| "!==" -> EqualityOperator

        ShiftExpression ((IsOperator Type) | (RelationalOperator ShiftExpression))?
		| "super" RelationalOperator ShiftExpression -> RelationalExpression

        ">="
		| ">"
		| "<="
		| "<" -> RelationalOperator

        AdditiveExpression (ShiftOperator AdditiveExpression)*
		| "super" (ShiftOperator AdditiveExpression)+ -> ShiftExpression

        "<<"
		| ">>>"
		| ">>" -> ShiftOperator

        MultiplicativeExpression (AdditiveOperator MultiplicativeExpression)*
		| "super" (AdditiveOperator MultiplicativeExpression)+ -> AdditiveExpression

        "+"
		| "-" -> AdditiveOperator

        UnaryExpression (MultiplicativeOperator UnaryExpression)*
		| "super" (MultiplicativeOperator UnaryExpression)+ -> MultiplicativeExpression

        "*"
		| "/"
		| "%"
		| "~/" -> MultiplicativeOperator

        PrefixExpression
		| PostfixExpression
		| UnaryOperator "super"
		| "-" "super"
		| IncrementOperator AssignableExpression -> UnaryExpression

        PrefixOperator UnaryExpression -> PrefixExpression

        AssignableExpression PostfixOperator
		| Primary Selector* -> PostfixExpression

        IncrementOperator -> PostfixOperator

        "++"
		| "--" -> IncrementOperator

        Primary (Arguments* AssignableSelector)+
		| "super" AssignableSelector
		| Identifier -> AssignableExpression

        AssignableSelector
		| Arguments -> Selector

        "[" Expression "]"
		| "." Identifier -> AssignableSelector

        IDENTIFIER-NO-DOLLAR
		| IDENTIFIER
		| BUILT-IN-IDENTIFIER -> Identifier

        IDENTIFIER-START-NO-DOLLAR IDENTIFIER-PART-NO-DOLLAR* -> IDENTIFIER-NO-DOLLAR

        IDENTIFIER-START IDENTIFIER-PART* -> IDENTIFIER

        "abstract"
		| "assert"
		| "class"
		| "extends"
		| "factory"
		| "get"
		| "implements"
		| "import"
		| "interface"
		| "is"
		| "library"
		| "negate"
		| "operator"
		| "set"
		| "source"
		| "static"
		| "typedef" -> BUILT-IN-IDENTIFIER

        IDENTIFIER-START-NO-DOLLAR
		| "$" -> IDENTIFIER-START

        LETTER
		| "_" -> IDENTIFIER-START-NO-DOLLAR

        IDENTIFIER-START-NO-DOLLAR
		| DIGIT -> IDENTIFIER-PART-NO-DOLLAR

        IDENTIFIER-START
		| DIGIT -> IDENTIFIER-PART

        Identifier ("." Identifier)? -> Qualified

        "is" "!"? -> IsOperator

        Statement* -> Statements

        Label* NonLabelledStatement -> Statement

        Block
		| InitializedVariableDeclaration ";"
		| ForStatement
		| WhileStatement
		| DoStatement
		| SwitchStatement
		| IfStatement
		| TryStatement
		| BreakStatement
		| ContinueStatement
		| ReturnStatement
		| ThrowStatement
		| ExpressionStatement
		| AssertStatement
		| FunctionSignature FunctionBody -> NonLabelledStatement

        Expression? ";" -> ExpressionStatement

        "if" "(" Expression ")" Statement ("else" Statement)? -> IfStatement

        "for" "(" ForLoopParts ")" Statement -> ForStatement

        ForInitializerStatement Expression? ";" ExpressionList?
		| DeclaredIdentifier "in" Expression
		| Identifier "in" Expression -> ForLoopParts

        InitializedVariableDeclaration ";"
		| Expression? ";" -> ForInitializerStatement

        "while" "(" Expression ")" Statement -> WhileStatement

        "do" Statement "while" "(" Expression ")" ";" -> DoStatement

        "switch" "(" Expression ")" "{" SwitchCase* DefaultCase? "}" -> SwitchStatement

        Label? ("case" Expression ":")+ Statements -> SwitchCase

        Label? ("case" Expression ":")* "default" ":" Statements -> DefaultCase

        "try" Block ((CatchPart+ FinallyPart?) | FinallyPart) -> TryStatement

        "catch" "(" DeclaredIndentifier ("," DeclaredIndentifier)? ")" Block -> CatchPart

        "finally" Block -> FinallyPart

        "return" Expression? ";" -> ReturnStatement

        Identifier ":" -> Label

        "break" Identifier? ";" -> BreakStatement

        "continue" Identifier? ";" -> ContinueStatement

        "throw" Expression? ";" -> ThrowStatement

        "assert" "(" ConditionalExpression ")" ";" -> AssertStatement

        ClassDefinition
		| InterfaceDefinition
		| FunctionTypeAlias
		| FunctionSignature FunctionBody
		| ReturnType? GetOrSet Identifier FormalParameterList FunctionBody
		| "final" Type? StaticFinalDeclarationList ";"
		| VariableDeclaration ";" -> TopLevelDefinition

        "get"
		| "set" -> GetOrSet

        ScriptTag? LibraryName LibraryImport* Include* Resource* TopLevelDefinition* -> LibraryDefinition

        "#!" ANY* NEWLINE -> ScriptTag

        "#" "library" "(" StringLiteral ")" ";" -> LibraryName

        "#" "resource" "(" StringLiteral ")" ";" -> Resource

        "#" "import" "(" StringLiteral ("," "prefix:" StringLiteral)? ")" ";" -> LibraryImport

        "#" "source" "(" StringLiteral ")" ";" -> Include

        TopLevelDefinition* EOF -> CompilationUnit

        ScriptTag? LibraryName? LibraryImport* Include* Resource* TopLevelDefinition* -> ScriptDefinition

        Qualified TypeArguments? -> Type

        "<" TypeList ">" -> TypeArguments

        Type ("," Type)* -> TypeList

        "typedef" FunctionPrefix TypeParameters? FormalParameterList ";" -> FunctionTypeAlias

        "a"
		| "b"
		| "c"
		| "d"
		| "e"
		| "f"
		| "g"
		| "h"
		| "i"
		| "j"
		| "k"
		| "l"
		| "m"
		| "n"
		| "o"
		| "p"
		| "q"
		| "r"
		| "s"
		| "t"
		| "u"
		| "v"
		| "w"
		| "x"
		| "y"
		| "z"
		| "A"
		| "B"
		| "C"
		| "D"
		| "E"
		| "F"
		| "G"
		| "H"
		| "I"
		| "J"
		| "K"
		| "L"
		| "M"
		| "N"
		| "O"
		| "P"
		| "Q"
		| "R"
		| "S"
		| "T"
		| "U"
		| "V"
		| "W"
		| "X"
		| "Y"
		| "Z" -> LETTER

        "0"
		| "1"
		| "2"
		| "3"
		| "4"
		| "5"
		| "6"
		| "7"
		| "8"
		| "9" -> DIGIT

        ("\t" | " " | NEWLINE)+ -> WHITESPACE

        "//" ANY* NEWLINE? -> SINGLE-LINE-COMMENT

        "/*" ANY* -> MULTI-LINE-COMMENT

        "void"
		| Type -> ReturnType
