module Main

exports
  sorts
        Class-declaration Indexing Index-list Index-clause Index Index-terms Index-value Class-header Header-mark Class-name Formal-generics Formal-generic-list Formal-generic Formal-generic-name Constraint Obsolete Message Inheritance Parent-list Parent Feature-adaptation Rename Rename-list Rename-pair New-exports New-export-list New-export-item Feature-set Feature-list Clients Class-list Redefine Undefine Select Creators Creation-clause Procedure-list Procedure-name Features Feature-clause Feature-declaration-list Feature-declaration Declaration-body Constant-or-routine Feature-value Unique New-feature-list New-feature Feature-name Prefix Infix Prefix-operator Infix-operator Unary Binary Formal-arguments Entity-declaration-list Entity-declaration-group Identifier-list Type-mark Routine Routine-body Effective Internal Routine-mark Deferred External Language-name External-name Local-declarations Precondition Postcondition Invariant Assertion Assertion-clause Unlabeled-assertion-clause Tag-mark Tag Rescue Type Class-type Actual-generics Type-list Class-type-expanded Class-type-separate Bit-type Bit-length Anchored Anchor Compound Instruction Creation Creation-call Assignment Assignment-attempt Conditional Then-part-list Then-part Else-part Multi-branch When-part-list When-part Choices Choice Interval Choice-constant Loop Initialization Variant Loop-body Exit Debug Debug-keys Debug-key-list Debug-key Check Retry Null-instruction Call Qualified-call Call-qualifier Call-target Call-chain Unqualified-call Precursor Parent-qualification Attribute Writable Actuals Actual-list Actual Address Address-mark Expression Boolean-expression Operator-expression Parenthesized Unary-expression Binary-expression Equality Comparison Manifest-constant Boolean-constant Integer-constant Real-constant Sign Wide-character-constant Wide-manifest-string Manifest-array Expression-list Old Strip Attribute-list Identifier Integer 
  context-free syntax
        Indexing? Class-header Formal-generics? Obsolete? Inheritance? Creators? Features? Invariant? "end" ("--" "class" Class-name)? -> Class-declaration

        "indexing" Index-list -> Indexing

        (Index-clause ";")* -> Index-list

        Index? Index-terms -> Index-clause

        Identifier ":" -> Index

        (Index-value ",")+ -> Index-terms

        Identifier
		| Manifest-constant -> Index-value

        Header-mark? "class" Class-name -> Class-header

        "deferred"
		| "expanded"
		| "separate" -> Header-mark

        Identifier -> Class-name

        Formal-generic-list? -> Formal-generics

        (Formal-generic ",")* -> Formal-generic-list

        Formal-generic-name Constraint? -> Formal-generic

        Identifier -> Formal-generic-name

        "-" ">" Class-type -> Constraint

        "obsolete" Message -> Obsolete

        Manifest-string -> Message

        "inherit" Parent-list -> Inheritance

        (Parent ";")* -> Parent-list

        Class-type Feature-adaptation? -> Parent

        Rename? New-exports? Undefine? Redefine? Select? "end" -> Feature-adaptation

        "rename" Rename-list -> Rename

        (Rename-pair ",")* -> Rename-list

        Feature-name "as" Feature-name -> Rename-pair

        "export" New-export-list -> New-exports

        (New-export-item ";")* -> New-export-list

        Clients Feature-set -> New-export-item

        Feature-list
		| "all" -> Feature-set

        (Feature-name ",")* -> Feature-list

        "{" Class-list "}" -> Clients

        (Class-name ",")* -> Class-list

        "redefine" Feature-list -> Redefine

        "undefine" Feature-list -> Undefine

        "select" Feature-list -> Select

        "creation" (Creation-clause "creation")+ -> Creators

        Clients? Header-comment? Procedure-list -> Creation-clause

        (Procedure-name ",")* -> Procedure-list

        Identifier -> Procedure-name

        "feature" (Feature-clause "feature")+ -> Features

        Clients? Header-comment? Feature-declaration-list -> Feature-clause

        (Feature-declaration ";")* -> Feature-declaration-list

        New-feature-list Declaration-body -> Feature-declaration

        Formal-arguments? Type-mark? Constant-or-routine? -> Declaration-body

        "is" Feature-value -> Constant-or-routine

        Manifest-constant
		| Unique
		| Routine -> Feature-value

        "Unique" -> Unique

        (New-feature ",")+ -> New-feature-list

        "frozen"? Feature-name -> New-feature

        Identifier
		| Prefix
		| Infix -> Feature-name

        "prefix" """ Prefix-operator """ -> Prefix

        "infix" """ Infix-operator """ -> Infix

        Unary
		| Free-operator -> Prefix-operator

        Binary
		| Free-operator -> Infix-operator

        "not"
		| "+"
		| "-" -> Unary

        "+"
		| "-"
		| "*"
		| "/"
		| "<"
		| ">"
		| "<="
		| ">="
		| "//"
		| "\\"
		| "^"
		| "and"
		| "or"
		| "xor"
		| "and" "then"
		| "or" "else"
		| "implies" -> Binary

        "(" Entity-declaration-list ")" -> Formal-arguments

        (Entity-declaration-group ";")* -> Entity-declaration-list

        Identifier-list Type-mark -> Entity-declaration-group

        (Identifier ",")+ -> Identifier-list

        ":" Type -> Type-mark

        Obsolete? Header-comment? Precondition? Local-declarations? Routine-body Postcondition? Rescue? "end" ("--" Feature-name)? -> Routine

        Effective
		| Deferred -> Routine-body

        Internal
		| External -> Effective

        Routine-mark Compound -> Internal

        "do"
		| "once" -> Routine-mark

        "deferred" -> Deferred

        "external" Language-name External-name? -> External

        Manifest-string -> Language-name

        "alias" Manifest-string -> External-name

        "local" Entity-declaration-list -> Local-declarations

        "require" "else"? Assertion -> Precondition

        "ensure" "then"? Assertion -> Postcondition

        "invariant" Assertion -> Invariant

        (Assertion-clause ";")* -> Assertion

        Tag-mark? Unlabeled-assertion-clause -> Assertion-clause

        Boolean-expression
		| Comment -> Unlabeled-assertion-clause

        Tag ":" -> Tag-mark

        Identifier -> Tag

        "rescue" Compound -> Rescue

        Class-type
		| Class-type-expanded
		| Class-type-separate
		| Anchored
		| Bit-type -> Type

        Class-name Actual-generics? -> Class-type

        Type-list? -> Actual-generics

        (Type ",")* -> Type-list

        "expanded" Class-type -> Class-type-expanded

        "separate" Class-type -> Class-type-separate

        "BIT" Bit-length -> Bit-type

        Integer-constant
		| Attribute -> Bit-length

        "like" Anchor -> Anchored

        Identifier
		| "Current" -> Anchor

        (Instruction ";")* -> Compound

        Creation
		| Call
		| Assignment
		| Assignment-attempt
		| Conditional
		| Multi-branch
		| Loop
		| Debug
		| Check
		| Retry
		| Null-instruction -> Instruction

        "!" Type? "!" Writable Creation-call? -> Creation

        "." Procedure-name Actuals? -> Creation-call

        Writable ":=" Expression -> Assignment

        Writable "?=" Expression -> Assignment-attempt

        "if" Then-part-list Else-part? "end" -> Conditional

        (Then-part "elseif")+ -> Then-part-list

        Boolean-expression "then" Compound -> Then-part

        "else" Compound -> Else-part

        "inspect" Expression When-part-list? Else-part? "end" -> Multi-branch

        "when" (When-part "when")+ -> When-part-list

        Choices "then" Compound -> When-part

        (Choice ",")* -> Choices

        Choice-constant
		| Interval -> Choice

        Choice-constant ".." Choice-constant -> Interval

        Integer-constant
		| Character-constant
		| Attribute -> Choice-constant

        Initialization Invariant? Variant? Loop-body "end" -> Loop

        "from" Compound -> Initialization

        "variant" Tag-mark? Expression -> Variant

        Exit "loop" Compound -> Loop-body

        "until" Boolean-expression -> Exit

        "debug" Debug-keys? Compound "end" -> Debug

        "(" Debug-key-list ")" -> Debug-keys

        (Debug-key ",")* -> Debug-key-list

        Manifest-string -> Debug-key

        "check" Assertion "end" -> Check

        "retry" -> Retry

         -> Null-instruction

        Qualified-call
		| Precursor -> Call

        Call-qualifier? Call-chain -> Qualified-call

        Call-target "." -> Call-qualifier

        Parenthesized
		| "Result"
		| "Current"
		| Precursor -> Call-target

        (Unqualified-call ".")+ -> Call-chain

        Identifier Actuals? -> Unqualified-call

        Parent-qualification? "Precursor" Actuals? -> Precursor

        "{" Class-name "}" -> Parent-qualification

        Identifier -> Attribute

        Identifier
		| "Result" -> Writable

        "(" Actual-list ")" -> Actuals

        (Actual ",")* -> Actual-list

        Expression
		| Address -> Actual

        "$" Address-mark -> Address

        Feature-name
		| "Current"
		| "Result" -> Address-mark

        "Current"
		| "Result"
		| Call
		| Operator-expression
		| Equality
		| Manifest-array
		| Old
		| Strip
		| Boolean-constant
		| Bit-constant
		| Integer
		| Real
		| Manifest-string
		| Character-constant
		| Wide-character-constant
		| Wide-manifest-string
		| Hexadecimal-constant -> Expression

        Expression -> Boolean-expression

        Parenthesized
		| Unary-expression
		| Binary-expression -> Operator-expression

        "(" Expression ")" -> Parenthesized

        Prefix-operator Expression -> Unary-expression

        Expression Infix-operator Expression -> Binary-expression

        Expression Comparison Expression -> Equality

        "="
		| "/=" -> Comparison

        Boolean-constant
		| Character-constant
		| Integer-constant
		| Real-constant
		| Manifest-string
		| Bit-constant
		| Wide-character-constant
		| Wide-manifest-string
		| Hexadecimal-constant -> Manifest-constant

        "True"
		| "False" -> Boolean-constant

        Sign? Integer -> Integer-constant

        Sign? Real -> Real-constant

        "+"
		| "-" -> Sign

        "$" Character-constant -> Wide-character-constant

        "$" Manifest-string -> Wide-manifest-string

        "<<" Expression-list ">>" -> Manifest-array

        (Expression ",")* -> Expression-list

        "old" Expression -> Old

        "Strip" "(" Attribute-list ")" -> Strip

        (Attribute ",")* -> Attribute-list

        Letter (Letter | Decimal-digit | "_")* -> Identifier

        Decimal-digit+
		| Decimal-digit (Decimal-digit Decimal-digit?)? ("_" Decimal-digit Decimal-digit Decimal-digit)+ -> Integer
