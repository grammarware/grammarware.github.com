Class_name = Identifier ;
Class_declaration = Notes? Class_header Formal_generics? Obsolete? Inheritance? Creators? Converters? Features? Invariant? Notes? 'end' ;
Notes = 'note' Note_list ;
Note_list = 
	Note_entry
	';'
       ;
Note_entry = Note_name Note_values ;
Note_name = Identifier ':' ;
Note_values = 
	Note_item
	','
       ;
Note_item = Identifier ;
Note_item = Manifest_constant ;
Class_header = Header_mark? 'class' Class_name ;
Header_mark = 'deferred' ;
Header_mark = 'expanded' ;
Header_mark = 'frozen' ;
Obsolete = 'obsolete' Message ;
Message = Manifest_string ;
Features = Feature_clause+ ;
Feature_clause = 'feature' Clients? Header_comment? Feature_declaration_list ;
Feature_declaration_list = 
	Feature_declaration
	';'
       ;
Header_comment = Comment ;
Feature_declaration = New_feature_list Declaration_body ;
Declaration_body = Formal_arguments? Query_mark? Feature_value? ;
Query_mark = Type_mark Assigner_mark? ;
Type_mark = ':' Type ;
Feature_value = Explicit_value? Obsolete? Header_comment? Attribute_or_routine? ;
Explicit_value = '=' Manifest_constant ;
New_feature_list = 
	New_feature
	','
       ;
New_feature = 'frozen'? Extended_feature_name ;
Attribute_or_routine = Precondition? Local_declarations? Feature_body Postcondition? Rescue? 'end' ;
Feature_body = Deferred ;
Feature_body = Effective_routine ;
Feature_body = Attribute ;
Extended_feature_name = Feature_name Alias? ;
Feature_name = Identifier ;
Alias = 'alias' '"' Alias_name '"' 'convert'? ;
Alias_name = Operator ;
Alias_name = Bracket ;
Bracket = '[]' ;
Operator = Unary ;
Operator = Binary ;
Unary = 'not' ;
Unary = '+' ;
Unary = '-' ;
Unary = Free_unary ;
Binary = '+' ;
Binary = '-' ;
Binary = '*' ;
Binary = '/' ;
Binary = '//' ;
Binary = '\\' ;
Binary = '^' ;
Binary = '..' ;
Binary = '<' ;
Binary = '>' ;
Binary = '<=' ;
Binary = '>=' ;
Binary = 'and' ;
Binary = 'or' ;
Binary = 'xor' ;
Binary = 'and' 'then' ;
Binary = 'or' 'else' ;
Binary = 'implies' ;
Binary = Free_binary ;
Assigner_mark = 'assign' Feature_name ;
Inheritance = Inherit_clause+ ;
Inherit_clause = 'inherit' Non_conformance? Parent_list ;
Non_conformance = '{' 'NONE' '}' ;
Parent_list = 
	Parent
	';'
       ;
Parent = Class_type Feature_adaptation? ;
Feature_adaptation = Undefine? Redefine? Rename? New_exports? Select? 'end' ;
Rename = 'rename' Rename_list ;
Rename_list = 
	Rename_pair
	','
       ;
Rename_pair = Feature_name 'as' Extended_feature_name ;
Clients = '{' Class_list '}' ;
Class_list = 
	Class_name
	','
       ;
New_exports = 'export' New_export_list ;
New_export_list = 
	New_export_item
	';'
       ;
New_export_item = Clients Header_comment? Feature_set ;
Feature_set = Feature_list ;
Feature_set = 'all' ;
Feature_list = 
	Feature_name
	','
       ;
Formal_arguments = '(' Entity_declaration_list ')' ;
Entity_declaration_list = 
	Entity_declaration_group
	';'
       ;
Entity_declaration_group = Identifier_list Type_mark ;
Identifier_list = 
	Identifier
	','
       ;
Deferred = 'deferred' ;
Effective_routine = Internal ;
Effective_routine = External ;
Internal = Routine_mark Compound ;
Routine_mark = 'do' ;
Routine_mark = Once ;
Once = 'once' ('(' Key_list ')')? ;
Key_list = 
	Manifest_string
	','
       ;
Local_declarations = 'local' Entity_declaration_list? ;
Compound = 
	Instruction
	';'
       ;
Instruction = Creation_instruction ;
Instruction = Call ;
Instruction = Assignment ;
Instruction = Assigner_call ;
Instruction = Conditional ;
Instruction = Multi_branch ;
Instruction = Loop ;
Instruction = Debug ;
Instruction = Precursor ;
Instruction = Check ;
Instruction = Retry ;
Precondition = 'require' 'else'? Assertion ;
Postcondition = 'ensure' 'then'? Assertion Only? ;
Invariant = 'invariant' Assertion ;
Assertion = 
	Assertion_clause
	';'
       ;
Assertion_clause = Tag_mark? Unlabeled_assertion_clause ;
Unlabeled_assertion_clause = Boolean_expression ;
Unlabeled_assertion_clause = Comment ;
Tag_mark = Tag ':' ;
Tag = Identifier ;
Old = 'old' Expression ;
Only = 'only' Feature_list? ;
Check = 'check' Assertion Notes? 'end' ;
Variant = 'variant' Tag_mark? Expression ;
Precursor = Precursor Parent_qualification? Actuals? ;
Parent_qualification = '{' Class_name '}' ;
Redefine = 'redefine' Feature_list ;
Undefine = 'undefine' Feature_list ;
Type = Class_or_tuple_type ;
Type = Formal_generic_name ;
Type = Anchored ;
Class_or_tuple_type = Class_type ;
Class_or_tuple_type = Tuple_type ;
Class_type = Attachment_mark? Class_name Actual_generics? ;
Attachment_mark = '?' ;
Attachment_mark = '!' ;
Anchored = Attachment_mark? 'like' Anchor ;
Anchor = Feature_name ;
Anchor = 'Current' ;
Actual_generics = '[' Type_list ']' ;
Type_list = 
	Type
	','
       ;
Formal_generics = '[' Formal_generic_list ']' ;
Formal_generic_list = 
	Formal_generic
	','
       ;
Formal_generic = 'frozen'? Formal_generic_name Constraint? ;
Formal_generic_name = '?'? Identifier ;
Constraint = '->' Constraining_types Constraint_creators? ;
Constraining_types = Single_constraint ;
Constraining_types = Multiple_constraint ;
Single_constraint = Type Renaming? ;
Renaming = Rename 'end' ;
Multiple_constraint = '{' Constraint_list '}' ;
Constraint_list = 
	Single_constraint
	','
       ;
Constraint_creators = 'create' Feature_list 'end' ;
Tuple_type = 'TUPLE' Tuple_parameter_list? ;
Tuple_parameter_list = '[' Tuple_parameters ']' ;
Tuple_parameters = Type_list ;
Tuple_parameters = Entity_declaration_list ;
Manifest_tuple = '[' Expression_list ']' ;
Expression_list = 
	Expression
	','
       ;
Converters = 'convert' Converter_list ;
Converter_list = 
	Converter
	','
       ;
Converter = Conversion_procedure ;
Converter = Conversion_query ;
Conversion_procedure = Feature_name '({' Type_list '})' ;
Conversion_query = Feature_name ':{' Type_list '}' ;
Select = 'select' Feature_list ;
Conditional = 'if' Then_part_list Else_part? 'end' ;
Then_part_list = 
	Then_part
	'elseif'
       ;
Then_part = Boolean_expression 'then' Compound ;
Else_part = 'else' Compound ;
Multi_branch = 'inspect' Expression When_part_list? Else_part? 'end' ;
When_part_list = When_part+ ;
When_part = 'when' Choices 'then' Compound ;
Choices = 
	Choice
	','
       ;
Choice = Constant ;
Choice = Manifest_type ;
Choice = Constant_interval ;
Choice = Type_interval ;
Constant_interval = Constant '..' Constant ;
Type_interval = Manifest_type '..' Manifest_type ;
Loop = Initialization Invariant? Exit_condition Loop_body Variant? 'end' ;
Initialization = 'from' Compound ;
Exit_condition = 'until' Boolean_expression ;
Loop_body = 'loop' Compound ;
Debug = 'debug' ('(' Key_list ')')? Compound 'end' ;
Attribute = 'attribute' Compound ;
Entity = Variable ;
Entity = Read_only ;
Variable = Variable_attribute ;
Variable = Local ;
Variable_attribute = Feature_name ;
Local = Identifier ;
Local = 'Result' ;
Read_only = Formal ;
Read_only = Constant_attribute ;
Read_only = 'Current' ;
Formal = Identifier ;
Constant_attribute = Feature_name ;
Creators = Creation_clause+ ;
Creation_clause = 'create' Clients? Header_comment? Creation_procedure_list ;
Creation_procedure_list = 
	Creation_procedure
	','
       ;
Creation_procedure = Feature_name ;
Creation_instruction = 'create' Explicit_creation_type? Creation_call ;
Explicit_creation_type = '{' Type '}' ;
Creation_call = Variable Explicit_creation_call? ;
Explicit_creation_call = '.' Unqualified_call ;
Creation_expression = 'create' Explicit_creation_type Explicit_creation_call? ;
Equality = Expression Comparison Expression ;
Comparison = '=' ;
Comparison = '/=' ;
Comparison = '~' ;
Comparison = '/~' ;
Assignment = Variable ':=' Expression ;
Assigner_call = Expression ':=' Expression ;
Call = Object_call ;
Call = Non_object_call ;
Object_call = (Target '.')? Unqualified_call ;
Unqualified_call = Feature_name Actuals? ;
Target = Local ;
Target = Read_only ;
Target = Call ;
Target = Parenthesized_target ;
Parenthesized_target = '(|' Expression '|)' ;
Non_object_call = '{' Type '}.' Unqualified_call ;
Actuals = '(' Actual_list ')' ;
Actual_list = 
	Expression
	','
       ;
Object_test = '{' Identifier ':' Type '}' Expression ;
Rescue = 'rescue' Compound ;
Retry = 'retry' ;
Agent = Call_agent ;
Agent = Inline_agent ;
Call_agent = 'agent' Call_agent_body ;
Inline_agent = 'agent' Formal_arguments? Type_mark? Attribute_or_routine? Agent_actuals? ;
Call_agent_body = Agent_qualified ;
Call_agent_body = Agent_unqualified ;
Agent_qualified = Agent_target '.' Agent_unqualified ;
Agent_unqualified = Feature_name Agent_actuals? ;
Agent_target = Entity ;
Agent_target = Parenthesized ;
Agent_target = Manifest_type ;
Agent_actuals = '(' Agent_actual_list ')' ;
Agent_actual_list = 
	Agent_actual
	','
       ;
Agent_actual = Expression ;
Agent_actual = Placeholder ;
Placeholder = Manifest_type? '?' ;
Expression = Basic_expression ;
Expression = Special_expression ;
Basic_expression = Read_only ;
Basic_expression = Local ;
Basic_expression = Call ;
Basic_expression = Precursor ;
Basic_expression = Equality ;
Basic_expression = Parenthesized ;
Basic_expression = Old ;
Basic_expression = Operator_expression ;
Basic_expression = Bracket_expression ;
Basic_expression = Creation_expression ;
Special_expression = Manifest_constant ;
Special_expression = Manifest_tuple ;
Special_expression = Agent ;
Special_expression = Object_test ;
Special_expression = Once_string ;
Special_expression = Address ;
Parenthesized = '(' Expression ')' ;
Address = '$' Variable ;
Once_string = 'once' Manifest_string ;
Boolean_expression = Basic_expression ;
Boolean_expression = Boolean_constant ;
Boolean_expression = Object_test ;
Operator_expression = Unary_expression ;
Operator_expression = Binary_expression ;
Unary_expression = Unary Expression ;
Binary_expression = Expression Binary Expression ;
Bracket_expression = Bracket_target '[' Actuals ']' ;
Bracket_target = Target ;
Bracket_target = Once_string ;
Bracket_target = Manifest_constant ;
Bracket_target = Manifest_tuple ;
Constant = Manifest_constant ;
Constant = Constant_attribute ;
Manifest_constant = Manifest_type? Manifest_value ;
Manifest_type = '{' Type '}' ;
Manifest_value = Boolean_constant ;
Manifest_value = Character_constant ;
Manifest_value = Integer_constant ;
Manifest_value = Real_constant ;
Manifest_value = Manifest_string ;
Manifest_value = Manifest_type ;
Sign = '+' ;
Sign = '-' ;
Integer_constant = Sign? Integer ;
Character_constant = ''' Character ''' ;
Boolean_constant = 'True' ;
Boolean_constant = 'False' ;
Real_constant = Sign? Real ;
Manifest_string = Basic_manifest_string ;
Manifest_string = Verbatim_string ;
Basic_manifest_string = '"' String_content '"' ;
String_content = 
	Simple_string
	Line_wrapping_part
       ;
Verbatim_string = Verbatim_string_opener Line_sequence Verbatim_string_closer ;
Verbatim_string_opener = '"' Simple_string? Open_bracket ;
Verbatim_string_closer = Close_bracket Simple_string? '"' ;
Open_bracket = '[' ;
Open_bracket = '{' ;
Close_bracket = ']' ;
Close_bracket = '}' ;
External = 'external' External_language External_name? ;
External_language = Unregistered_language ;
External_language = Registered_language ;
Unregistered_language = Manifest_string ;
External_name = 'alias' Manifest_string ;
Registered_language = C_external ;
Registered_language = CPP_external ;
Registered_language = DLL_external ;
External_signature = 'signature' External_argument_types? (':' External_type)? ;
External_argument_types = '(' External_type_list ')' ;
External_type_list = 
	External_type
	','
       ;
External_type = Simple_string ;
External_file_use = 'use' External_file_list ;
External_file_list = 
	External_file
	','
       ;
External_file = External_user_file ;
External_file = External_system_file ;
External_user_file = '"' Simple_string '"' ;
External_system_file = '<' Simple_string '>' ;
C_external = '"' 'C' 'inline'? External_signature? External_file_use? '"' ;
CPP_external = '"' 'C++' 'inline' External_signature? External_file_use? '"' ;
DLL_external = '"' 'dll' 'windows'? DLL_identifier DLL_index? External_signature? External_file_use? '"' ;
DLL_identifier = Simple_string ;
DLL_index = Integer ;
Comment = '--' 
	    Simple_string
	    Comment_break
	   ;
Comment_break = New_line Blanks_or_tabs? '--' ;
Integer = Integer_base? Digit_sequence ;
Integer_base = '0' Integer_base_letter ;
Integer_base_letter = 'b' ;
Integer_base_letter = 'c' ;
Integer_base_letter = 'x' ;
Integer_base_letter = 'B' ;
Integer_base_letter = 'C' ;
Integer_base_letter = 'X' ;
Digit_sequence = Digit+ ;
Digit = '0' ;
Digit = '1' ;
Digit = '2' ;
Digit = '3' ;
Digit = '4' ;
Digit = '5' ;
Digit = '6' ;
Digit = '7' ;
Digit = '8' ;
Digit = '9' ;
Digit = 'a' ;
Digit = 'b' ;
Digit = 'c' ;
Digit = 'd' ;
Digit = 'e' ;
Digit = 'f' ;
Digit = 'A' ;
Digit = 'B' ;
Digit = 'C' ;
Digit = 'D' ;
Digit = 'E' ;
Digit = 'F' ;
Digit = '_' ;
