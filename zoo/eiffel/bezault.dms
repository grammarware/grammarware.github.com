Class_declaration = Indexing? Class_header Formal_generics? Obsolete? Inheritance? Creators? Features? Invariant? 'end' ('--' 'class' Class_name)? ;
Indexing = 'indexing' Index_list ;
Index_list = (Index_clause ';')* ;
Index_clause = Index? Index_terms ;
Index = Identifier ':' ;
Index_terms = (Index_value ',')+ ;
Index_value = Identifier ;
Index_value = Manifest_constant ;
Class_header = Header_mark? 'class' Class_name ;
Header_mark = 'deferred' ;
Header_mark = 'expanded' ;
Header_mark = 'separate' ;
Class_name = Identifier ;
Formal_generics = Formal_generic_list? ;
Formal_generic_list = (Formal_generic ',')* ;
Formal_generic = Formal_generic_name Constraint? ;
Formal_generic_name = Identifier ;
Constraint = '-' '>' Class_type ;
Obsolete = 'obsolete' Message ;
Message = Manifest_string ;
Inheritance = 'inherit' Parent_list ;
Parent_list = (Parent ';')* ;
Parent = Class_type Feature_adaptation? ;
Feature_adaptation = Rename? New_exports? Undefine? Redefine? Select? 'end' ;
Rename = 'rename' Rename_list ;
Rename_list = (Rename_pair ',')* ;
Rename_pair = Feature_name 'as' Feature_name ;
New_exports = 'export' New_export_list ;
New_export_list = (New_export_item ';')* ;
New_export_item = Clients Feature_set ;
Feature_set = Feature_list ;
Feature_set = 'all' ;
Feature_list = (Feature_name ',')* ;
Clients = '{' Class_list '}' ;
Class_list = (Class_name ',')* ;
Redefine = 'redefine' Feature_list ;
Undefine = 'undefine' Feature_list ;
Select = 'select' Feature_list ;
Creators = 'creation' (Creation_clause 'creation')+ ;
Creation_clause = Clients? Header_comment? Procedure_list ;
Procedure_list = (Procedure_name ',')* ;
Procedure_name = Identifier ;
Features = 'feature' (Feature_clause 'feature')+ ;
Feature_clause = Clients? Header_comment? Feature_declaration_list ;
Feature_declaration_list = (Feature_declaration ';')* ;
Feature_declaration = New_feature_list Declaration_body ;
Declaration_body = Formal_arguments? Type_mark? Constant_or_routine? ;
Constant_or_routine = 'is' Feature_value ;
Feature_value = Manifest_constant ;
Feature_value = Unique ;
Feature_value = Routine ;
Unique = 'Unique' ;
New_feature_list = (New_feature ',')+ ;
New_feature = 'frozen'? Feature_name ;
Feature_name = Identifier ;
Feature_name = Prefix ;
Feature_name = Infix ;
Prefix = 'prefix' '"' Prefix_operator '"' ;
Infix = 'infix' '"' Infix_operator '"' ;
Prefix_operator = Unary ;
Prefix_operator = Free_operator ;
Infix_operator = Binary ;
Infix_operator = Free_operator ;
Unary = 'not' ;
Unary = '+' ;
Unary = '-' ;
Binary = '+' ;
Binary = '-' ;
Binary = '*' ;
Binary = '/' ;
Binary = '<' ;
Binary = '>' ;
Binary = '<=' ;
Binary = '>=' ;
Binary = '//' ;
Binary = '\\' ;
Binary = '^' ;
Binary = 'and' ;
Binary = 'or' ;
Binary = 'xor' ;
Binary = 'and' 'then' ;
Binary = 'or' 'else' ;
Binary = 'implies' ;
Formal_arguments = '(' Entity_declaration_list ')' ;
Entity_declaration_list = (Entity_declaration_group ';')* ;
Entity_declaration_group = Identifier_list Type_mark ;
Identifier_list = (Identifier ',')+ ;
Type_mark = ':' Type ;
Routine = Obsolete? Header_comment? Precondition? Local_declarations? Routine_body Postcondition? Rescue? 'end' ('--' Feature_name)? ;
Routine_body = Effective ;
Routine_body = Deferred ;
Effective = Internal ;
Effective = External ;
Internal = Routine_mark Compound ;
Routine_mark = 'do' ;
Routine_mark = 'once' ;
Deferred = 'deferred' ;
External = 'external' Language_name External_name? ;
Language_name = Manifest_string ;
External_name = 'alias' Manifest_string ;
Local_declarations = 'local' Entity_declaration_list ;
Precondition = 'require' 'else'? Assertion ;
Postcondition = 'ensure' 'then'? Assertion ;
Invariant = 'invariant' Assertion ;
Assertion = (Assertion_clause ';')* ;
Assertion_clause = Tag_mark? Unlabeled_assertion_clause ;
Unlabeled_assertion_clause = Boolean_expression ;
Unlabeled_assertion_clause = Comment ;
Tag_mark = Tag ':' ;
Tag = Identifier ;
Rescue = 'rescue' Compound ;
Type = Class_type ;
Type = Class_type_expanded ;
Type = Class_type_separate ;
Type = Anchored ;
Type = Bit_type ;
Class_type = Class_name Actual_generics? ;
Actual_generics = Type_list? ;
Type_list = (Type ',')* ;
Class_type_expanded = 'expanded' Class_type ;
Class_type_separate = 'separate' Class_type ;
Bit_type = 'BIT' Bit_length ;
Bit_length = Integer_constant ;
Bit_length = Attribute ;
Anchored = 'like' Anchor ;
Anchor = Identifier ;
Anchor = 'Current' ;
Compound = (Instruction ';')* ;
Instruction = Creation ;
Instruction = Call ;
Instruction = Assignment ;
Instruction = Assignment_attempt ;
Instruction = Conditional ;
Instruction = Multi_branch ;
Instruction = Loop ;
Instruction = Debug ;
Instruction = Check ;
Instruction = Retry ;
Instruction = Null_instruction ;
Creation = '!' Type? '!' Writable Creation_call? ;
Creation_call = '.' Procedure_name Actuals? ;
Assignment = Writable ':=' Expression ;
Assignment_attempt = Writable '?=' Expression ;
Conditional = 'if' Then_part_list Else_part? 'end' ;
Then_part_list = (Then_part 'elseif')+ ;
Then_part = Boolean_expression 'then' Compound ;
Else_part = 'else' Compound ;
Multi_branch = 'inspect' Expression When_part_list? Else_part? 'end' ;
When_part_list = 'when' (When_part 'when')+ ;
When_part = Choices 'then' Compound ;
Choices = (Choice ',')* ;
Choice = Choice_constant ;
Choice = Interval ;
Interval = Choice_constant '..' Choice_constant ;
Choice_constant = Integer_constant ;
Choice_constant = Character_constant ;
Choice_constant = Attribute ;
Loop = Initialization Invariant? Variant? Loop_body 'end' ;
Initialization = 'from' Compound ;
Variant = 'variant' Tag_mark? Expression ;
Loop_body = Exit 'loop' Compound ;
Exit = 'until' Boolean_expression ;
Debug = 'debug' Debug_keys? Compound 'end' ;
Debug_keys = '(' Debug_key_list ')' ;
Debug_key_list = (Debug_key ',')* ;
Debug_key = Manifest_string ;
Check = 'check' Assertion 'end' ;
Retry = 'retry' ;
Null_instruction = ;
Call = Qualified_call ;
Call = Precursor ;
Qualified_call = Call_qualifier? Call_chain ;
Call_qualifier = Call_target '.' ;
Call_target = Parenthesized ;
Call_target = 'Result' ;
Call_target = 'Current' ;
Call_target = Precursor ;
Call_chain = (Unqualified_call '.')+ ;
Unqualified_call = Identifier Actuals? ;
Precursor = Parent_qualification? 'Precursor' Actuals? ;
Parent_qualification = '{' Class_name '}' ;
Attribute = Identifier ;
Writable = Identifier ;
Writable = 'Result' ;
Actuals = '(' Actual_list ')' ;
Actual_list = (Actual ',')* ;
Actual = Expression ;
Actual = Address ;
Address = '$' Address_mark ;
Address_mark = Feature_name ;
Address_mark = 'Current' ;
Address_mark = 'Result' ;
Expression = 'Current' ;
Expression = 'Result' ;
Expression = Call ;
Expression = Operator_expression ;
Expression = Equality ;
Expression = Manifest_array ;
Expression = Old ;
Expression = Strip ;
Expression = Boolean_constant ;
Expression = Bit_constant ;
Expression = Integer ;
Expression = Real ;
Expression = Manifest_string ;
Expression = Character_constant ;
Expression = Wide_character_constant ;
Expression = Wide_manifest_string ;
Expression = Hexadecimal_constant ;
Boolean_expression = Expression ;
Operator_expression = Parenthesized ;
Operator_expression = Unary_expression ;
Operator_expression = Binary_expression ;
Parenthesized = '(' Expression ')' ;
Unary_expression = Prefix_operator Expression ;
Binary_expression = Expression Infix_operator Expression ;
Equality = Expression Comparison Expression ;
Comparison = '=' ;
Comparison = '/=' ;
Manifest_constant = Boolean_constant ;
Manifest_constant = Character_constant ;
Manifest_constant = Integer_constant ;
Manifest_constant = Real_constant ;
Manifest_constant = Manifest_string ;
Manifest_constant = Bit_constant ;
Manifest_constant = Wide_character_constant ;
Manifest_constant = Wide_manifest_string ;
Manifest_constant = Hexadecimal_constant ;
Boolean_constant = 'True' ;
Boolean_constant = 'False' ;
Integer_constant = Sign? Integer ;
Real_constant = Sign? Real ;
Sign = '+' ;
Sign = '-' ;
Wide_character_constant = '$' Character_constant ;
Wide_manifest_string = '$' Manifest_string ;
Manifest_array = '<<' Expression_list '>>' ;
Expression_list = (Expression ',')* ;
Old = 'old' Expression ;
Strip = 'Strip' '(' Attribute_list ')' ;
Attribute_list = (Attribute ',')* ;
Identifier = Letter (Letter | Decimal_digit | '_')* ;
Integer = Decimal_digit+ ;
Integer = Decimal_digit (Decimal_digit Decimal_digit?)? ('_' Decimal_digit Decimal_digit Decimal_digit)+ ;
