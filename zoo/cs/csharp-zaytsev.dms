ref-or-out = 'ref' ;
ref-or-out = 'out' ;
expression-unary-operator = lex-csharp-extra/plus ;
expression-unary-operator = lex-csharp-extra/minus ;
expression-unary-operator = increment-decrement ;
expression-unary-operator = '!' ;
expression-unary-operator = '~' ;
expression-unary-operator = '*' ;
increment-decrement = '++' ;
increment-decrement = '--' ;
expression-shift-operator = '<<' ;
expression-shift-operator = '>>' ;
expression-relational-operator = lex-csharp-extra/less-than ;
expression-relational-operator = lex-csharp-extra/greater-than ;
expression-relational-operator = '<=' ;
expression-relational-operator = '>=' ;
expression-relational-operator = 'is' ;
expression-relational-operator = 'as' ;
expression-equality-operator = '==' ;
expression-equality-operator = '!=' ;
conversion-kind = 'implicit' ;
conversion-kind = 'explicit' ;
maybe-empty-block = '{' statement* '}' ;
maybe-empty-block = ';' ;
built-in-type = integral-type ;
built-in-type = built-in-class-type ;
built-in-type = 'bool' ;
built-in-type = 'decimal' ;
built-in-type = 'float' ;
built-in-type = 'double' ;
built-in-class-type = 'object' ;
built-in-class-type = 'string' ;
else-part = 'else' embedded-statement ;
qualified-identifier-list = '{' qualified-identifier ',' '}'+ ;
compilation-unit = using-directive* global-attributes namespace-member-declaration* ;
type = non-array-type rank-specifier* ;
integral-type = 'sbyte' ;
integral-type = 'byte' ;
integral-type = 'short' ;
integral-type = 'ushort' ;
integral-type = 'int' ;
integral-type = 'uint' ;
integral-type = 'long' ;
integral-type = 'ulong' ;
integral-type = 'char' ;
argument-list = '{' argument ',' '}'* ;
argument = ref-or-out? expression ;
primary-expression = 'new' non-array-type '[' expression-list ']' rank-specifier* array-initializer? ;
primary-expression = 'new' array-type array-initializer ;
primary-expression = lex-csharp/literal ;
primary-expression = lex-csharp/identifier ;
primary-expression = '(' expression ')' ;
primary-expression = primary-expression '.' lex-csharp/identifier ;
primary-expression = predefined-type '.' lex-csharp/identifier ;
primary-expression = primary-expression '(' argument-list ')' ;
primary-expression = primary-expression '[' expression-list ']' ;
primary-expression = 'this' ;
primary-expression = 'base' '.' lex-csharp/identifier ;
primary-expression = 'base' '[' expression-list ']' ;
primary-expression = primary-expression increment-decrement ;
primary-expression = 'new' type '(' argument-list ')' ;
primary-expression = 'typeof' '(' type-or-void ')' ;
primary-expression = 'checked' '(' expression ')' ;
primary-expression = 'unchecked' '(' expression ')' ;
predefined-type = 'bool' ;
predefined-type = 'byte' ;
predefined-type = 'char' ;
predefined-type = 'decimal' ;
predefined-type = 'double' ;
predefined-type = 'float' ;
predefined-type = 'int' ;
predefined-type = 'long' ;
predefined-type = 'object' ;
predefined-type = 'sbyte' ;
predefined-type = 'short' ;
predefined-type = 'string' ;
predefined-type = 'uint' ;
predefined-type = 'ulong' ;
predefined-type = 'ushort' ;
expression-list = '{' expression ',' '}'+ ;
unary-expression = expression-unary-operator unary-expression ;
unary-expression = '(' type ')' unary-expression ;
unary-expression = primary-expression ;
assignment-operator = '=' ;
assignment-operator = '+=' ;
assignment-operator = '-=' ;
assignment-operator = '*=' ;
assignment-operator = '/=' ;
assignment-operator = '%=' ;
assignment-operator = '&=' ;
assignment-operator = '|=' ;
assignment-operator = '^=' ;
assignment-operator = '<<=' ;
assignment-operator = '>>=' ;
expression = expression '?' expression ':' expression ;
expression = expression '||' expression ;
expression = expression '&&' expression ;
expression = expression lex-csharp-extra/bar expression ;
expression = expression '^' expression ;
expression = expression lex-csharp-extra/ampersand expression ;
expression = expression expression-equality-operator expression ;
expression = expression expression-relational-operator expression ;
expression = expression 'is' built-in-type ;
expression = expression expression-shift-operator expression ;
expression = expression lex-csharp-extra/plus expression ;
expression = expression lex-csharp-extra/minus expression ;
expression = expression '*' expression ;
expression = expression '/' expression ;
expression = expression '%' expression ;
expression = unary-expression ;
expression = unary-expression assignment-operator expression ;
statement = labeled-statement ;
statement = declaration-statement ;
statement = embedded-statement ;
embedded-statement = maybe-empty-block ;
embedded-statement = statement-expression ';' ;
embedded-statement = selection-statement ;
embedded-statement = iteration-statement ;
embedded-statement = jump-statement ;
embedded-statement = try-statement ;
embedded-statement = 'checked' block ;
embedded-statement = 'unchecked' block ;
embedded-statement = lock-statement ;
embedded-statement = using-statement ;
block = '{' statement* '}' ;
labeled-statement = lex-csharp/identifier ':' statement ;
declaration-statement = local-variable-declaration ';' ;
declaration-statement = local-constant-declaration ';' ;
local-variable-declaration = type '{' variable-declarator ',' '}'+ ;
local-constant-declaration = 'const' type '{' constant-declarator ',' '}'+ ;
constant-declarator = lex-csharp/identifier '=' expression ;
statement-expression = primary-expression '(' argument-list ')' ;
statement-expression = 'new' type '(' argument-list ')' ;
statement-expression = unary-expression assignment-operator expression ;
statement-expression = primary-expression increment-decrement ;
statement-expression = increment-decrement primary-expression ;
selection-statement = if-statement ;
selection-statement = switch-statement ;
if-statement = 'if' '(' expression ')' embedded-statement else-part? ;
switch-statement = 'switch' '(' expression ')' '{' switch-section* '}' ;
switch-section = switch-label+ statement+ ;
switch-label = 'case' expression ':' ;
switch-label = 'default' ':' ;
iteration-statement = while-statement ;
iteration-statement = do-statement ;
iteration-statement = for-statement ;
iteration-statement = foreach-statement ;
while-statement = 'while' '(' expression ')' embedded-statement ;
do-statement = 'do' embedded-statement 'while' '(' expression ')' ';' ;
for-statement = 'for' '(' for-initializer? ';' expression? ';' statement-expression-list? ')' embedded-statement ;
for-initializer = local-variable-declaration ;
for-initializer = statement-expression-list ;
statement-expression-list = '{' statement-expression ',' '}'+ ;
foreach-statement = 'foreach' '(' type lex-csharp/identifier 'in' expression ')' embedded-statement ;
jump-statement = break-statement ;
jump-statement = continue-statement ;
jump-statement = goto-statement ;
jump-statement = return-statement ;
jump-statement = throw-statement ;
break-statement = 'break' ';' ;
continue-statement = 'continue' ';' ;
goto-statement = 'goto' lex-csharp/identifier ';' ;
goto-statement = 'goto' 'case' expression ';' ;
goto-statement = 'goto' 'default' ';' ;
return-statement = 'return' expression? ';' ;
throw-statement = 'throw' expression? ';' ;
try-statement = 'try' block catch-clauses finally-clause? ;
try-statement = 'try' block finally-clause ;
catch-clauses = specific-catch-clause+ general-catch-clause? ;
catch-clauses = specific-catch-clause* general-catch-clause ;
specific-catch-clause = 'catch' '(' built-in-class-type lex-csharp/identifier? ')' block ;
specific-catch-clause = 'catch' '(' qualified-identifier lex-csharp/identifier? ')' block ;
general-catch-clause = 'catch' block ;
finally-clause = 'finally' block ;
lock-statement = 'lock' '(' expression ')' embedded-statement ;
using-statement = 'using' '(' resource-acquisition ')' embedded-statement ;
resource-acquisition = local-variable-declaration ;
resource-acquisition = expression ;
namespace-declaration = 'namespace' qualified-identifier namespace-body ';'? ;
qualified-identifier = '{' lex-csharp/identifier '.' '}'+ ;
namespace-body = '{' using-directive* namespace-member-declaration* '}' ;
using-directive = 'using' '(' lex-csharp/identifier '=' ')'? qualified-identifier ';' ;
namespace-member-declaration = namespace-declaration ;
namespace-member-declaration = type-declaration ;
type-declaration = class-declaration ;
type-declaration = struct-declaration ;
type-declaration = interface-declaration ;
type-declaration = enum-declaration ;
type-declaration = delegate-declaration ;
class-declaration = attributes class-modifier* 'class' lex-csharp/identifier class-base? class-body ';'? ;
class-modifier = 'new' ;
class-modifier = 'public' ;
class-modifier = 'protected' ;
class-modifier = 'internal' ;
class-modifier = 'private' ;
class-modifier = 'abstract' ;
class-modifier = 'sealed' ;
class-base = ':' qualified-identifier-list ;
class-base = ':' built-in-class-type '(' ',' qualified-identifier-list ')'? ;
class-body = '{' class-member-declaration* '}' ;
class-member-declaration = constant-declaration ;
class-member-declaration = field-declaration ;
class-member-declaration = method-declaration ;
class-member-declaration = property-declaration ;
class-member-declaration = event-declaration ;
class-member-declaration = indexer-declaration ;
class-member-declaration = operator-declaration ;
class-member-declaration = constructor-declaration ;
class-member-declaration = destructor-declaration ;
class-member-declaration = static-constructor-declaration ;
class-member-declaration = type-declaration ;
constant-declaration = attributes constant-modifier* 'const' type '{' constant-declarator ',' '}'+ ';' ;
constant-modifier = 'new' ;
constant-modifier = 'public' ;
constant-modifier = 'protected' ;
constant-modifier = 'internal' ;
constant-modifier = 'private' ;
field-declaration = attributes field-modifier* type '{' variable-declarator ',' '}'+ ';' ;
field-modifier = 'new' ;
field-modifier = 'public' ;
field-modifier = 'protected' ;
field-modifier = 'internal' ;
field-modifier = 'private' ;
field-modifier = 'static' ;
field-modifier = 'readonly' ;
field-modifier = 'volatile' ;
variable-declarator = lex-csharp/identifier ;
variable-declarator = lex-csharp/identifier '=' variable-initializer ;
method-declaration = method-header maybe-empty-block ;
method-header = attributes method-modifier* type-or-void qualified-identifier '(' formal-parameter-list? ')' ;
method-modifier = 'new' ;
method-modifier = 'public' ;
method-modifier = 'protected' ;
method-modifier = 'internal' ;
method-modifier = 'private' ;
method-modifier = 'static' ;
method-modifier = 'virtual' ;
method-modifier = 'sealed' ;
method-modifier = 'override' ;
method-modifier = 'abstract' ;
method-modifier = 'extern' ;
type-or-void = type ;
type-or-void = 'void' ;
formal-parameter-list = fixed-parameters ;
formal-parameter-list = fixed-parameters ',' parameter-array ;
formal-parameter-list = parameter-array ;
fixed-parameters = '{' fixed-parameter ',' '}'+ ;
fixed-parameter = attributes parameter-modifier? type lex-csharp/identifier ;
parameter-modifier = 'ref' ;
parameter-modifier = 'out' ;
parameter-array = attributes 'params' array-type lex-csharp/identifier ;
property-declaration = attributes property-modifier* type qualified-identifier '{' accessor-declarations '}' ;
property-modifier = 'new' ;
property-modifier = 'public' ;
property-modifier = 'protected' ;
property-modifier = 'internal' ;
property-modifier = 'private' ;
property-modifier = 'static' ;
property-modifier = 'virtual' ;
property-modifier = 'sealed' ;
property-modifier = 'override' ;
property-modifier = 'abstract' ;
property-modifier = 'extern' ;
accessor-declarations = get-accessor-declaration set-accessor-declaration? ;
accessor-declarations = set-accessor-declaration get-accessor-declaration? ;
get-accessor-declaration = attributes 'get' maybe-empty-block ;
set-accessor-declaration = attributes 'set' maybe-empty-block ;
event-declaration = attributes event-modifier* 'event' type '{' variable-declarator ',' '}'+ ';' ;
event-declaration = attributes event-modifier* 'event' type qualified-identifier '{' event-accessor-declarations '}' ;
event-modifier = 'new' ;
event-modifier = 'public' ;
event-modifier = 'protected' ;
event-modifier = 'internal' ;
event-modifier = 'private' ;
event-modifier = 'static' ;
event-modifier = 'virtual' ;
event-modifier = 'sealed' ;
event-modifier = 'override' ;
event-modifier = 'abstract' ;
event-modifier = 'extern' ;
event-accessor-declarations = add-accessor-declaration remove-accessor-declaration ;
event-accessor-declarations = remove-accessor-declaration add-accessor-declaration ;
add-accessor-declaration = attributes 'add' block ;
remove-accessor-declaration = attributes 'remove' block ;
indexer-declaration = attributes indexer-modifier* indexer-declarator '{' accessor-declarations '}' ;
indexer-modifier = 'new' ;
indexer-modifier = 'public' ;
indexer-modifier = 'protected' ;
indexer-modifier = 'internal' ;
indexer-modifier = 'private' ;
indexer-modifier = 'virtual' ;
indexer-modifier = 'sealed' ;
indexer-modifier = 'override' ;
indexer-modifier = 'abstract' ;
indexer-modifier = 'extern' ;
indexer-declarator = type 'this' '[' formal-parameter-list ']' ;
indexer-declarator = type qualified-identifier '.' 'this' '[' formal-parameter-list ']' ;
operator-declaration = attributes operator-modifier+ operator-declarator maybe-empty-block ;
operator-modifier = 'public' ;
operator-modifier = 'static' ;
operator-modifier = 'extern' ;
operator-declarator = unary-operator-declarator ;
operator-declarator = binary-operator-declarator ;
operator-declarator = conversion-operator-declarator ;
unary-operator-declarator = type 'operator' overloadable-unary-operator '(' type lex-csharp/identifier ')' ;
overloadable-unary-operator = lex-csharp-extra/plus ;
overloadable-unary-operator = lex-csharp-extra/minus ;
overloadable-unary-operator = increment-decrement ;
overloadable-unary-operator = '!' ;
overloadable-unary-operator = '~' ;
overloadable-unary-operator = 'true' ;
overloadable-unary-operator = 'false' ;
binary-operator-declarator = type 'operator' overloadable-binary-operator '(' type lex-csharp/identifier ',' type lex-csharp/identifier ')' ;
overloadable-binary-operator = lex-csharp-extra/plus ;
overloadable-binary-operator = lex-csharp-extra/minus ;
overloadable-binary-operator = '*' ;
overloadable-binary-operator = '/' ;
overloadable-binary-operator = '%' ;
overloadable-binary-operator = lex-csharp-extra/ampersand ;
overloadable-binary-operator = lex-csharp-extra/bar ;
overloadable-binary-operator = '^' ;
overloadable-binary-operator = '<<' ;
overloadable-binary-operator = '>>' ;
overloadable-binary-operator = '==' ;
overloadable-binary-operator = '!=' ;
overloadable-binary-operator = lex-csharp-extra/greater-than ;
overloadable-binary-operator = lex-csharp-extra/less-than ;
overloadable-binary-operator = '>=' ;
overloadable-binary-operator = '<=' ;
conversion-operator-declarator = conversion-kind 'operator' type '(' type lex-csharp/identifier ')' ;
constructor-declaration = attributes constructor-modifier* constructor-declarator maybe-empty-block ;
constructor-modifier = 'public' ;
constructor-modifier = 'protected' ;
constructor-modifier = 'internal' ;
constructor-modifier = 'private' ;
constructor-modifier = 'extern' ;
constructor-declarator = lex-csharp/identifier '(' formal-parameter-list? ')' constructor-initializer? ;
constructor-initializer = ':' 'base' '(' argument-list ')' ;
constructor-initializer = ':' 'this' '(' argument-list ')' ;
static-constructor-declaration = attributes static-constructor-modifiers lex-csharp/identifier '(' ')' maybe-empty-block ;
static-constructor-modifiers = 'extern'? 'static' ;
static-constructor-modifiers = 'static' 'extern' ;
destructor-declaration = attributes 'extern'? '~' lex-csharp/identifier '(' ')' maybe-empty-block ;
struct-declaration = attributes struct-modifier* 'struct' lex-csharp/identifier '(' ':' qualified-identifier-list ')'? struct-body ';'? ;
struct-modifier = 'new' ;
struct-modifier = 'public' ;
struct-modifier = 'protected' ;
struct-modifier = 'internal' ;
struct-modifier = 'private' ;
struct-body = '{' struct-member-declaration* '}' ;
struct-member-declarations = struct-member-declaration ;
struct-member-declarations = struct-member-declarations struct-member-declaration ;
struct-member-declaration = constant-declaration ;
struct-member-declaration = field-declaration ;
struct-member-declaration = method-declaration ;
struct-member-declaration = property-declaration ;
struct-member-declaration = event-declaration ;
struct-member-declaration = indexer-declaration ;
struct-member-declaration = operator-declaration ;
struct-member-declaration = constructor-declaration ;
struct-member-declaration = static-constructor-declaration ;
struct-member-declaration = type-declaration ;
array-type = non-array-type rank-specifier+ ;
non-array-type = qualified-identifier ;
non-array-type = built-in-type ;
rank-specifier = '[' ','* ']' ;
array-initializer = '{' '}' ;
array-initializer = '{' '{' variable-initializer ',' '}'+ ','? '}' ;
variable-initializer = expression ;
variable-initializer = array-initializer ;
interface-declaration = attributes interface-modifier* 'interface' lex-csharp/identifier '(' ':' qualified-identifier-list ')'? interface-body ';'? ;
interface-modifier = 'new' ;
interface-modifier = 'public' ;
interface-modifier = 'protected' ;
interface-modifier = 'internal' ;
interface-modifier = 'private' ;
interface-body = '{' interface-member-declaration* '}' ;
interface-member-declaration = interface-method-declaration ;
interface-member-declaration = interface-property-declaration ;
interface-member-declaration = interface-event-declaration ;
interface-member-declaration = interface-indexer-declaration ;
interface-method-declaration = attributes 'new'? type-or-void lex-csharp/identifier '(' formal-parameter-list? ')' ';' ;
interface-property-declaration = attributes 'new'? type lex-csharp/identifier '{' interface-accessors '}' ;
interface-accessors = attributes 'get' ';' '(' attributes 'set' ';' ')'? ;
interface-accessors = attributes 'set' ';' '(' attributes 'get' ';' ')'? ;
interface-event-declaration = attributes 'new'? 'event' type lex-csharp/identifier ';' ;
interface-indexer-declaration = attributes 'new'? type 'this' '[' formal-parameter-list ']' '{' interface-accessors '}' ;
enum-declaration = attributes enum-modifier* 'enum' lex-csharp/identifier '(' ':' integral-type ')'? enum-body ';'? ;
enum-body = '{' '}' ;
enum-body = '{' '{' enum-member-declaration ',' '}'+ ','? '}' ;
enum-modifier = 'new' ;
enum-modifier = 'public' ;
enum-modifier = 'protected' ;
enum-modifier = 'internal' ;
enum-modifier = 'private' ;
enum-member-declaration = attributes lex-csharp/identifier '(' '=' expression ')'? ;
delegate-declaration = attributes delegate-modifier* 'delegate' type-or-void lex-csharp/identifier '(' formal-parameter-list? ')' ';' ;
delegate-modifier = 'new' ;
delegate-modifier = 'public' ;
delegate-modifier = 'protected' ;
delegate-modifier = 'internal' ;
delegate-modifier = 'private' ;
global-attributes = global-attribute-section* ;
global-attribute-section = '[' 'assembly' ':' attribute-list ','? ']' ;
attributes = attribute-section* ;
attribute-section = '[' '(' attribute-target ':' ')'? attribute-list ','? ']' ;
attribute-target = 'field' ;
attribute-target = 'event' ;
attribute-target = 'method' ;
attribute-target = 'module' ;
attribute-target = 'param' ;
attribute-target = 'property' ;
attribute-target = 'return' ;
attribute-target = 'type' ;
attribute-list = '{' attribute ',' '}'+ ;
attribute = attribute-name attribute-arguments? ;
attribute-name = qualified-identifier ;
attribute-arguments = '(' expression-list? ')' ;
