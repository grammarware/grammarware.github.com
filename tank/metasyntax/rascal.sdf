module Main

exports
 context-free start-symbols Module
  sorts
        Module Header Tags Tag Expression Statement Label Visit Strategy Case PatternWithAction Pattern QualifiedName Literal IntegerLiteral StringLiteral StringTemplate StringMiddle StringTail DateTimeLiteral LocationLiteral ProtocolPart ProtocolTail PathPart PathTail Type UserType FunctionType TypeArg StructuredType BasicType DataTypeSelector TypeVar Symbol CharClass OptCharRanges CharRanges CharRange Character Mapping Replacement NoElseMayFollow Target Bound Catch Assignable Assignment DataTarget FunctionDeclaration Visibility Signature FunctionModifiers FunctionModifier Parameters Formals Formal FunctionBody LocalVariableDeclaration Declarator Variable Comprehension Field ModuleParameters Import ImportedModule ModuleActuals Renamings Renaming SyntaxDefinition Sym Class Range Prod LanguageAction ProdModifier Assoc Start Body Toplevel Declaration Alternative Kind Variant Test PreModule Rest Command ShellCommand 
  context-free syntax
        header::Header body::Body -> Module {cons(Default)}

        tags::Tags "module" name::QualifiedName params::ModuleParameters imports::(Import*) -> Header {cons(Parameters)}

        tags::Tags "module" name::QualifiedName imports::(Import*) -> Header {cons(Default)}

        tags::(Tag*) -> Tags {cons(Default)}

        "@" name::Name contents::TagString -> Tag {cons(Default)}

        "@" name::Name -> Tag {cons(Empty)}

        "@" name::Name "=" expression::Expression -> Tag {cons(Expression)}

        "{" statements::(Statement+) "}" -> Expression {cons(NonEmptyBlock)}

        "(" expression::Expression ")" -> Expression {cons(Bracket)}

        type::Type parameters::Parameters "{" statements::(Statement+) "}" -> Expression {cons(Closure)}

        "[" first::Expression "," second::Expression ".." last::Expression "]" -> Expression {cons(StepRange)}

        parameters::Parameters "{" statements::(Statement*) "}" -> Expression {cons(VoidClosure)}

        label::Label visit::Visit -> Expression {cons(Visit)}

        "(" init::Expression "|" result::Expression "|" generators::(Expression ("," Expression)*) ")" -> Expression {cons(Reducer)}

        basicType::BasicType "(" arguments::((Expression ("," Expression)*)?) ")" -> Expression {cons(ReifiedType)}

        expression::Expression "(" arguments::((Expression ("," Expression)*)?) ")" -> Expression {cons(CallOrTree)}

        literal::Literal -> Expression {cons(Literal)}

        "any" "(" generators::(Expression ("," Expression)*) ")" -> Expression {cons(Any)}

        "all" "(" generators::(Expression ("," Expression)*) ")" -> Expression {cons(All)}

        comprehension::Comprehension -> Expression {cons(Comprehension)}

        "{" elements::((Expression ("," Expression)*)?) "}" -> Expression {cons(Set)}

        "[" elements::((Expression ("," Expression)*)?) "]" -> Expression {cons(List)}

        "#" type::Type -> Expression {cons(ReifyType)}

        "[" first::Expression ".." last::Expression "]" -> Expression {cons(Range)}

        "<" elements::(Expression ("," Expression)*) ">" -> Expression {cons(Tuple)}

        "(" mappings::((Mapping ("," Mapping)*)?) ")" -> Expression {cons(Map)}

        "it" -> Expression {cons(It)}

        qualifiedName::QualifiedName -> Expression {cons(QualifiedName)}

        expression::Expression "[" subscripts::(Expression ("," Expression)*) "]" -> Expression {cons(Subscript)}

        expression::Expression "." field::Name -> Expression {cons(FieldAccess)}

        expression::Expression "[" key::Name "=" replacement::Expression "]" -> Expression {cons(FieldUpdate)}

        expression::Expression "<" fields::(Field ("," Field)*) ">" -> Expression {cons(FieldProject)}

        argument::Expression "?" -> Expression {cons(IsDefined)}

        "!" argument::Expression -> Expression {cons(Negation)}

        "-" argument::Expression -> Expression {cons(Negative)}

        argument::Expression "+" -> Expression {cons(TransitiveClosure)}

        argument::Expression "*" -> Expression {cons(TransitiveReflexiveClosure)}

        expression::Expression "[" "@" name::Name "=" value::Expression "]" -> Expression {cons(SetAnnotation)}

        expression::Expression "@" name::Name -> Expression {cons(GetAnnotation)}

        lhs::Expression "o" rhs::Expression -> Expression {cons(Composition)}

        lhs::Expression "*" rhs::Expression -> Expression {cons(Product)}

        lhs::Expression "join" rhs::Expression -> Expression {cons(Join)}

        lhs::Expression "%" rhs::Expression -> Expression {cons(Modulo)}

        lhs::Expression "/" rhs::Expression -> Expression {cons(Division)}

        lhs::Expression "&" rhs::Expression -> Expression {cons(Intersection)}

        lhs::Expression "+" rhs::Expression -> Expression {cons(Addition)}

        lhs::Expression "-" rhs::Expression -> Expression {cons(Subtraction)}

        lhs::Expression "notin" rhs::Expression -> Expression {cons(NotIn)}

        lhs::Expression "in" rhs::Expression -> Expression {cons(In)}

        lhs::Expression ">=" rhs::Expression -> Expression {cons(GreaterThanOrEq)}

        lhs::Expression "<=" rhs::Expression -> Expression {cons(LessThanOrEq)}

        lhs::Expression "<" rhs::Expression -> Expression {cons(LessThan)}

        lhs::Expression ">" rhs::Expression -> Expression {cons(GreaterThan)}

        condition::Expression "?" thenExp::Expression ":" elseExp::Expression -> Expression {cons(IfThenElse)}

        lhs::Expression "==" rhs::Expression -> Expression {cons(Equals)}

        lhs::Expression "!=" rhs::Expression -> Expression {cons(NonEquals)}

        lhs::Expression "?" rhs::Expression -> Expression {cons(IfDefinedOtherwise)}

        pattern::Pattern "!:=" expression::Expression -> Expression {cons(NoMatch)}

        pattern::Pattern ":=" expression::Expression -> Expression {cons(Match)}

        pattern::Pattern "<-" expression::Expression -> Expression {cons(Enumerator)}

        lhs::Expression "==>" rhs::Expression -> Expression {cons(Implication)}

        lhs::Expression "<==>" rhs::Expression -> Expression {cons(Equivalence)}

        lhs::Expression "&&" rhs::Expression -> Expression {cons(And)}

        lhs::Expression "||" rhs::Expression -> Expression {cons(Or)}

        "assert" expression::Expression ";" -> Statement {cons(Assert)}

        "assert" expression::Expression ":" message::Expression ";" -> Statement {cons(AssertWithMessage)}

        expression::Expression ";" -> Statement {cons(Expression)}

        label::Label visit::Visit -> Statement {cons(Visit)}

        label::Label "while" "(" conditions::(Expression ("," Expression)*) ")" body::Statement -> Statement {cons(While)}

        label::Label "do" body::Statement "while" "(" condition::Expression ")" ";" -> Statement {cons(DoWhile)}

        label::Label "for" "(" generators::(Expression ("," Expression)*) ")" body::Statement -> Statement {cons(For)}

        label::Label "if" "(" conditions::(Expression ("," Expression)*) ")" thenStatement::Statement noElseMayFollow::NoElseMayFollow -> Statement {cons(IfThen)}

        label::Label "if" "(" conditions::(Expression ("," Expression)*) ")" thenStatement::Statement "else" elseStatement::Statement -> Statement {cons(IfThenElse)}

        label::Label "switch" "(" expression::Expression ")" "{" cases::(Case+) "}" -> Statement {cons(Switch)}

        "fail" target::Target ";" -> Statement {cons(Fail)}

        "break" target::Target ";" -> Statement {cons(Break)}

        "continue" target::Target ";" -> Statement {cons(Continue)}

        "solve" "(" variables::(QualifiedName ("," QualifiedName)*) bound::Bound ")" body::Statement -> Statement {cons(Solve)}

        "try" body::Statement handlers::(Catch+) -> Statement {cons(Try)}

        "try" body::Statement handlers::(Catch+) "finally" finallyBody::Statement -> Statement {cons(TryFinally)}

        label::Label "{" statements::(Statement+) "}" -> Statement {cons(NonEmptyBlock)}

        ";" -> Statement {cons(EmptyStatement)}

        "global" type::Type names::(QualifiedName ("," QualifiedName)*) ";" -> Statement {cons(GlobalDirective)}

        assignable::Assignable operator::Assignment statement::Statement -> Statement {cons(Assignment)}

        "return" statement::Statement -> Statement {cons(Return)}

        "throw" statement::Statement -> Statement {cons(Throw)}

        "insert" dataTarget::DataTarget statement::Statement -> Statement {cons(Insert)}

        "append" dataTarget::DataTarget statement::Statement -> Statement {cons(Append)}

        functionDeclaration::FunctionDeclaration -> Statement {cons(FunctionDeclaration)}

        declaration::LocalVariableDeclaration ";" -> Statement {cons(VariableDeclaration)}

        name::Name ":" -> Label {cons(Default)}

         -> Label {cons(Empty)}

        strategy::Strategy "visit" "(" subject::Expression ")" "{" cases::(Case+) "}" -> Visit {cons(GivenStrategy)}

        "visit" "(" subject::Expression ")" "{" cases::(Case+) "}" -> Visit {cons(DefaultStrategy)}

        "top-down-break" -> Strategy {cons(TopDownBreak)}

        "top-down" -> Strategy {cons(TopDown)}

        "bottom-up" -> Strategy {cons(BottomUp)}

        "bottom-up-break" -> Strategy {cons(BottomUpBreak)}

        "outermost" -> Strategy {cons(Outermost)}

        "innermost" -> Strategy {cons(Innermost)}

        "case" patternWithAction::PatternWithAction -> Case {cons(PatternWithAction)}

        "default" ":" statement::Statement -> Case {cons(Default)}

        pattern::Pattern "=>" replacement::Replacement -> PatternWithAction {cons(Replacing)}

        pattern::Pattern ":" statement::Statement -> PatternWithAction {cons(Arbitrary)}

        "{" elements::((Pattern ("," Pattern)*)?) "}" -> Pattern {cons(Set)}

        "[" elements::((Pattern ("," Pattern)*)?) "]" -> Pattern {cons(List)}

        qualifiedName::QualifiedName -> Pattern {cons(QualifiedName)}

        qualifiedName::QualifiedName "*" -> Pattern {cons(MultiVariable)}

        literal::Literal -> Pattern {cons(Literal)}

        "<" elements::(Pattern ("," Pattern)*) ">" -> Pattern {cons(Tuple)}

        type::Type name::Name -> Pattern {cons(TypedVariable)}

        "(" mappings::((Mapping ("," Mapping)*)?) ")" -> Pattern {cons(Map)}

        basicType::BasicType "(" arguments::((Pattern ("," Pattern)*)?) ")" -> Pattern {cons(ReifiedType)}

        expression::Pattern "(" arguments::((Pattern ("," Pattern)*)?) ")" -> Pattern {cons(CallOrTree)}

        name::Name ":" pattern::Pattern -> Pattern {cons(VariableBecomes)}

        "[" type::Type "]" pattern::Pattern -> Pattern {cons(Guarded)}

        "/" pattern::Pattern -> Pattern {cons(Descendant)}

        "!" pattern::Pattern -> Pattern {cons(Anti)}

        type::Type name::Name ":" pattern::Pattern -> Pattern {cons(TypedVariableBecomes)}

        names::(Name ("::" Name)*) -> QualifiedName {cons(Default)}

        integerLiteral::IntegerLiteral -> Literal {cons(Integer)}

        regExpLiteral::RegExpLiteral -> Literal {cons(RegExp)}

        realLiteral::RealLiteral -> Literal {cons(Real)}

        booleanLiteral::BooleanLiteral -> Literal {cons(Boolean)}

        stringLiteral::StringLiteral -> Literal {cons(String)}

        dateTimeLiteral::DateTimeLiteral -> Literal {cons(DateTime)}

        locationLiteral::LocationLiteral -> Literal {cons(Location)}

        decimal::DecimalIntegerLiteral -> IntegerLiteral {cons(DecimalIntegerLiteral)}

        hex::HexIntegerLiteral -> IntegerLiteral {cons(HexIntegerLiteral)}

        octal::OctalIntegerLiteral -> IntegerLiteral {cons(OctalIntegerLiteral)}

        pre::PreStringChars template::StringTemplate tail::StringTail -> StringLiteral {cons(Template)}

        pre::PreStringChars expression::Expression tail::StringTail -> StringLiteral {cons(Interpolated)}

        constant::StringConstant -> StringLiteral {cons(NonInterpolated)}

        "if" "(" conditions::(Expression ("," Expression)*) ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}" -> StringTemplate {cons(IfThen)}

        "if" "(" conditions::(Expression ("," Expression)*) ")" "{" preStatsThen::(Statement*) thenString::StringMiddle postStatsThen::(Statement*) "}" "else" "{" preStatsElse::(Statement*) elseString::StringMiddle postStatsElse::(Statement*) "}" -> StringTemplate {cons(IfThenElse)}

        "for" "(" generators::(Expression ("," Expression)*) ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}" -> StringTemplate {cons(For)}

        "do" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}" "while" "(" condition::Expression ")" -> StringTemplate {cons(DoWhile)}

        "while" "(" condition::Expression ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}" -> StringTemplate {cons(While)}

        mid::MidStringChars -> StringMiddle {cons(Mid)}

        mid::MidStringChars template::StringTemplate tail::StringMiddle -> StringMiddle {cons(Template)}

        mid::MidStringChars expression::Expression tail::StringMiddle -> StringMiddle {cons(Interpolated)}

        mid::MidStringChars expression::Expression tail::StringTail -> StringTail {cons(MidInterpolated)}

        post::PostStringChars -> StringTail {cons(Post)}

        mid::MidStringChars template::StringTemplate tail::StringTail -> StringTail {cons(MidTemplate)}

        date::JustDate -> DateTimeLiteral {cons(DateLiteral)}

        time::JustTime -> DateTimeLiteral {cons(TimeLiteral)}

        dateAndTime::DateAndTime -> DateTimeLiteral {cons(DateAndTimeLiteral)}

        protocolPart::ProtocolPart pathPart::PathPart -> LocationLiteral {cons(Default)}

        protocolChars::ProtocolChars -> ProtocolPart {cons(NonInterpolated)}

        pre::PreProtocolChars expression::Expression tail::ProtocolTail -> ProtocolPart {cons(Interpolated)}

        mid::MidProtocolChars expression::Expression tail::ProtocolTail -> ProtocolTail {cons(Mid)}

        post::PostProtocolChars -> ProtocolTail {cons(Post)}

        pathChars::PathChars -> PathPart {cons(NonInterpolated)}

        pre::PrePathChars expression::Expression tail::PathTail -> PathPart {cons(Interpolated)}

        mid::MidPathChars expression::Expression tail::PathTail -> PathTail {cons(Mid)}

        post::PostPathChars -> PathTail {cons(Post)}

        "(" type::Type ")" -> Type {cons(Bracket)}

        user::UserType -> Type {cons(User)}

        function::FunctionType -> Type {cons(Function)}

        structured::StructuredType -> Type {cons(Structured)}

        basic::BasicType -> Type {cons(Basic)}

        selector::DataTypeSelector -> Type {cons(Selector)}

        typeVar::TypeVar -> Type {cons(Variable)}

        symbol::Symbol -> Type {cons(Symbol)}

        name::QualifiedName -> UserType {cons(Name)}

        name::QualifiedName "[" parameters::(Type ("," Type)*) "]" -> UserType {cons(Parametric)}

        type::Type "(" arguments::((TypeArg ("," TypeArg)*)?) ")" -> FunctionType {cons(TypeArguments)}

        type::Type -> TypeArg {cons(Default)}

        type::Type name::Name -> TypeArg {cons(Named)}

        basicType::BasicType "[" arguments::(TypeArg ("," TypeArg)*) "]" -> StructuredType {cons(Default)}

        "value" -> BasicType {cons(Value)}

        "loc" -> BasicType {cons(Loc)}

        "node" -> BasicType {cons(Node)}

        "num" -> BasicType {cons(Num)}

        "type" -> BasicType {cons(ReifiedType)}

        "bag" -> BasicType {cons(Bag)}

        "int" -> BasicType {cons(Int)}

        "rel" -> BasicType {cons(Relation)}

        "parameter" -> BasicType {cons(ReifiedTypeParameter)}

        "real" -> BasicType {cons(Real)}

        "fun" -> BasicType {cons(ReifiedFunction)}

        "tuple" -> BasicType {cons(Tuple)}

        "str" -> BasicType {cons(String)}

        "bool" -> BasicType {cons(Bool)}

        "reified" -> BasicType {cons(ReifiedReifiedType)}

        "void" -> BasicType {cons(Void)}

        "non-terminal" -> BasicType {cons(ReifiedNonTerminal)}

        "datetime" -> BasicType {cons(DateTime)}

        "set" -> BasicType {cons(Set)}

        "map" -> BasicType {cons(Map)}

        "constructor" -> BasicType {cons(ReifiedConstructor)}

        "list" -> BasicType {cons(List)}

        "adt" -> BasicType {cons(ReifiedAdt)}

        "lex" -> BasicType {cons(Lex)}

        sort::QualifiedName "." production::Name -> DataTypeSelector {cons(Selector)}

        "&" name::Name -> TypeVar {cons(Free)}

        "&" name::Name "<:" bound::Type -> TypeVar {cons(Bounded)}

        "{" symbol::Symbol sep::StrCon "}" "+" -> Symbol {cons(IterSep)}

        "{" symbol::Symbol sep::StrCon "}" "*" -> Symbol {cons(IterStarSep)}

        "(" head::Symbol tail::(Symbol+) ")" -> Symbol {cons(Sequence)}

        "(" ")" -> Symbol {cons(Empty)}

        singelQuotedString::SingleQuotedStrCon -> Symbol {cons(CaseInsensitiveLiteral)}

        string::StrCon -> Symbol {cons(Literal)}

        charClass::CharClass -> Symbol {cons(CharacterClass)}

        symbol::Symbol "?" -> Symbol {cons(Optional)}

        symbol::Symbol "+" -> Symbol {cons(Iter)}

        symbol::Symbol "*" -> Symbol {cons(IterStar)}

        name::QualifiedName -> Symbol {cons(Sort)}

        lhs::Symbol "|" rhs::Symbol -> Symbol {cons(Alternative)}

        "(" charClass::CharClass ")" -> CharClass {cons(Bracket)}

        "[" optionalCharRanges::OptCharRanges "]" -> CharClass {cons(SimpleCharclass)}

        "~" charClass::CharClass -> CharClass {cons(Complement)}

        lhs::CharClass "/" rhs::CharClass -> CharClass {cons(Difference)}

        lhs::CharClass "/\" rhs::CharClass -> CharClass {cons(Intersection)}

        lhs::CharClass "\/" rhs::CharClass -> CharClass {cons(Union)}

        ranges::CharRanges -> OptCharRanges {cons(Present)}

         -> OptCharRanges {cons(Absent)}

        lhs::CharRanges rhs::CharRanges -> CharRanges {cons(Concatenate)}

        range::CharRange -> CharRanges {cons(Range)}

        "(" ranges::CharRanges ")" -> CharRanges {cons(Bracket)}

        character::Character -> CharRange {cons(Character)}

        start::Character "-" end::Character -> CharRange {cons(Range)}

        numChar::NumChar -> Character {cons(Numeric)}

        "\EOF" -> Character {cons(EOF)}

        shortChar::ShortChar -> Character {cons(Short)}

        "\BOT" -> Character {cons(Bottom)}

        "\TOP" -> Character {cons(Top)}

        from::&T ":" to::&T -> Mapping {cons(Default)}

        replacementExpression::Expression -> Replacement {cons(Unconditional)}

        replacementExpression::Expression "when" conditions::(Expression ("," Expression)*) -> Replacement {cons(Conditional)}

         -> NoElseMayFollow {cons(Default)}

         -> Target {cons(Empty)}

        name::Name -> Target {cons(Labeled)}

        ";" expression::Expression -> Bound {cons(Default)}

         -> Bound {cons(Empty)}

        "catch" ":" body::Statement -> Catch {cons(Default)}

        "catch" pattern::Pattern ":" body::Statement -> Catch {cons(Binding)}

        "(" arg::Assignable ")" -> Assignable {cons(Bracket)}

        qualifiedName::QualifiedName -> Assignable {cons(Variable)}

        receiver::Assignable "[" subscript::Expression "]" -> Assignable {cons(Subscript)}

        receiver::Assignable "." field::Name -> Assignable {cons(FieldAccess)}

        receiver::Assignable "?" defaultExpression::Expression -> Assignable {cons(IfDefinedOrDefault)}

        name::Name "(" arguments::(Assignable ("," Assignable)*) ")" -> Assignable {cons(Constructor)}

        "<" elements::(Assignable ("," Assignable)*) ">" -> Assignable {cons(Tuple)}

        receiver::Assignable "@" annotation::Name -> Assignable {cons(Annotation)}

        "?=" -> Assignment {cons(IfDefined)}

        "/=" -> Assignment {cons(Division)}

        "*=" -> Assignment {cons(Product)}

        "&=" -> Assignment {cons(Intersection)}

        "-=" -> Assignment {cons(Subtraction)}

        "=" -> Assignment {cons(Default)}

        "+=" -> Assignment {cons(Addition)}

         -> DataTarget {cons(Empty)}

        label::Name ":" -> DataTarget {cons(Labeled)}

        tags::Tags visibility::Visibility signature::Signature ";" -> FunctionDeclaration {cons(Abstract)}

        tags::Tags visibility::Visibility signature::Signature body::FunctionBody -> FunctionDeclaration {cons(Default)}

        "private" -> Visibility {cons(Private)}

         -> Visibility {cons(Default)}

        "public" -> Visibility {cons(Public)}

        type::Type modifiers::FunctionModifiers name::Name parameters::Parameters "throws" exceptions::(Type ("," Type)*) -> Signature {cons(WithThrows)}

        type::Type modifiers::FunctionModifiers name::Name parameters::Parameters -> Signature {cons(NoThrows)}

        modifiers::(FunctionModifier*) -> FunctionModifiers {cons(List)}

        "java" -> FunctionModifier {cons(Java)}

        "(" formals::Formals ")" -> Parameters {cons(Default)}

        "(" formals::Formals "..." ")" -> Parameters {cons(VarArgs)}

        formals::((Formal ("," Formal)*)?) -> Formals {cons(Default)}

        type::Type name::Name -> Formal {cons(TypeName)}

        "{" statements::(Statement*) "}" -> FunctionBody {cons(Default)}

        declarator::Declarator -> LocalVariableDeclaration {cons(Default)}

        "dynamic" declarator::Declarator -> LocalVariableDeclaration {cons(Dynamic)}

        type::Type variables::(Variable ("," Variable)*) -> Declarator {cons(Default)}

        name::Name "=" initial::Expression -> Variable {cons(Initialized)}

        name::Name -> Variable {cons(UnInitialized)}

        "{" results::(Expression ("," Expression)*) "|" generators::(Expression ("," Expression)*) "}" -> Comprehension {cons(Set)}

        "(" from::Expression ":" to::Expression "|" generators::(Expression ("," Expression)*) ")" -> Comprehension {cons(Map)}

        "[" results::(Expression ("," Expression)*) "|" generators::(Expression ("," Expression)*) "]" -> Comprehension {cons(List)}

        fieldIndex::IntegerLiteral -> Field {cons(Index)}

        fieldName::Name -> Field {cons(Name)}

        "[" parameters::(TypeVar ("," TypeVar)*) "]" -> ModuleParameters {cons(Default)}

        "extend" module::ImportedModule ";" -> Import {cons(Extend)}

        "import" module::ImportedModule ";" -> Import {cons(Default)}

        syntax::SyntaxDefinition -> Import {cons(Syntax)}

        name::QualifiedName -> ImportedModule {cons(Default)}

        name::QualifiedName actuals::ModuleActuals renamings::Renamings -> ImportedModule {cons(ActualsRenaming)}

        name::QualifiedName renamings::Renamings -> ImportedModule {cons(Renamings)}

        name::QualifiedName actuals::ModuleActuals -> ImportedModule {cons(Actuals)}

        "[" types::(Type ("," Type)*) "]" -> ModuleActuals {cons(Default)}

        "renaming" renamings::(Renaming ("," Renaming)*) -> Renamings {cons(Default)}

        from::Name "=>" to::Name -> Renaming {cons(Default)}

        "layout" defined::Sym "=" production::Prod ";" -> SyntaxDefinition {cons(Layout)}

        start::Start "syntax" defined::Sym "=" production::Prod ";" -> SyntaxDefinition {cons(Language)}

        symbol::Sym "+" -> Sym {cons(Iter)}

        "{" symbol::Sym sep::StringConstant "}" "+" -> Sym {cons(IterSep)}

        "@" column::IntegerLiteral -> Sym {cons(Column)}

        charClass::Class -> Sym {cons(CharacterClass)}

        string::StringConstant -> Sym {cons(Literal)}

        "$" -> Sym {cons(EndOfLine)}

        symbol::Sym label::NonterminalLabel -> Sym {cons(Labeled)}

        nonterminal::Nonterminal -> Sym {cons(Nonterminal)}

        "&" nonterminal::Nonterminal -> Sym {cons(Parameter)}

        symbol::Sym "*" -> Sym {cons(IterStar)}

        pnonterminal::ParameterizedNonterminal "[" parameters::(Sym ("," Sym)*) "]" -> Sym {cons(Parametrized)}

        symbol::Sym "?" -> Sym {cons(Optional)}

        "{" symbol::Sym sep::StringConstant "}" "*" -> Sym {cons(IterStarSep)}

        cistring::CaseInsensitiveStringConstant -> Sym {cons(CaseInsensitiveLiteral)}

        "^" -> Sym {cons(StartOfLine)}

        "[" ranges::(Range*) "]" -> Class {cons(SimpleCharclass)}

        "!" charClass::Class -> Class {cons(Complement)}

        lhs::Class "-" rhs::Class -> Class {cons(Difference)}

        lhs::Class "&&" rhs::Class -> Class {cons(Intersection)}

        lhs::Class "||" rhs::Class -> Class {cons(Union)}

        "(" charclass::Class ")" -> Class {cons(Bracket)}

        start::Char "-" end::Char -> Range {cons(FromTo)}

        character::Char -> Range {cons(Character)}

        ":" referenced::Name -> Prod {cons(Reference)}

        prod::Prod action::LanguageAction -> Prod {cons(Action)}

        modifiers::(ProdModifier*) name::Name ":" args::(Sym*) -> Prod {cons(Labeled)}

        "..." -> Prod {cons(Others)}

        modifiers::(ProdModifier*) args::(Sym*) -> Prod {cons(Unlabeled)}

        associativity::Assoc "(" group::Prod ")" -> Prod {cons(AssociativityGroup)}

        lhs::Prod "-" rhs::Prod -> Prod {cons(Reject)}

        lhs::Prod "#" rhs::Prod -> Prod {cons(Follow)}

        lhs::Prod "|" rhs::Prod -> Prod {cons(All)}

        lhs::Prod ">" rhs::Prod -> Prod {cons(First)}

        "=>" expression::Expression -> LanguageAction {cons(Build)}

        "{" statements::(Statement*) "}" -> LanguageAction {cons(Action)}

        associativity::Assoc -> ProdModifier {cons(Associativity)}

        "bracket" -> ProdModifier {cons(Bracket)}

        "lex" -> ProdModifier {cons(Lexical)}

        "assoc" -> Assoc {cons(Associative)}

        "left" -> Assoc {cons(Left)}

        "non-assoc" -> Assoc {cons(NonAssociative)}

        "right" -> Assoc {cons(Right)}

         -> Start {cons(Absent)}

        "start" -> Start {cons(Present)}

        toplevels::(Toplevel*) -> Body {cons(Toplevels)}

        declaration::Declaration -> Toplevel {cons(GivenVisibility)}

        tags::Tags visibility::Visibility type::Type variables::(Variable ("," Variable)*) ";" -> Declaration {cons(Variable)}

        tags::Tags visibility::Visibility "anno" annoType::Type onType::Type "@" name::Name ";" -> Declaration {cons(Annotation)}

        tags::Tags visibility::Visibility "view" view::Name "<:" superType::Name "=" alts::(Alternative ("|" Alternative)*) ";" -> Declaration {cons(View)}

        tags::Tags visibility::Visibility "alias" user::UserType "=" base::Type ";" -> Declaration {cons(Alias)}

        tags::Tags visibility::Visibility "tag" kind::Kind name::Name "on" types::(Type ("," Type)*) ";" -> Declaration {cons(Tag)}

        tags::Tags visibility::Visibility "data" user::UserType ";" -> Declaration {cons(DataAbstract)}

        tags::Tags visibility::Visibility "data" user::UserType "=" variants::(Variant ("|" Variant)*) ";" -> Declaration {cons(Data)}

        tags::Tags "rule" name::Name patternAction::PatternWithAction ";" -> Declaration {cons(Rule)}

        functionDeclaration::FunctionDeclaration -> Declaration {cons(Function)}

        test::Test ";" -> Declaration {cons(Test)}

        name::Name type::Type -> Alternative {cons(NamedType)}

        "function" -> Kind {cons(Function)}

        "variable" -> Kind {cons(Variable)}

        "all" -> Kind {cons(All)}

        "anno" -> Kind {cons(Anno)}

        "data" -> Kind {cons(Data)}

        "view" -> Kind {cons(View)}

        "rule" -> Kind {cons(Rule)}

        "alias" -> Kind {cons(Alias)}

        "module" -> Kind {cons(Module)}

        "tag" -> Kind {cons(Tag)}

        name::Name "(" arguments::((TypeArg ("," TypeArg)*)?) ")" -> Variant {cons(NAryConstructor)}

        tags::Tags "test" expression::Expression ":" labeled::StringLiteral -> Test {cons(Labeled)}

        tags::Tags "test" expression::Expression -> Test {cons(Unlabeled)}

        header::Header Marker Rest -> PreModule {cons(Default)}

        Word*; -> Rest

        expression::Expression -> Command {cons(Expression)}

        declaration::Declaration -> Command {cons(Declaration)}

        ":" command::ShellCommand -> Command {cons(Shell)}

        statement::Statement -> Command {cons(Statement)}

        imported::Import -> Command {cons(Import)}

        "set" name::QualifiedName expression::Expression -> ShellCommand {cons(SetOption)}

        "undeclare" name::QualifiedName -> ShellCommand {cons(Undeclare)}

        "help" -> ShellCommand {cons(Help)}

        "edit" name::QualifiedName -> ShellCommand {cons(Edit)}

        "unimport" name::QualifiedName -> ShellCommand {cons(Unimport)}

        "declarations" -> ShellCommand {cons(ListDeclarations)}

        "quit" -> ShellCommand {cons(Quit)}

        "history" -> ShellCommand {cons(History)}

        "test" -> ShellCommand {cons(Test)}

        "modules" -> ShellCommand {cons(ListModules)}
