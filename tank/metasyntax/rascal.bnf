[Default] Module:
        header::Header body::Body
[Parameters] Header:
        tags::Tags "module" name::QualifiedName params::ModuleParameters imports::(Import*)
[Default] Header:
        tags::Tags "module" name::QualifiedName imports::(Import*)
[Default] Tags:
        tags::(Tag*)
[Default] Tag:
        "@" name::Name contents::TagString
[Empty] Tag:
        "@" name::Name
[Expression] Tag:
        "@" name::Name "=" expression::Expression
[NonEmptyBlock] Expression:
        "{" statements::(Statement+) "}"
[Bracket] Expression:
        "(" expression::Expression ")"
[Closure] Expression:
        type::Type parameters::Parameters "{" statements::(Statement+) "}"
[StepRange] Expression:
        "[" first::Expression "," second::Expression ".." last::Expression "]"
[VoidClosure] Expression:
        parameters::Parameters "{" statements::(Statement*) "}"
[Visit] Expression:
        label::Label visit::Visit
[Reducer] Expression:
        "(" init::Expression "|" result::Expression "|" generators::(Expression ("," Expression)*) ")"
[ReifiedType] Expression:
        basicType::BasicType "(" arguments::((Expression ("," Expression)*)?) ")"
[CallOrTree] Expression:
        expression::Expression "(" arguments::((Expression ("," Expression)*)?) ")"
[Literal] Expression:
        literal::Literal
[Any] Expression:
        "any" "(" generators::(Expression ("," Expression)*) ")"
[All] Expression:
        "all" "(" generators::(Expression ("," Expression)*) ")"
[Comprehension] Expression:
        comprehension::Comprehension
[Set] Expression:
        "{" elements::((Expression ("," Expression)*)?) "}"
[List] Expression:
        "[" elements::((Expression ("," Expression)*)?) "]"
[ReifyType] Expression:
        "#" type::Type
[Range] Expression:
        "[" first::Expression ".." last::Expression "]"
[Tuple] Expression:
        "<" elements::(Expression ("," Expression)*) ">"
[Map] Expression:
        "(" mappings::((Mapping ("," Mapping)*)?) ")"
[It] Expression:
        "it"
[QualifiedName] Expression:
        qualifiedName::QualifiedName
[Subscript] Expression:
        expression::Expression "[" subscripts::(Expression ("," Expression)*) "]"
[FieldAccess] Expression:
        expression::Expression "." field::Name
[FieldUpdate] Expression:
        expression::Expression "[" key::Name "=" replacement::Expression "]"
[FieldProject] Expression:
        expression::Expression "<" fields::(Field ("," Field)*) ">"
[IsDefined] Expression:
        argument::Expression "?"
[Negation] Expression:
        "!" argument::Expression
[Negative] Expression:
        "-" argument::Expression
[TransitiveClosure] Expression:
        argument::Expression "+"
[TransitiveReflexiveClosure] Expression:
        argument::Expression "*"
[SetAnnotation] Expression:
        expression::Expression "[" "@" name::Name "=" value::Expression "]"
[GetAnnotation] Expression:
        expression::Expression "@" name::Name
[Composition] Expression:
        lhs::Expression "o" rhs::Expression
[Product] Expression:
        lhs::Expression "*" rhs::Expression
[Join] Expression:
        lhs::Expression "join" rhs::Expression
[Modulo] Expression:
        lhs::Expression "%" rhs::Expression
[Division] Expression:
        lhs::Expression "/" rhs::Expression
[Intersection] Expression:
        lhs::Expression "&" rhs::Expression
[Addition] Expression:
        lhs::Expression "+" rhs::Expression
[Subtraction] Expression:
        lhs::Expression "-" rhs::Expression
[NotIn] Expression:
        lhs::Expression "notin" rhs::Expression
[In] Expression:
        lhs::Expression "in" rhs::Expression
[GreaterThanOrEq] Expression:
        lhs::Expression ">=" rhs::Expression
[LessThanOrEq] Expression:
        lhs::Expression "<=" rhs::Expression
[LessThan] Expression:
        lhs::Expression "<" rhs::Expression
[GreaterThan] Expression:
        lhs::Expression ">" rhs::Expression
[IfThenElse] Expression:
        condition::Expression "?" thenExp::Expression ":" elseExp::Expression
[Equals] Expression:
        lhs::Expression "==" rhs::Expression
[NonEquals] Expression:
        lhs::Expression "!=" rhs::Expression
[IfDefinedOtherwise] Expression:
        lhs::Expression "?" rhs::Expression
[NoMatch] Expression:
        pattern::Pattern "!:=" expression::Expression
[Match] Expression:
        pattern::Pattern ":=" expression::Expression
[Enumerator] Expression:
        pattern::Pattern "<-" expression::Expression
[Implication] Expression:
        lhs::Expression "==>" rhs::Expression
[Equivalence] Expression:
        lhs::Expression "<==>" rhs::Expression
[And] Expression:
        lhs::Expression "&&" rhs::Expression
[Or] Expression:
        lhs::Expression "||" rhs::Expression
[Assert] Statement:
        "assert" expression::Expression ";"
[AssertWithMessage] Statement:
        "assert" expression::Expression ":" message::Expression ";"
[Expression] Statement:
        expression::Expression ";"
[Visit] Statement:
        label::Label visit::Visit
[While] Statement:
        label::Label "while" "(" conditions::(Expression ("," Expression)*) ")" body::Statement
[DoWhile] Statement:
        label::Label "do" body::Statement "while" "(" condition::Expression ")" ";"
[For] Statement:
        label::Label "for" "(" generators::(Expression ("," Expression)*) ")" body::Statement
[IfThen] Statement:
        label::Label "if" "(" conditions::(Expression ("," Expression)*) ")" thenStatement::Statement noElseMayFollow::NoElseMayFollow
[IfThenElse] Statement:
        label::Label "if" "(" conditions::(Expression ("," Expression)*) ")" thenStatement::Statement "else" elseStatement::Statement
[Switch] Statement:
        label::Label "switch" "(" expression::Expression ")" "{" cases::(Case+) "}"
[Fail] Statement:
        "fail" target::Target ";"
[Break] Statement:
        "break" target::Target ";"
[Continue] Statement:
        "continue" target::Target ";"
[Solve] Statement:
        "solve" "(" variables::(QualifiedName ("," QualifiedName)*) bound::Bound ")" body::Statement
[Try] Statement:
        "try" body::Statement handlers::(Catch+)
[TryFinally] Statement:
        "try" body::Statement handlers::(Catch+) "finally" finallyBody::Statement
[NonEmptyBlock] Statement:
        label::Label "{" statements::(Statement+) "}"
[EmptyStatement] Statement:
        ";"
[GlobalDirective] Statement:
        "global" type::Type names::(QualifiedName ("," QualifiedName)*) ";"
[Assignment] Statement:
        assignable::Assignable operator::Assignment statement::Statement
[Return] Statement:
        "return" statement::Statement
[Throw] Statement:
        "throw" statement::Statement
[Insert] Statement:
        "insert" dataTarget::DataTarget statement::Statement
[Append] Statement:
        "append" dataTarget::DataTarget statement::Statement
[FunctionDeclaration] Statement:
        functionDeclaration::FunctionDeclaration
[VariableDeclaration] Statement:
        declaration::LocalVariableDeclaration ";"
[Default] Label:
        name::Name ":"
[Empty] Label:
        EPSILON
[GivenStrategy] Visit:
        strategy::Strategy "visit" "(" subject::Expression ")" "{" cases::(Case+) "}"
[DefaultStrategy] Visit:
        "visit" "(" subject::Expression ")" "{" cases::(Case+) "}"
[TopDownBreak] Strategy:
        "top-down-break"
[TopDown] Strategy:
        "top-down"
[BottomUp] Strategy:
        "bottom-up"
[BottomUpBreak] Strategy:
        "bottom-up-break"
[Outermost] Strategy:
        "outermost"
[Innermost] Strategy:
        "innermost"
[PatternWithAction] Case:
        "case" patternWithAction::PatternWithAction
[Default] Case:
        "default" ":" statement::Statement
[Replacing] PatternWithAction:
        pattern::Pattern "=>" replacement::Replacement
[Arbitrary] PatternWithAction:
        pattern::Pattern ":" statement::Statement
[Set] Pattern:
        "{" elements::((Pattern ("," Pattern)*)?) "}"
[List] Pattern:
        "[" elements::((Pattern ("," Pattern)*)?) "]"
[QualifiedName] Pattern:
        qualifiedName::QualifiedName
[MultiVariable] Pattern:
        qualifiedName::QualifiedName "*"
[Literal] Pattern:
        literal::Literal
[Tuple] Pattern:
        "<" elements::(Pattern ("," Pattern)*) ">"
[TypedVariable] Pattern:
        type::Type name::Name
[Map] Pattern:
        "(" mappings::((Mapping ("," Mapping)*)?) ")"
[ReifiedType] Pattern:
        basicType::BasicType "(" arguments::((Pattern ("," Pattern)*)?) ")"
[CallOrTree] Pattern:
        expression::Pattern "(" arguments::((Pattern ("," Pattern)*)?) ")"
[VariableBecomes] Pattern:
        name::Name ":" pattern::Pattern
[Guarded] Pattern:
        "[" type::Type "]" pattern::Pattern
[Descendant] Pattern:
        "/" pattern::Pattern
[Anti] Pattern:
        "!" pattern::Pattern
[TypedVariableBecomes] Pattern:
        type::Type name::Name ":" pattern::Pattern
[Default] QualifiedName:
        names::(Name ("::" Name)*)
[Integer] Literal:
        integerLiteral::IntegerLiteral
[RegExp] Literal:
        regExpLiteral::RegExpLiteral
[Real] Literal:
        realLiteral::RealLiteral
[Boolean] Literal:
        booleanLiteral::BooleanLiteral
[String] Literal:
        stringLiteral::StringLiteral
[DateTime] Literal:
        dateTimeLiteral::DateTimeLiteral
[Location] Literal:
        locationLiteral::LocationLiteral
[DecimalIntegerLiteral] IntegerLiteral:
        decimal::DecimalIntegerLiteral
[HexIntegerLiteral] IntegerLiteral:
        hex::HexIntegerLiteral
[OctalIntegerLiteral] IntegerLiteral:
        octal::OctalIntegerLiteral
[Template] StringLiteral:
        pre::PreStringChars template::StringTemplate tail::StringTail
[Interpolated] StringLiteral:
        pre::PreStringChars expression::Expression tail::StringTail
[NonInterpolated] StringLiteral:
        constant::StringConstant
[IfThen] StringTemplate:
        "if" "(" conditions::(Expression ("," Expression)*) ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}"
[IfThenElse] StringTemplate:
        "if" "(" conditions::(Expression ("," Expression)*) ")" "{" preStatsThen::(Statement*) thenString::StringMiddle postStatsThen::(Statement*) "}" "else" "{" preStatsElse::(Statement*) elseString::StringMiddle postStatsElse::(Statement*) "}"
[For] StringTemplate:
        "for" "(" generators::(Expression ("," Expression)*) ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}"
[DoWhile] StringTemplate:
        "do" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}" "while" "(" condition::Expression ")"
[While] StringTemplate:
        "while" "(" condition::Expression ")" "{" preStats::(Statement*) body::StringMiddle postStats::(Statement*) "}"
[Mid] StringMiddle:
        mid::MidStringChars
[Template] StringMiddle:
        mid::MidStringChars template::StringTemplate tail::StringMiddle
[Interpolated] StringMiddle:
        mid::MidStringChars expression::Expression tail::StringMiddle
[MidInterpolated] StringTail:
        mid::MidStringChars expression::Expression tail::StringTail
[Post] StringTail:
        post::PostStringChars
[MidTemplate] StringTail:
        mid::MidStringChars template::StringTemplate tail::StringTail
[DateLiteral] DateTimeLiteral:
        date::JustDate
[TimeLiteral] DateTimeLiteral:
        time::JustTime
[DateAndTimeLiteral] DateTimeLiteral:
        dateAndTime::DateAndTime
[Default] LocationLiteral:
        protocolPart::ProtocolPart pathPart::PathPart
[NonInterpolated] ProtocolPart:
        protocolChars::ProtocolChars
[Interpolated] ProtocolPart:
        pre::PreProtocolChars expression::Expression tail::ProtocolTail
[Mid] ProtocolTail:
        mid::MidProtocolChars expression::Expression tail::ProtocolTail
[Post] ProtocolTail:
        post::PostProtocolChars
[NonInterpolated] PathPart:
        pathChars::PathChars
[Interpolated] PathPart:
        pre::PrePathChars expression::Expression tail::PathTail
[Mid] PathTail:
        mid::MidPathChars expression::Expression tail::PathTail
[Post] PathTail:
        post::PostPathChars
[Bracket] Type:
        "(" type::Type ")"
[User] Type:
        user::UserType
[Function] Type:
        function::FunctionType
[Structured] Type:
        structured::StructuredType
[Basic] Type:
        basic::BasicType
[Selector] Type:
        selector::DataTypeSelector
[Variable] Type:
        typeVar::TypeVar
[Symbol] Type:
        symbol::Symbol
[Name] UserType:
        name::QualifiedName
[Parametric] UserType:
        name::QualifiedName "[" parameters::(Type ("," Type)*) "]"
[TypeArguments] FunctionType:
        type::Type "(" arguments::((TypeArg ("," TypeArg)*)?) ")"
[Default] TypeArg:
        type::Type
[Named] TypeArg:
        type::Type name::Name
[Default] StructuredType:
        basicType::BasicType "[" arguments::(TypeArg ("," TypeArg)*) "]"
[Value] BasicType:
        "value"
[Loc] BasicType:
        "loc"
[Node] BasicType:
        "node"
[Num] BasicType:
        "num"
[ReifiedType] BasicType:
        "type"
[Bag] BasicType:
        "bag"
[Int] BasicType:
        "int"
[Relation] BasicType:
        "rel"
[ReifiedTypeParameter] BasicType:
        "parameter"
[Real] BasicType:
        "real"
[ReifiedFunction] BasicType:
        "fun"
[Tuple] BasicType:
        "tuple"
[String] BasicType:
        "str"
[Bool] BasicType:
        "bool"
[ReifiedReifiedType] BasicType:
        "reified"
[Void] BasicType:
        "void"
[ReifiedNonTerminal] BasicType:
        "non-terminal"
[DateTime] BasicType:
        "datetime"
[Set] BasicType:
        "set"
[Map] BasicType:
        "map"
[ReifiedConstructor] BasicType:
        "constructor"
[List] BasicType:
        "list"
[ReifiedAdt] BasicType:
        "adt"
[Lex] BasicType:
        "lex"
[Selector] DataTypeSelector:
        sort::QualifiedName "." production::Name
[Free] TypeVar:
        "&" name::Name
[Bounded] TypeVar:
        "&" name::Name "<:" bound::Type
[IterSep] Symbol:
        "{" symbol::Symbol sep::StrCon "}" "+"
[IterStarSep] Symbol:
        "{" symbol::Symbol sep::StrCon "}" "*"
[Sequence] Symbol:
        "(" head::Symbol tail::(Symbol+) ")"
[Empty] Symbol:
        "(" ")"
[CaseInsensitiveLiteral] Symbol:
        singelQuotedString::SingleQuotedStrCon
[Literal] Symbol:
        string::StrCon
[CharacterClass] Symbol:
        charClass::CharClass
[Optional] Symbol:
        symbol::Symbol "?"
[Iter] Symbol:
        symbol::Symbol "+"
[IterStar] Symbol:
        symbol::Symbol "*"
[Sort] Symbol:
        name::QualifiedName
[Alternative] Symbol:
        lhs::Symbol "|" rhs::Symbol
[Bracket] CharClass:
        "(" charClass::CharClass ")"
[SimpleCharclass] CharClass:
        "[" optionalCharRanges::OptCharRanges "]"
[Complement] CharClass:
        "~" charClass::CharClass
[Difference] CharClass:
        lhs::CharClass "/" rhs::CharClass
[Intersection] CharClass:
        lhs::CharClass "/\" rhs::CharClass
[Union] CharClass:
        lhs::CharClass "\/" rhs::CharClass
[Present] OptCharRanges:
        ranges::CharRanges
[Absent] OptCharRanges:
        EPSILON
[Concatenate] CharRanges:
        lhs::CharRanges rhs::CharRanges
[Range] CharRanges:
        range::CharRange
[Bracket] CharRanges:
        "(" ranges::CharRanges ")"
[Character] CharRange:
        character::Character
[Range] CharRange:
        start::Character "-" end::Character
[Numeric] Character:
        numChar::NumChar
[EOF] Character:
        "\EOF"
[Short] Character:
        shortChar::ShortChar
[Bottom] Character:
        "\BOT"
[Top] Character:
        "\TOP"
[Default] Mapping:
        from::&T ":" to::&T
[Unconditional] Replacement:
        replacementExpression::Expression
[Conditional] Replacement:
        replacementExpression::Expression "when" conditions::(Expression ("," Expression)*)
[Default] NoElseMayFollow:
        EPSILON
[Empty] Target:
        EPSILON
[Labeled] Target:
        name::Name
[Default] Bound:
        ";" expression::Expression
[Empty] Bound:
        EPSILON
[Default] Catch:
        "catch" ":" body::Statement
[Binding] Catch:
        "catch" pattern::Pattern ":" body::Statement
[Bracket] Assignable:
        "(" arg::Assignable ")"
[Variable] Assignable:
        qualifiedName::QualifiedName
[Subscript] Assignable:
        receiver::Assignable "[" subscript::Expression "]"
[FieldAccess] Assignable:
        receiver::Assignable "." field::Name
[IfDefinedOrDefault] Assignable:
        receiver::Assignable "?" defaultExpression::Expression
[Constructor] Assignable:
        name::Name "(" arguments::(Assignable ("," Assignable)*) ")"
[Tuple] Assignable:
        "<" elements::(Assignable ("," Assignable)*) ">"
[Annotation] Assignable:
        receiver::Assignable "@" annotation::Name
[IfDefined] Assignment:
        "?="
[Division] Assignment:
        "/="
[Product] Assignment:
        "*="
[Intersection] Assignment:
        "&="
[Subtraction] Assignment:
        "-="
[Default] Assignment:
        "="
[Addition] Assignment:
        "+="
[Empty] DataTarget:
        EPSILON
[Labeled] DataTarget:
        label::Name ":"
[Abstract] FunctionDeclaration:
        tags::Tags visibility::Visibility signature::Signature ";"
[Default] FunctionDeclaration:
        tags::Tags visibility::Visibility signature::Signature body::FunctionBody
[Private] Visibility:
        "private"
[Default] Visibility:
        EPSILON
[Public] Visibility:
        "public"
[WithThrows] Signature:
        type::Type modifiers::FunctionModifiers name::Name parameters::Parameters "throws" exceptions::(Type ("," Type)*)
[NoThrows] Signature:
        type::Type modifiers::FunctionModifiers name::Name parameters::Parameters
[List] FunctionModifiers:
        modifiers::(FunctionModifier*)
[Java] FunctionModifier:
        "java"
[Default] Parameters:
        "(" formals::Formals ")"
[VarArgs] Parameters:
        "(" formals::Formals "..." ")"
[Default] Formals:
        formals::((Formal ("," Formal)*)?)
[TypeName] Formal:
        type::Type name::Name
[Default] FunctionBody:
        "{" statements::(Statement*) "}"
[Default] LocalVariableDeclaration:
        declarator::Declarator
[Dynamic] LocalVariableDeclaration:
        "dynamic" declarator::Declarator
[Default] Declarator:
        type::Type variables::(Variable ("," Variable)*)
[Initialized] Variable:
        name::Name "=" initial::Expression
[UnInitialized] Variable:
        name::Name
[Set] Comprehension:
        "{" results::(Expression ("," Expression)*) "|" generators::(Expression ("," Expression)*) "}"
[Map] Comprehension:
        "(" from::Expression ":" to::Expression "|" generators::(Expression ("," Expression)*) ")"
[List] Comprehension:
        "[" results::(Expression ("," Expression)*) "|" generators::(Expression ("," Expression)*) "]"
[Index] Field:
        fieldIndex::IntegerLiteral
[Name] Field:
        fieldName::Name
[Default] ModuleParameters:
        "[" parameters::(TypeVar ("," TypeVar)*) "]"
[Extend] Import:
        "extend" module::ImportedModule ";"
[Default] Import:
        "import" module::ImportedModule ";"
[Syntax] Import:
        syntax::SyntaxDefinition
[Default] ImportedModule:
        name::QualifiedName
[ActualsRenaming] ImportedModule:
        name::QualifiedName actuals::ModuleActuals renamings::Renamings
[Renamings] ImportedModule:
        name::QualifiedName renamings::Renamings
[Actuals] ImportedModule:
        name::QualifiedName actuals::ModuleActuals
[Default] ModuleActuals:
        "[" types::(Type ("," Type)*) "]"
[Default] Renamings:
        "renaming" renamings::(Renaming ("," Renaming)*)
[Default] Renaming:
        from::Name "=>" to::Name
[Layout] SyntaxDefinition:
        "layout" defined::Sym "=" production::Prod ";"
[Language] SyntaxDefinition:
        start::Start "syntax" defined::Sym "=" production::Prod ";"
[Iter] Sym:
        symbol::Sym "+"
[IterSep] Sym:
        "{" symbol::Sym sep::StringConstant "}" "+"
[Column] Sym:
        "@" column::IntegerLiteral
[CharacterClass] Sym:
        charClass::Class
[Literal] Sym:
        string::StringConstant
[EndOfLine] Sym:
        "$"
[Labeled] Sym:
        symbol::Sym label::NonterminalLabel
[Nonterminal] Sym:
        nonterminal::Nonterminal
[Parameter] Sym:
        "&" nonterminal::Nonterminal
[IterStar] Sym:
        symbol::Sym "*"
[Parametrized] Sym:
        pnonterminal::ParameterizedNonterminal "[" parameters::(Sym ("," Sym)*) "]"
[Optional] Sym:
        symbol::Sym "?"
[IterStarSep] Sym:
        "{" symbol::Sym sep::StringConstant "}" "*"
[CaseInsensitiveLiteral] Sym:
        cistring::CaseInsensitiveStringConstant
[StartOfLine] Sym:
        "^"
[SimpleCharclass] Class:
        "[" ranges::(Range*) "]"
[Complement] Class:
        "!" charClass::Class
[Difference] Class:
        lhs::Class "-" rhs::Class
[Intersection] Class:
        lhs::Class "&&" rhs::Class
[Union] Class:
        lhs::Class "||" rhs::Class
[Bracket] Class:
        "(" charclass::Class ")"
[FromTo] Range:
        start::Char "-" end::Char
[Character] Range:
        character::Char
[Reference] Prod:
        ":" referenced::Name
[Action] Prod:
        prod::Prod action::LanguageAction
[Labeled] Prod:
        modifiers::(ProdModifier*) name::Name ":" args::(Sym*)
[Others] Prod:
        "..."
[Unlabeled] Prod:
        modifiers::(ProdModifier*) args::(Sym*)
[AssociativityGroup] Prod:
        associativity::Assoc "(" group::Prod ")"
[Reject] Prod:
        lhs::Prod "-" rhs::Prod
[Follow] Prod:
        lhs::Prod "#" rhs::Prod
[All] Prod:
        lhs::Prod "|" rhs::Prod
[First] Prod:
        lhs::Prod ">" rhs::Prod
[Build] LanguageAction:
        "=>" expression::Expression
[Action] LanguageAction:
        "{" statements::(Statement*) "}"
[Associativity] ProdModifier:
        associativity::Assoc
[Bracket] ProdModifier:
        "bracket"
[Lexical] ProdModifier:
        "lex"
[Associative] Assoc:
        "assoc"
[Left] Assoc:
        "left"
[NonAssociative] Assoc:
        "non-assoc"
[Right] Assoc:
        "right"
[Absent] Start:
        EPSILON
[Present] Start:
        "start"
[Toplevels] Body:
        toplevels::(Toplevel*)
[GivenVisibility] Toplevel:
        declaration::Declaration
[Variable] Declaration:
        tags::Tags visibility::Visibility type::Type variables::(Variable ("," Variable)*) ";"
[Annotation] Declaration:
        tags::Tags visibility::Visibility "anno" annoType::Type onType::Type "@" name::Name ";"
[View] Declaration:
        tags::Tags visibility::Visibility "view" view::Name "<:" superType::Name "=" alts::(Alternative ("|" Alternative)*) ";"
[Alias] Declaration:
        tags::Tags visibility::Visibility "alias" user::UserType "=" base::Type ";"
[Tag] Declaration:
        tags::Tags visibility::Visibility "tag" kind::Kind name::Name "on" types::(Type ("," Type)*) ";"
[DataAbstract] Declaration:
        tags::Tags visibility::Visibility "data" user::UserType ";"
[Data] Declaration:
        tags::Tags visibility::Visibility "data" user::UserType "=" variants::(Variant ("|" Variant)*) ";"
[Rule] Declaration:
        tags::Tags "rule" name::Name patternAction::PatternWithAction ";"
[Function] Declaration:
        functionDeclaration::FunctionDeclaration
[Test] Declaration:
        test::Test ";"
[NamedType] Alternative:
        name::Name type::Type
[Function] Kind:
        "function"
[Variable] Kind:
        "variable"
[All] Kind:
        "all"
[Anno] Kind:
        "anno"
[Data] Kind:
        "data"
[View] Kind:
        "view"
[Rule] Kind:
        "rule"
[Alias] Kind:
        "alias"
[Module] Kind:
        "module"
[Tag] Kind:
        "tag"
[NAryConstructor] Variant:
        name::Name "(" arguments::((TypeArg ("," TypeArg)*)?) ")"
[Labeled] Test:
        tags::Tags "test" expression::Expression ":" labeled::StringLiteral
[Unlabeled] Test:
        tags::Tags "test" expression::Expression
[Default] PreModule:
        header::Header Marker Rest
Rest:
        Word*;
[Expression] Command:
        expression::Expression
[Declaration] Command:
        declaration::Declaration
[Shell] Command:
        ":" command::ShellCommand
[Statement] Command:
        statement::Statement
[Import] Command:
        imported::Import
[SetOption] ShellCommand:
        "set" name::QualifiedName expression::Expression
[Undeclare] ShellCommand:
        "undeclare" name::QualifiedName
[Help] ShellCommand:
        "help"
[Edit] ShellCommand:
        "edit" name::QualifiedName
[Unimport] ShellCommand:
        "unimport" name::QualifiedName
[ListDeclarations] ShellCommand:
        "declarations"
[Quit] ShellCommand:
        "quit"
[History] ShellCommand:
        "history"
[Test] ShellCommand:
        "test"
[ListModules] ShellCommand:
        "modules"
