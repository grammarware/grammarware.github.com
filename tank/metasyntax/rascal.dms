Module = header::Header body::Body ;
Header = tags::Tags 'module' name::QualifiedName params::ModuleParameters imports::(Import*) ;
Header = tags::Tags 'module' name::QualifiedName imports::(Import*) ;
Tags = tags::(Tag*) ;
Tag = '@' name::Name contents::TagString ;
Tag = '@' name::Name ;
Tag = '@' name::Name '=' expression::Expression ;
Expression = '{' statements::(Statement+) '}' ;
Expression = '(' expression::Expression ')' ;
Expression = type::Type parameters::Parameters '{' statements::(Statement+) '}' ;
Expression = '[' first::Expression ',' second::Expression '..' last::Expression ']' ;
Expression = parameters::Parameters '{' statements::(Statement*) '}' ;
Expression = label::Label visit::Visit ;
Expression = '(' init::Expression '|' result::Expression '|' generators::(Expression (',' Expression)*) ')' ;
Expression = basicType::BasicType '(' arguments::((Expression (',' Expression)*)?) ')' ;
Expression = expression::Expression '(' arguments::((Expression (',' Expression)*)?) ')' ;
Expression = literal::Literal ;
Expression = 'any' '(' generators::(Expression (',' Expression)*) ')' ;
Expression = 'all' '(' generators::(Expression (',' Expression)*) ')' ;
Expression = comprehension::Comprehension ;
Expression = '{' elements::((Expression (',' Expression)*)?) '}' ;
Expression = '[' elements::((Expression (',' Expression)*)?) ']' ;
Expression = '#' type::Type ;
Expression = '[' first::Expression '..' last::Expression ']' ;
Expression = '<' elements::(Expression (',' Expression)*) '>' ;
Expression = '(' mappings::((Mapping (',' Mapping)*)?) ')' ;
Expression = 'it' ;
Expression = qualifiedName::QualifiedName ;
Expression = expression::Expression '[' subscripts::(Expression (',' Expression)*) ']' ;
Expression = expression::Expression '.' field::Name ;
Expression = expression::Expression '[' key::Name '=' replacement::Expression ']' ;
Expression = expression::Expression '<' fields::(Field (',' Field)*) '>' ;
Expression = argument::Expression '?' ;
Expression = '!' argument::Expression ;
Expression = '-' argument::Expression ;
Expression = argument::Expression '+' ;
Expression = argument::Expression '*' ;
Expression = expression::Expression '[' '@' name::Name '=' value::Expression ']' ;
Expression = expression::Expression '@' name::Name ;
Expression = lhs::Expression 'o' rhs::Expression ;
Expression = lhs::Expression '*' rhs::Expression ;
Expression = lhs::Expression 'join' rhs::Expression ;
Expression = lhs::Expression '%' rhs::Expression ;
Expression = lhs::Expression '/' rhs::Expression ;
Expression = lhs::Expression '&' rhs::Expression ;
Expression = lhs::Expression '+' rhs::Expression ;
Expression = lhs::Expression '-' rhs::Expression ;
Expression = lhs::Expression 'notin' rhs::Expression ;
Expression = lhs::Expression 'in' rhs::Expression ;
Expression = lhs::Expression '>=' rhs::Expression ;
Expression = lhs::Expression '<=' rhs::Expression ;
Expression = lhs::Expression '<' rhs::Expression ;
Expression = lhs::Expression '>' rhs::Expression ;
Expression = condition::Expression '?' thenExp::Expression ':' elseExp::Expression ;
Expression = lhs::Expression '==' rhs::Expression ;
Expression = lhs::Expression '!=' rhs::Expression ;
Expression = lhs::Expression '?' rhs::Expression ;
Expression = pattern::Pattern '!:=' expression::Expression ;
Expression = pattern::Pattern ':=' expression::Expression ;
Expression = pattern::Pattern '<-' expression::Expression ;
Expression = lhs::Expression '==>' rhs::Expression ;
Expression = lhs::Expression '<==>' rhs::Expression ;
Expression = lhs::Expression '&&' rhs::Expression ;
Expression = lhs::Expression '||' rhs::Expression ;
Statement = 'assert' expression::Expression ';' ;
Statement = 'assert' expression::Expression ':' message::Expression ';' ;
Statement = expression::Expression ';' ;
Statement = label::Label visit::Visit ;
Statement = label::Label 'while' '(' conditions::(Expression (',' Expression)*) ')' body::Statement ;
Statement = label::Label 'do' body::Statement 'while' '(' condition::Expression ')' ';' ;
Statement = label::Label 'for' '(' generators::(Expression (',' Expression)*) ')' body::Statement ;
Statement = label::Label 'if' '(' conditions::(Expression (',' Expression)*) ')' thenStatement::Statement noElseMayFollow::NoElseMayFollow ;
Statement = label::Label 'if' '(' conditions::(Expression (',' Expression)*) ')' thenStatement::Statement 'else' elseStatement::Statement ;
Statement = label::Label 'switch' '(' expression::Expression ')' '{' cases::(Case+) '}' ;
Statement = 'fail' target::Target ';' ;
Statement = 'break' target::Target ';' ;
Statement = 'continue' target::Target ';' ;
Statement = 'solve' '(' variables::(QualifiedName (',' QualifiedName)*) bound::Bound ')' body::Statement ;
Statement = 'try' body::Statement handlers::(Catch+) ;
Statement = 'try' body::Statement handlers::(Catch+) 'finally' finallyBody::Statement ;
Statement = label::Label '{' statements::(Statement+) '}' ;
Statement = ';' ;
Statement = 'global' type::Type names::(QualifiedName (',' QualifiedName)*) ';' ;
Statement = assignable::Assignable operator::Assignment statement::Statement ;
Statement = 'return' statement::Statement ;
Statement = 'throw' statement::Statement ;
Statement = 'insert' dataTarget::DataTarget statement::Statement ;
Statement = 'append' dataTarget::DataTarget statement::Statement ;
Statement = functionDeclaration::FunctionDeclaration ;
Statement = declaration::LocalVariableDeclaration ';' ;
Label = name::Name ':' ;
Label = ;
Visit = strategy::Strategy 'visit' '(' subject::Expression ')' '{' cases::(Case+) '}' ;
Visit = 'visit' '(' subject::Expression ')' '{' cases::(Case+) '}' ;
Strategy = 'top-down-break' ;
Strategy = 'top-down' ;
Strategy = 'bottom-up' ;
Strategy = 'bottom-up-break' ;
Strategy = 'outermost' ;
Strategy = 'innermost' ;
Case = 'case' patternWithAction::PatternWithAction ;
Case = 'default' ':' statement::Statement ;
PatternWithAction = pattern::Pattern '=>' replacement::Replacement ;
PatternWithAction = pattern::Pattern ':' statement::Statement ;
Pattern = '{' elements::((Pattern (',' Pattern)*)?) '}' ;
Pattern = '[' elements::((Pattern (',' Pattern)*)?) ']' ;
Pattern = qualifiedName::QualifiedName ;
Pattern = qualifiedName::QualifiedName '*' ;
Pattern = literal::Literal ;
Pattern = '<' elements::(Pattern (',' Pattern)*) '>' ;
Pattern = type::Type name::Name ;
Pattern = '(' mappings::((Mapping (',' Mapping)*)?) ')' ;
Pattern = basicType::BasicType '(' arguments::((Pattern (',' Pattern)*)?) ')' ;
Pattern = expression::Pattern '(' arguments::((Pattern (',' Pattern)*)?) ')' ;
Pattern = name::Name ':' pattern::Pattern ;
Pattern = '[' type::Type ']' pattern::Pattern ;
Pattern = '/' pattern::Pattern ;
Pattern = '!' pattern::Pattern ;
Pattern = type::Type name::Name ':' pattern::Pattern ;
QualifiedName = names::(Name ('::' Name)*) ;
Literal = integerLiteral::IntegerLiteral ;
Literal = regExpLiteral::RegExpLiteral ;
Literal = realLiteral::RealLiteral ;
Literal = booleanLiteral::BooleanLiteral ;
Literal = stringLiteral::StringLiteral ;
Literal = dateTimeLiteral::DateTimeLiteral ;
Literal = locationLiteral::LocationLiteral ;
IntegerLiteral = decimal::DecimalIntegerLiteral ;
IntegerLiteral = hex::HexIntegerLiteral ;
IntegerLiteral = octal::OctalIntegerLiteral ;
StringLiteral = pre::PreStringChars template::StringTemplate tail::StringTail ;
StringLiteral = pre::PreStringChars expression::Expression tail::StringTail ;
StringLiteral = constant::StringConstant ;
StringTemplate = 'if' '(' conditions::(Expression (',' Expression)*) ')' '{' preStats::(Statement*) body::StringMiddle postStats::(Statement*) '}' ;
StringTemplate = 'if' '(' conditions::(Expression (',' Expression)*) ')' '{' preStatsThen::(Statement*) thenString::StringMiddle postStatsThen::(Statement*) '}' 'else' '{' preStatsElse::(Statement*) elseString::StringMiddle postStatsElse::(Statement*) '}' ;
StringTemplate = 'for' '(' generators::(Expression (',' Expression)*) ')' '{' preStats::(Statement*) body::StringMiddle postStats::(Statement*) '}' ;
StringTemplate = 'do' '{' preStats::(Statement*) body::StringMiddle postStats::(Statement*) '}' 'while' '(' condition::Expression ')' ;
StringTemplate = 'while' '(' condition::Expression ')' '{' preStats::(Statement*) body::StringMiddle postStats::(Statement*) '}' ;
StringMiddle = mid::MidStringChars ;
StringMiddle = mid::MidStringChars template::StringTemplate tail::StringMiddle ;
StringMiddle = mid::MidStringChars expression::Expression tail::StringMiddle ;
StringTail = mid::MidStringChars expression::Expression tail::StringTail ;
StringTail = post::PostStringChars ;
StringTail = mid::MidStringChars template::StringTemplate tail::StringTail ;
DateTimeLiteral = date::JustDate ;
DateTimeLiteral = time::JustTime ;
DateTimeLiteral = dateAndTime::DateAndTime ;
LocationLiteral = protocolPart::ProtocolPart pathPart::PathPart ;
ProtocolPart = protocolChars::ProtocolChars ;
ProtocolPart = pre::PreProtocolChars expression::Expression tail::ProtocolTail ;
ProtocolTail = mid::MidProtocolChars expression::Expression tail::ProtocolTail ;
ProtocolTail = post::PostProtocolChars ;
PathPart = pathChars::PathChars ;
PathPart = pre::PrePathChars expression::Expression tail::PathTail ;
PathTail = mid::MidPathChars expression::Expression tail::PathTail ;
PathTail = post::PostPathChars ;
Type = '(' type::Type ')' ;
Type = user::UserType ;
Type = function::FunctionType ;
Type = structured::StructuredType ;
Type = basic::BasicType ;
Type = selector::DataTypeSelector ;
Type = typeVar::TypeVar ;
Type = symbol::Symbol ;
UserType = name::QualifiedName ;
UserType = name::QualifiedName '[' parameters::(Type (',' Type)*) ']' ;
FunctionType = type::Type '(' arguments::((TypeArg (',' TypeArg)*)?) ')' ;
TypeArg = type::Type ;
TypeArg = type::Type name::Name ;
StructuredType = basicType::BasicType '[' arguments::(TypeArg (',' TypeArg)*) ']' ;
BasicType = 'value' ;
BasicType = 'loc' ;
BasicType = 'node' ;
BasicType = 'num' ;
BasicType = 'type' ;
BasicType = 'bag' ;
BasicType = 'int' ;
BasicType = 'rel' ;
BasicType = 'parameter' ;
BasicType = 'real' ;
BasicType = 'fun' ;
BasicType = 'tuple' ;
BasicType = 'str' ;
BasicType = 'bool' ;
BasicType = 'reified' ;
BasicType = 'void' ;
BasicType = 'non-terminal' ;
BasicType = 'datetime' ;
BasicType = 'set' ;
BasicType = 'map' ;
BasicType = 'constructor' ;
BasicType = 'list' ;
BasicType = 'adt' ;
BasicType = 'lex' ;
DataTypeSelector = sort::QualifiedName '.' production::Name ;
TypeVar = '&' name::Name ;
TypeVar = '&' name::Name '<:' bound::Type ;
Symbol = '{' symbol::Symbol sep::StrCon '}' '+' ;
Symbol = '{' symbol::Symbol sep::StrCon '}' '*' ;
Symbol = '(' head::Symbol tail::(Symbol+) ')' ;
Symbol = '(' ')' ;
Symbol = singelQuotedString::SingleQuotedStrCon ;
Symbol = string::StrCon ;
Symbol = charClass::CharClass ;
Symbol = symbol::Symbol '?' ;
Symbol = symbol::Symbol '+' ;
Symbol = symbol::Symbol '*' ;
Symbol = name::QualifiedName ;
Symbol = lhs::Symbol '|' rhs::Symbol ;
CharClass = '(' charClass::CharClass ')' ;
CharClass = '[' optionalCharRanges::OptCharRanges ']' ;
CharClass = '~' charClass::CharClass ;
CharClass = lhs::CharClass '/' rhs::CharClass ;
CharClass = lhs::CharClass '/\' rhs::CharClass ;
CharClass = lhs::CharClass '\/' rhs::CharClass ;
OptCharRanges = ranges::CharRanges ;
OptCharRanges = ;
CharRanges = lhs::CharRanges rhs::CharRanges ;
CharRanges = range::CharRange ;
CharRanges = '(' ranges::CharRanges ')' ;
CharRange = character::Character ;
CharRange = start::Character '-' end::Character ;
Character = numChar::NumChar ;
Character = '\EOF' ;
Character = shortChar::ShortChar ;
Character = '\BOT' ;
Character = '\TOP' ;
Mapping = from::&T ':' to::&T ;
Replacement = replacementExpression::Expression ;
Replacement = replacementExpression::Expression 'when' conditions::(Expression (',' Expression)*) ;
NoElseMayFollow = ;
Target = ;
Target = name::Name ;
Bound = ';' expression::Expression ;
Bound = ;
Catch = 'catch' ':' body::Statement ;
Catch = 'catch' pattern::Pattern ':' body::Statement ;
Assignable = '(' arg::Assignable ')' ;
Assignable = qualifiedName::QualifiedName ;
Assignable = receiver::Assignable '[' subscript::Expression ']' ;
Assignable = receiver::Assignable '.' field::Name ;
Assignable = receiver::Assignable '?' defaultExpression::Expression ;
Assignable = name::Name '(' arguments::(Assignable (',' Assignable)*) ')' ;
Assignable = '<' elements::(Assignable (',' Assignable)*) '>' ;
Assignable = receiver::Assignable '@' annotation::Name ;
Assignment = '?=' ;
Assignment = '/=' ;
Assignment = '*=' ;
Assignment = '&=' ;
Assignment = '-=' ;
Assignment = '=' ;
Assignment = '+=' ;
DataTarget = ;
DataTarget = label::Name ':' ;
FunctionDeclaration = tags::Tags visibility::Visibility signature::Signature ';' ;
FunctionDeclaration = tags::Tags visibility::Visibility signature::Signature body::FunctionBody ;
Visibility = 'private' ;
Visibility = ;
Visibility = 'public' ;
Signature = type::Type modifiers::FunctionModifiers name::Name parameters::Parameters 'throws' exceptions::(Type (',' Type)*) ;
Signature = type::Type modifiers::FunctionModifiers name::Name parameters::Parameters ;
FunctionModifiers = modifiers::(FunctionModifier*) ;
FunctionModifier = 'java' ;
Parameters = '(' formals::Formals ')' ;
Parameters = '(' formals::Formals '...' ')' ;
Formals = formals::((Formal (',' Formal)*)?) ;
Formal = type::Type name::Name ;
FunctionBody = '{' statements::(Statement*) '}' ;
LocalVariableDeclaration = declarator::Declarator ;
LocalVariableDeclaration = 'dynamic' declarator::Declarator ;
Declarator = type::Type variables::(Variable (',' Variable)*) ;
Variable = name::Name '=' initial::Expression ;
Variable = name::Name ;
Comprehension = '{' results::(Expression (',' Expression)*) '|' generators::(Expression (',' Expression)*) '}' ;
Comprehension = '(' from::Expression ':' to::Expression '|' generators::(Expression (',' Expression)*) ')' ;
Comprehension = '[' results::(Expression (',' Expression)*) '|' generators::(Expression (',' Expression)*) ']' ;
Field = fieldIndex::IntegerLiteral ;
Field = fieldName::Name ;
ModuleParameters = '[' parameters::(TypeVar (',' TypeVar)*) ']' ;
Import = 'extend' module::ImportedModule ';' ;
Import = 'import' module::ImportedModule ';' ;
Import = syntax::SyntaxDefinition ;
ImportedModule = name::QualifiedName ;
ImportedModule = name::QualifiedName actuals::ModuleActuals renamings::Renamings ;
ImportedModule = name::QualifiedName renamings::Renamings ;
ImportedModule = name::QualifiedName actuals::ModuleActuals ;
ModuleActuals = '[' types::(Type (',' Type)*) ']' ;
Renamings = 'renaming' renamings::(Renaming (',' Renaming)*) ;
Renaming = from::Name '=>' to::Name ;
SyntaxDefinition = 'layout' defined::Sym '=' production::Prod ';' ;
SyntaxDefinition = start::Start 'syntax' defined::Sym '=' production::Prod ';' ;
Sym = symbol::Sym '+' ;
Sym = '{' symbol::Sym sep::StringConstant '}' '+' ;
Sym = '@' column::IntegerLiteral ;
Sym = charClass::Class ;
Sym = string::StringConstant ;
Sym = '$' ;
Sym = symbol::Sym label::NonterminalLabel ;
Sym = nonterminal::Nonterminal ;
Sym = '&' nonterminal::Nonterminal ;
Sym = symbol::Sym '*' ;
Sym = pnonterminal::ParameterizedNonterminal '[' parameters::(Sym (',' Sym)*) ']' ;
Sym = symbol::Sym '?' ;
Sym = '{' symbol::Sym sep::StringConstant '}' '*' ;
Sym = cistring::CaseInsensitiveStringConstant ;
Sym = '^' ;
Class = '[' ranges::(Range*) ']' ;
Class = '!' charClass::Class ;
Class = lhs::Class '-' rhs::Class ;
Class = lhs::Class '&&' rhs::Class ;
Class = lhs::Class '||' rhs::Class ;
Class = '(' charclass::Class ')' ;
Range = start::Char '-' end::Char ;
Range = character::Char ;
Prod = ':' referenced::Name ;
Prod = prod::Prod action::LanguageAction ;
Prod = modifiers::(ProdModifier*) name::Name ':' args::(Sym*) ;
Prod = '...' ;
Prod = modifiers::(ProdModifier*) args::(Sym*) ;
Prod = associativity::Assoc '(' group::Prod ')' ;
Prod = lhs::Prod '-' rhs::Prod ;
Prod = lhs::Prod '#' rhs::Prod ;
Prod = lhs::Prod '|' rhs::Prod ;
Prod = lhs::Prod '>' rhs::Prod ;
LanguageAction = '=>' expression::Expression ;
LanguageAction = '{' statements::(Statement*) '}' ;
ProdModifier = associativity::Assoc ;
ProdModifier = 'bracket' ;
ProdModifier = 'lex' ;
Assoc = 'assoc' ;
Assoc = 'left' ;
Assoc = 'non-assoc' ;
Assoc = 'right' ;
Start = ;
Start = 'start' ;
Body = toplevels::(Toplevel*) ;
Toplevel = declaration::Declaration ;
Declaration = tags::Tags visibility::Visibility type::Type variables::(Variable (',' Variable)*) ';' ;
Declaration = tags::Tags visibility::Visibility 'anno' annoType::Type onType::Type '@' name::Name ';' ;
Declaration = tags::Tags visibility::Visibility 'view' view::Name '<:' superType::Name '=' alts::(Alternative ('|' Alternative)*) ';' ;
Declaration = tags::Tags visibility::Visibility 'alias' user::UserType '=' base::Type ';' ;
Declaration = tags::Tags visibility::Visibility 'tag' kind::Kind name::Name 'on' types::(Type (',' Type)*) ';' ;
Declaration = tags::Tags visibility::Visibility 'data' user::UserType ';' ;
Declaration = tags::Tags visibility::Visibility 'data' user::UserType '=' variants::(Variant ('|' Variant)*) ';' ;
Declaration = tags::Tags 'rule' name::Name patternAction::PatternWithAction ';' ;
Declaration = functionDeclaration::FunctionDeclaration ;
Declaration = test::Test ';' ;
Alternative = name::Name type::Type ;
Kind = 'function' ;
Kind = 'variable' ;
Kind = 'all' ;
Kind = 'anno' ;
Kind = 'data' ;
Kind = 'view' ;
Kind = 'rule' ;
Kind = 'alias' ;
Kind = 'module' ;
Kind = 'tag' ;
Variant = name::Name '(' arguments::((TypeArg (',' TypeArg)*)?) ')' ;
Test = tags::Tags 'test' expression::Expression ':' labeled::StringLiteral ;
Test = tags::Tags 'test' expression::Expression ;
PreModule = header::Header Marker Rest ;
Rest = Word*; ;
Command = expression::Expression ;
Command = declaration::Declaration ;
Command = ':' command::ShellCommand ;
Command = statement::Statement ;
Command = imported::Import ;
ShellCommand = 'set' name::QualifiedName expression::Expression ;
ShellCommand = 'undeclare' name::QualifiedName ;
ShellCommand = 'help' ;
ShellCommand = 'edit' name::QualifiedName ;
ShellCommand = 'unimport' name::QualifiedName ;
ShellCommand = 'declarations' ;
ShellCommand = 'quit' ;
ShellCommand = 'history' ;
ShellCommand = 'test' ;
ShellCommand = 'modules' ;
